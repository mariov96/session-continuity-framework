#!/usr/bin/env python3
"""
SCF - Session Continuity Framework
Unified Command Line Interface

This replaces the 25+ separate Python scripts with a single, intuitive entry point.
Provides role-based onboarding and progressive complexity disclosure.
"""

import argparse
import sys
import json
import shutil
import subprocess
from pathlib import Path
from typing import Optional
from datetime import datetime, timezone

# Import existing SCF modules
try:
    from teach import main as teach_main, init_project, update_project
    from scf_enhanced_overview import generate_enhanced_overview
    from buildstate_hunter_learner import main as hunter_main
    from scf_sync_checker import check_sync_status
except ImportError as e:
    # Allow partial imports for hub-only operations
    pass

class SCFOnboarding:
    """Handles user onboarding and role selection"""

    def show_welcome(self):
        """Display welcome message and explain SCF concept"""
        print("""
ğŸš€ Welcome to Session Continuity Framework (SCF)

SCF gives your AI assistants perfect memory across all your development sessions.
Never lose context, never repeat explanations, always stay in flow.

Choose your role:
""")

    def choose_role(self) -> str:
        """Let user choose between hub and spoke modes"""
        print("1. ğŸ“Š Project Manager (Hub) - Manage multiple projects from one central location")
        print("2. ğŸ’» Solo Developer (Spoke) - Add AI memory to a single project")
        print("3. â“ Learn More - Understand the difference")

        while True:
            choice = input("\nEnter your choice (1/2/3): ").strip()
            if choice == "1":
                return "hub"
            elif choice == "2":
                return "spoke"
            elif choice == "3":
                self.explain_hub_spoke()
            else:
                print("Please enter 1, 2, or 3")

    def explain_hub_spoke(self):
        """Explain hub vs spoke concept clearly"""
        print("""
ğŸ—ï¸  Hub vs Spoke - Simple Explanation:

ğŸ¯ SPOKE MODE (Solo Developer):
   - You work on ONE project
   - SCF adds "memory" to that project
   - AI assistants remember all your conversations
   - Perfect for: Individual projects, focused development

ğŸ“Š HUB MODE (Project Manager):
   - You manage MULTIPLE projects
   - Central dashboard shows all project health
   - Share learnings between projects
   - Perfect for: Teams, consultants, multiple client projects

Most people start with SPOKE mode for their current project.
""")


class SCFHubManager:
    """Manages SCF Hub creation and configuration"""

    def __init__(self, framework_path: Path):
        self.framework_path = framework_path
        self.templates_dir = framework_path / 'templates' / 'hub'

    def create_hub(self, hub_path: Path, interactive: bool = True) -> bool:
        """Create a new SCF hub at the specified location"""
        hub_path = hub_path.expanduser().resolve()

        print(f"\nğŸ—ï¸  Creating SCF Hub at: {hub_path}\n")

        # Create hub directory
        hub_path.mkdir(parents=True, exist_ok=True)

        # Create .scf directory (hub is also a spoke tracking itself)
        scf_dir = hub_path / '.scf'
        scf_dir.mkdir(exist_ok=True)

        # Create .scf-registry directory
        registry_dir = hub_path / '.scf-registry'
        registry_dir.mkdir(exist_ok=True)
        (registry_dir / 'spokes').mkdir(exist_ok=True)

        # Gather user info if interactive
        user_info = {}
        if interactive:
            user_info = self._gather_user_info()

        # Create hub-profile.json
        self._create_hub_profile(hub_path, user_info)

        # Create spoke-projects.json
        self._create_spoke_registry(registry_dir)

        # Create hub's own buildstate (it's a spoke tracking itself)
        self._create_hub_buildstate(scf_dir, hub_path)

        # Create learnings directory
        learnings_dir = hub_path / 'learnings'
        learnings_dir.mkdir(exist_ok=True)

        print(f"\nâœ… Hub created successfully at: {hub_path}")
        print(f"\nğŸ“ Structure created:")
        print(f"   {hub_path}/")
        print(f"   â”œâ”€â”€ .scf/                  # Hub's own buildstate")
        print(f"   â”œâ”€â”€ .scf-registry/         # Project registry")
        print(f"   â”‚   â”œâ”€â”€ spokes/            # Individual spoke tracking")
        print(f"   â”‚   â””â”€â”€ spoke-projects.json")
        print(f"   â”œâ”€â”€ hub-profile.json       # Your preferences")
        print(f"   â””â”€â”€ learnings/             # Cross-project patterns")

        # Discover existing projects
        if interactive:
            self._discover_existing_projects(hub_path, registry_dir)

        print(f"\nğŸš€ Next steps:")
        print(f"   1. Run 'scf hub status' to see connected projects")
        print(f"   2. Run 'scf init <path>' to add more projects")

        return True

    def _discover_existing_projects(self, hub_path: Path, registry_dir: Path):
        """Interactively discover and intake existing projects"""
        print(f"\nğŸ“‚ Project Discovery")
        print(f"=" * 50)

        discover = input("\nDo you have existing projects to discover? [Y/n]: ").strip().lower()
        if discover == 'n':
            print("   Skipping project discovery.")
            return

        # Get scan locations
        scan_paths = []
        print("\nEnter directories to scan for projects (one per line).")
        print("Common locations: ~/projects, ~/code, ~/work")
        print("Press Enter with empty line when done.\n")

        while True:
            path_input = input("   Scan path: ").strip()
            if not path_input:
                break
            scan_path = Path(path_input).expanduser()
            if scan_path.exists() and scan_path.is_dir():
                scan_paths.append(scan_path)
                print(f"   âœ“ Added: {scan_path}")
            else:
                print(f"   âœ— Path not found: {scan_path}")

        if not scan_paths:
            # Default to common locations
            default_paths = [Path.home() / 'projects', Path.home() / 'code']
            for dp in default_paths:
                if dp.exists():
                    scan_paths.append(dp)
            if scan_paths:
                print(f"\n   Using default paths: {', '.join(str(p) for p in scan_paths)}")

        if not scan_paths:
            print("   No valid paths to scan.")
            return

        # Scan for projects
        print(f"\nğŸ” Scanning for projects...")
        discovered = self._scan_for_projects(scan_paths)

        if not discovered:
            print("   No projects found.")
            return

        # Separate SCF-enabled from regular projects
        scf_projects = [p for p in discovered if p.get('scf_enabled')]
        regular_projects = [p for p in discovered if not p.get('scf_enabled')]

        print(f"\nğŸ“Š Found {len(discovered)} projects:")
        print(f"   â€¢ {len(scf_projects)} SCF-enabled (have .scf/ folder)")
        print(f"   â€¢ {len(regular_projects)} regular projects")

        # Present SCF-enabled projects first
        if scf_projects:
            print(f"\nğŸŒŸ SCF-Enabled Projects (already have context):")
            print("-" * 50)
            for proj in scf_projects:
                self._present_project(proj, is_scf=True)

        # Present regular projects
        if regular_projects:
            print(f"\nğŸ“ Regular Projects (can add SCF):")
            print("-" * 50)
            for proj in regular_projects:
                self._present_project(proj, is_scf=False)

        # Let user select which to intake
        print(f"\nğŸ“¥ Project Intake")
        print("-" * 50)
        print("For each project, choose: [Y]es intake, [N]o skip, [A]ll remaining, [Q]uit\n")

        intake_list = []
        skip_remaining = False
        intake_remaining = False

        for proj in discovered:
            if skip_remaining:
                break
            if intake_remaining:
                intake_list.append(proj)
                continue

            status = "ğŸŒŸ SCF" if proj.get('scf_enabled') else "ğŸ“ New"
            print(f"{status} {proj['name']}")
            if proj.get('scf_enabled') and proj.get('description'):
                print(f"      â””â”€ {proj['description'][:60]}...")

            choice = input(f"   Intake? [Y/n/a/q]: ").strip().lower()

            if choice == 'q':
                skip_remaining = True
            elif choice == 'a':
                intake_remaining = True
                intake_list.append(proj)
            elif choice != 'n':
                intake_list.append(proj)

        # Register selected projects
        if intake_list:
            self._register_projects(registry_dir, intake_list, hub_path)
            print(f"\nâœ… Registered {len(intake_list)} projects with hub")
        else:
            print("\n   No projects selected for intake.")

    def _scan_for_projects(self, scan_paths: list) -> list:
        """Scan directories for projects (looks for git repos or common project markers)"""
        discovered = []
        seen_paths = set()

        for scan_path in scan_paths:
            # Look for immediate subdirectories that look like projects
            try:
                for item in scan_path.iterdir():
                    if not item.is_dir():
                        continue
                    if item.name.startswith('.'):
                        continue
                    if str(item.resolve()) in seen_paths:
                        continue

                    # Check if it's a project
                    is_git = (item / '.git').exists()
                    is_scf = (item / '.scf').exists() or (item / 'buildstate.json').exists()
                    has_package = (item / 'package.json').exists()
                    has_pyproject = (item / 'pyproject.toml').exists() or (item / 'setup.py').exists()
                    has_cargo = (item / 'Cargo.toml').exists()

                    if is_git or is_scf or has_package or has_pyproject or has_cargo:
                        proj_info = {
                            'name': item.name,
                            'path': str(item.resolve()),
                            'scf_enabled': is_scf,
                            'has_git': is_git,
                            'description': None,
                            'project_type': None
                        }

                        # If SCF-enabled, read additional details
                        if is_scf:
                            proj_info.update(self._read_scf_details(item))

                        discovered.append(proj_info)
                        seen_paths.add(str(item.resolve()))

            except PermissionError:
                continue

        return sorted(discovered, key=lambda x: (not x['scf_enabled'], x['name'].lower()))

    def _read_scf_details(self, project_path: Path) -> dict:
        """Read details from SCF-enabled project"""
        details = {}

        # Try .scf/BUILDSTATE.json first, then buildstate.json
        buildstate_paths = [
            project_path / '.scf' / 'BUILDSTATE.json',
            project_path / 'buildstate.json'
        ]

        for bs_path in buildstate_paths:
            if bs_path.exists():
                try:
                    with open(bs_path) as f:
                        data = json.load(f)

                    # Extract useful info
                    if 'project' in data:
                        details['description'] = data['project'].get('description')
                        details['project_type'] = data['project'].get('type')

                    if '_project_foundation' in data:
                        foundation = data['_project_foundation']
                        if foundation.get('identity'):
                            details['description'] = details.get('description') or foundation['identity'].get('one_liner')
                            details['project_type'] = details.get('project_type') or foundation['identity'].get('type')

                    if '_scf_metadata' in data:
                        details['scf_version'] = data['_scf_metadata'].get('version')
                        details['hub_path'] = data['_scf_metadata'].get('hub_path')

                    break
                except (json.JSONDecodeError, KeyError):
                    pass

        return details

    def _present_project(self, proj: dict, is_scf: bool):
        """Display project info"""
        print(f"\n   ğŸ“¦ {proj['name']}")
        print(f"      Path: {proj['path']}")
        if is_scf:
            if proj.get('description'):
                print(f"      Desc: {proj['description']}")
            if proj.get('project_type'):
                print(f"      Type: {proj['project_type']}")
            if proj.get('scf_version'):
                print(f"      SCF:  v{proj['scf_version']}")
        else:
            markers = []
            if proj.get('has_git'):
                markers.append('git')
            print(f"      Markers: {', '.join(markers) if markers else 'directory'}")

    def _register_projects(self, registry_dir: Path, projects: list, hub_path: Path):
        """Register projects in the spoke registry"""
        registry_path = registry_dir / 'spoke-projects.json'

        # Load existing registry
        if registry_path.exists():
            with open(registry_path) as f:
                registry = json.load(f)
        else:
            registry = {"version": "1.0", "projects": [], "last_scan": None}

        # Add projects
        existing_paths = {p.get('path') for p in registry.get('projects', [])}

        for proj in projects:
            if proj['path'] not in existing_paths:
                registry['projects'].append({
                    'name': proj['name'],
                    'path': proj['path'],
                    'type': proj.get('project_type', 'unknown'),
                    'scf_enabled': proj.get('scf_enabled', False),
                    'added_at': datetime.now(timezone.utc).isoformat(),
                    'last_sync': None
                })

                # Update spoke's hub_path if SCF-enabled
                if proj.get('scf_enabled'):
                    self._update_spoke_hub_path(Path(proj['path']), hub_path)

        registry['last_scan'] = datetime.now(timezone.utc).isoformat()

        with open(registry_path, 'w') as f:
            json.dump(registry, f, indent=2)

    def _update_spoke_hub_path(self, project_path: Path, hub_path: Path):
        """Update a spoke's hub_path to point to this hub"""
        buildstate_paths = [
            project_path / '.scf' / 'BUILDSTATE.json',
            project_path / 'buildstate.json'
        ]

        for bs_path in buildstate_paths:
            if bs_path.exists():
                try:
                    with open(bs_path) as f:
                        data = json.load(f)

                    if '_scf_metadata' in data:
                        data['_scf_metadata']['hub_path'] = str(hub_path)

                        with open(bs_path, 'w') as f:
                            json.dump(data, f, indent=2)
                        break
                except (json.JSONDecodeError, KeyError):
                    pass

    def _gather_user_info(self) -> dict:
        """Interactive user info gathering"""
        print("ğŸ“‹ Let's personalize your hub:\n")

        name = input("   What name should AI partners call you? ").strip()

        print("\n   What's your primary development focus?")
        print("   (e.g., 'Full-stack web, Python automation')")
        focus = input("   > ").strip()

        print("\n   How do you prefer AI collaboration?")
        print("   [1] Autonomous - Take initiative, check in on big decisions")
        print("   [2] Collaborative - Discuss approach before implementing")
        print("   [3] Supervised - Always ask before acting")

        while True:
            style_choice = input("   > ").strip()
            if style_choice == "1":
                style = "autonomous"
                break
            elif style_choice == "2":
                style = "collaborative"
                break
            elif style_choice == "3":
                style = "supervised"
                break
            else:
                print("   Please enter 1, 2, or 3")

        return {
            'name': name,
            'focus': focus,
            'style': style
        }

    def _create_hub_profile(self, hub_path: Path, user_info: dict):
        """Create hub-profile.json with user info"""
        profile_template = self.templates_dir / 'hub-profile.json'

        if profile_template.exists():
            with open(profile_template) as f:
                profile = json.load(f)
        else:
            profile = {
                "user": {"name": None},
                "work_style": {"description": None},
                "hub_config": {}
            }

        # Fill in user info
        profile['user']['name'] = user_info.get('name', 'Developer')
        profile['work_style']['description'] = user_info.get('focus', '')
        profile['work_style']['ai_collaboration_style'] = user_info.get('style', 'collaborative')
        profile['hub_config']['created_at'] = datetime.now(timezone.utc).isoformat()
        profile['hub_config']['hub_path'] = str(hub_path)
        profile['hub_config']['framework_path'] = str(self.framework_path)

        profile_path = hub_path / 'hub-profile.json'
        with open(profile_path, 'w') as f:
            json.dump(profile, f, indent=2)

        print(f"   âœ… Created hub-profile.json")

    def _create_spoke_registry(self, registry_dir: Path):
        """Create spoke-projects.json registry"""
        registry_template = self.templates_dir / 'spoke-projects.json'

        if registry_template.exists():
            shutil.copy2(registry_template, registry_dir / 'spoke-projects.json')
        else:
            registry = {
                "version": "1.0",
                "projects": [],
                "last_scan": None
            }
            with open(registry_dir / 'spoke-projects.json', 'w') as f:
                json.dump(registry, f, indent=2)

        print(f"   âœ… Created spoke registry")

    def _create_hub_buildstate(self, scf_dir: Path, hub_path: Path):
        """Create hub's own buildstate (hub tracks itself as a spoke)"""
        buildstate = {
            "_scf_metadata": {
                "version": "2.2.0",
                "structure_version": "v2",
                "description": "SCF Hub - Your personal learning center",
                "is_hub": True,
                "hub_path": str(hub_path)
            },
            "_project_foundation": {
                "completed": True,
                "completed_at": datetime.now(timezone.utc).isoformat(),
                "identity": {
                    "type": "hub",
                    "name": "SCF Hub",
                    "one_liner": "Central hub for cross-project learnings",
                    "success_looks_like": "All projects connected, learnings flowing"
                },
                "boundaries": {
                    "in_scope": ["User preferences", "Project registry", "Cross-project learnings"],
                    "out_of_scope": ["Individual project code", "Framework development"]
                }
            },
            "_session_state": {
                "last_modified_by": "scf hub create",
                "last_modified_at": datetime.now(timezone.utc).isoformat(),
                "session_count": 1
            },
            "project": {
                "name": "SCF Hub",
                "type": "hub",
                "created": datetime.now(timezone.utc).isoformat()
            }
        }

        with open(scf_dir / 'BUILDSTATE.json', 'w') as f:
            json.dump(buildstate, f, indent=2)

        print(f"   âœ… Created hub buildstate")

    @staticmethod
    def find_hub() -> Optional[Path]:
        """Find existing hub location"""
        # Check common locations
        common_paths = [
            Path.home() / 'scf-hub',
            Path.home() / '.scf-hub',
            Path.home() / 'projects' / 'scf-hub'
        ]

        for path in common_paths:
            if (path / 'hub-profile.json').exists():
                return path

        # Check environment variable
        import os
        env_hub = os.environ.get('SCF_HUB_PATH')
        if env_hub:
            env_path = Path(env_hub).expanduser()
            if env_path.exists():
                return env_path

        return None


class SCFHubMenu:
    """Interactive menu-driven interface for SCF Hub"""

    def __init__(self, hub_path: Path, hub_manager, framework_path: Path):
        self.hub_path = hub_path
        self.hub_manager = hub_manager
        self.framework_path = framework_path
        self.registry_path = hub_path / '.scf-registry' / 'spoke-projects.json'

    def clear_screen(self):
        """Clear terminal screen"""
        import os
        os.system('clear' if os.name != 'nt' else 'cls')

    def wait_for_enter(self):
        """Wait for user to press Enter"""
        input("\n   Press Enter to continue...")

    def get_choice(self, max_choice: int, allow_back: bool = True) -> str:
        """Get user menu choice"""
        while True:
            choice = input("\n   Enter choice: ").strip().lower()
            if choice == 'q':
                return 'q'
            if allow_back and choice in ('b', 'back', '0'):
                return 'b'
            if choice.isdigit() and 1 <= int(choice) <= max_choice:
                return choice
            print(f"   Please enter 1-{max_choice}" + (", b for back, or q to quit" if allow_back else " or q to quit"))

    def load_registry(self) -> dict:
        """Load project registry"""
        if self.registry_path.exists():
            with open(self.registry_path) as f:
                return json.load(f)
        return {"version": "1.0", "projects": []}

    def save_registry(self, registry: dict):
        """Save project registry"""
        with open(self.registry_path, 'w') as f:
            json.dump(registry, f, indent=2)

    def load_profile(self) -> dict:
        """Load hub profile"""
        profile_path = self.hub_path / 'hub-profile.json'
        if profile_path.exists():
            with open(profile_path) as f:
                return json.load(f)
        return {}

    def run(self):
        """Main menu loop"""
        while True:
            action = self.main_menu()
            if action == 'q':
                print("\nğŸ‘‹ Goodbye!\n")
                break

    def main_menu(self) -> str:
        """Display main hub menu"""
        self.clear_screen()
        profile = self.load_profile()
        registry = self.load_registry()
        projects = registry.get('projects', [])
        scf_count = sum(1 for p in projects if p.get('scf_enabled'))

        user_name = profile.get('user', {}).get('name', 'Developer')

        print(f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    ğŸ“Š SCF Hub Manager                        â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  ğŸ‘¤ {user_name:<20}  ğŸ“ {len(projects)} projects ({scf_count} SCF)       â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

   1. ğŸ“ Projects        - View and manage projects
   2. ğŸ“‚ Groups          - Organize projects into groups
   3. ğŸ” Scan            - Discover new projects
   4. ğŸ§  Learn           - Gather learnings from projects
   5. ğŸ“š Teach           - Push learnings to projects
   6. ğŸ“Š Statistics      - View detailed stats
   7. âš™ï¸  Settings        - Hub configuration

   q. Quit
""")
        choice = self.get_choice(7, allow_back=False)

        if choice == '1':
            self.projects_menu()
        elif choice == '2':
            self.groups_menu()
        elif choice == '3':
            self.scan_menu()
        elif choice == '4':
            self.learn_menu()
        elif choice == '5':
            self.teach_menu()
        elif choice == '6':
            self.stats_menu()
        elif choice == '7':
            self.settings_menu()

        return choice

    def projects_menu(self):
        """Projects management menu"""
        while True:
            self.clear_screen()
            registry = self.load_registry()
            projects = registry.get('projects', [])

            # Quick refresh of SCF status for each project
            status_changed = False
            for proj in projects:
                proj_path = Path(proj.get('path', '')).expanduser()
                if proj_path.exists():
                    current_scf = ((proj_path / '.scf').exists() or
                                   (proj_path / 'buildstate.json').exists() or
                                   (proj_path / 'BUILDSTATE.json').exists())
                    if proj.get('scf_enabled') != current_scf:
                        proj['scf_enabled'] = current_scf
                        status_changed = True

            if status_changed:
                self.save_registry(registry)

            print(f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    ğŸ“ Projects ({len(projects)})                          â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
""")
            if not projects:
                print("   No projects registered yet.\n")
                print("   1. â• Add a project")
                print("   2. ğŸ” Scan for projects")
                print("\n   b. Back to main menu")

                choice = self.get_choice(2)
                if choice == '1':
                    self.add_project()
                elif choice == '2':
                    self.scan_menu()
                elif choice in ('b', 'q'):
                    return
            else:
                # List all projects with size info if available
                for i, proj in enumerate(projects, 1):
                    status = "ğŸŒŸ" if proj.get('scf_enabled') else "ğŸ“"
                    group = f" [{proj.get('group', '')}]" if proj.get('group') else ""
                    size_info = ""
                    if proj.get('file_count'):
                        size_info = f" ({proj['file_count']} files)"
                    print(f"   {i:2}. {status} {proj['name']}{group}{size_info}")

                print(f"""
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   a. â• Add projects (scan a folder)
   r. ğŸ”„ Rescan project(s)
   d. ğŸ—‘ï¸  Delete a project
   v. ğŸ‘ï¸  View project details
   l. ğŸ“‹ List verbose (detailed view)

   b. Back to main menu
""")
                choice = input("   Enter choice (number or letter): ").strip().lower()

                if choice == 'b':
                    return
                elif choice == 'q':
                    return
                elif choice == 'a':
                    self.add_project()
                elif choice == 'r':
                    self.rescan_projects(projects)
                elif choice == 'd':
                    self.remove_project(projects)
                elif choice == 'v':
                    self.view_project_select(projects)
                elif choice == 'l':
                    self.list_projects_verbose(projects)
                elif choice.isdigit() and 1 <= int(choice) <= len(projects):
                    self.view_project(projects[int(choice) - 1])

    def list_projects_verbose(self, projects: list):
        """Show detailed view of all projects"""
        self.clear_screen()
        print(f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘              ğŸ“‹ Projects - Detailed View ({len(projects)})                 â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
""")
        # Summary stats
        scf_count = sum(1 for p in projects if p.get('scf_enabled'))
        total_files = sum(p.get('file_count', 0) for p in projects)
        total_size = sum(p.get('size_bytes', 0) for p in projects)

        print(f"   Summary: {scf_count} SCF-enabled, {len(projects) - scf_count} regular")
        print(f"   Total: {total_files:,} files, {self._format_size(total_size)}")
        print(f"   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n")

        for i, proj in enumerate(projects, 1):
            status = "ğŸŒŸ" if proj.get('scf_enabled') else "ğŸ“"
            group = f"[{proj.get('group')}] " if proj.get('group') else ""

            print(f"   {i:2}. {status} {group}{proj['name']}")
            print(f"       Path: {proj.get('path', 'unknown')}")

            # Size and files
            files = proj.get('file_count', 0)
            size = proj.get('size_bytes', 0)
            if files or size:
                print(f"       Size: {self._format_size(size)} ({files:,} files)")

            # Languages and frameworks
            langs = proj.get('languages', [])
            frameworks = proj.get('frameworks', [])
            if langs:
                tech = ', '.join(langs[:3])
                if frameworks:
                    tech += f" + {', '.join(frameworks[:2])}"
                print(f"       Tech: {tech}")

            # Dates
            created = proj.get('created_at', '')[:10] if proj.get('created_at') else None
            scanned = proj.get('last_scanned', '')[:10] if proj.get('last_scanned') else None
            added = proj.get('added_at', '')[:10] if proj.get('added_at') else None

            dates = []
            if created:
                dates.append(f"Started: {created}")
            if added:
                dates.append(f"Added: {added}")
            if scanned:
                dates.append(f"Scanned: {scanned}")
            if dates:
                print(f"       Dates: {' | '.join(dates)}")

            # Features
            features = []
            if proj.get('has_tests'):
                features.append("tests")
            if proj.get('has_ci'):
                features.append("CI/CD")
            if proj.get('scf_enabled'):
                features.append("SCF")
            if features:
                print(f"       Features: {', '.join(features)}")

            # Description
            if proj.get('description'):
                desc = proj['description'][:60] + "..." if len(proj.get('description', '')) > 60 else proj['description']
                print(f"       Desc: {desc}")

            print()  # Blank line between projects

        self.wait_for_enter()

    def groups_menu(self):
        """Groups management menu"""
        while True:
            self.clear_screen()
            registry = self.load_registry()
            groups = registry.get('groups', {})
            projects = registry.get('projects', [])

            print(f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    ğŸ“‚ Project Groups                         â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
""")
            if not groups:
                print("   No groups created yet.\n")
            else:
                for name, info in sorted(groups.items()):
                    member_count = sum(1 for p in projects if p.get('group') == name)
                    desc = info.get('description', '')
                    print(f"   ğŸ“‚ {name} ({member_count} projects)")
                    if desc:
                        print(f"      â””â”€ {desc}")
                print()

            # Show ungrouped projects
            ungrouped = [p for p in projects if not p.get('group')]
            if ungrouped:
                print(f"   ğŸ“ Ungrouped: {len(ungrouped)} projects\n")

            print("""   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   1. â• Create new group
   2. âœï¸  Assign projects to group
   3. â– Remove projects from group
   4. ğŸ—‘ï¸  Delete a group
   5. ğŸ‘ï¸  View group members

   b. Back to main menu
""")
            choice = self.get_choice(5)

            if choice == 'b':
                return
            elif choice == '1':
                self.create_group()
            elif choice == '2':
                self.assign_to_group()
            elif choice == '3':
                self.remove_from_group()
            elif choice == '4':
                self.delete_group()
            elif choice == '5':
                self.view_group()

    def create_group(self):
        """Create a new group"""
        self.clear_screen()
        print("""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    â• Create Group                            â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
""")
        name = input("   Group name (e.g., work, personal, client-x): ").strip().lower()

        if not name:
            return

        # Sanitize name
        name = name.replace(' ', '-')

        registry = self.load_registry()
        if 'groups' not in registry:
            registry['groups'] = {}

        if name in registry['groups']:
            print(f"\n   âš ï¸  Group '{name}' already exists")
            self.wait_for_enter()
            return

        desc = input("   Description (optional): ").strip()

        registry['groups'][name] = {
            'description': desc,
            'created_at': datetime.now(timezone.utc).isoformat()
        }
        self.save_registry(registry)

        print(f"\n   âœ… Created group: {name}")
        self.wait_for_enter()

    def assign_to_group(self):
        """Assign projects to a group"""
        self.clear_screen()
        registry = self.load_registry()
        groups = registry.get('groups', {})
        projects = registry.get('projects', [])

        if not groups:
            print("\n   âŒ No groups created yet. Create a group first.")
            self.wait_for_enter()
            return

        print("""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    âœï¸  Assign to Group                        â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

   Select a group:
""")
        group_list = sorted(groups.keys())
        for i, name in enumerate(group_list, 1):
            print(f"   {i}. ğŸ“‚ {name}")

        print("\n   c. Cancel\n")
        choice = input("   Selection: ").strip().lower()

        if choice == 'c':
            return

        if not choice.isdigit() or not (1 <= int(choice) <= len(group_list)):
            print("   âŒ Invalid selection")
            self.wait_for_enter()
            return

        target_group = group_list[int(choice) - 1]

        # Show projects not in this group
        self.clear_screen()
        available = [p for p in projects if p.get('group') != target_group]

        if not available:
            print(f"\n   All projects are already in '{target_group}'")
            self.wait_for_enter()
            return

        print(f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘              Assign to: {target_group:<36} â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

   Select projects to add to this group:
""")
        for i, proj in enumerate(available, 1):
            status = "ğŸŒŸ" if proj.get('scf_enabled') else "ğŸ“"
            current = f" [{proj.get('group')}]" if proj.get('group') else ""
            print(f"   {i:2}. {status} {proj['name']}{current}")

        print(f"\n   Selection (1,3,5 or 1-{len(available)}) [all]: ", end="")
        sel = input().strip().lower()

        if sel == 'c':
            return

        selected_indices = self._parse_selection(sel, len(available))
        if not selected_indices:
            print("   âŒ No valid selection")
            self.wait_for_enter()
            return

        # Update projects
        count = 0
        for idx in selected_indices:
            proj_name = available[idx]['name']
            for p in registry['projects']:
                if p['name'] == proj_name:
                    p['group'] = target_group
                    count += 1
                    break

        self.save_registry(registry)
        print(f"\n   âœ… Added {count} projects to '{target_group}'")
        self.wait_for_enter()

    def remove_from_group(self):
        """Remove projects from their group"""
        self.clear_screen()
        registry = self.load_registry()
        projects = registry.get('projects', [])

        # Get projects that have a group
        grouped = [p for p in projects if p.get('group')]

        if not grouped:
            print("\n   No projects are assigned to groups.")
            self.wait_for_enter()
            return

        print("""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    â– Remove from Group                       â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

   Select projects to ungroup:
""")
        for i, proj in enumerate(grouped, 1):
            status = "ğŸŒŸ" if proj.get('scf_enabled') else "ğŸ“"
            print(f"   {i:2}. {status} {proj['name']} [{proj.get('group')}]")

        print(f"\n   Selection (1,3,5 or 1-{len(grouped)}) [all]: ", end="")
        sel = input().strip().lower()

        if sel == 'c':
            return

        selected_indices = self._parse_selection(sel, len(grouped))
        if not selected_indices:
            print("   âŒ No valid selection")
            self.wait_for_enter()
            return

        # Update projects
        count = 0
        for idx in selected_indices:
            proj_name = grouped[idx]['name']
            for p in registry['projects']:
                if p['name'] == proj_name:
                    p.pop('group', None)
                    count += 1
                    break

        self.save_registry(registry)
        print(f"\n   âœ… Removed {count} projects from their groups")
        self.wait_for_enter()

    def delete_group(self):
        """Delete a group"""
        self.clear_screen()
        registry = self.load_registry()
        groups = registry.get('groups', {})

        if not groups:
            print("\n   No groups to delete.")
            self.wait_for_enter()
            return

        print("""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    ğŸ—‘ï¸  Delete Group                           â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

   Select a group to delete:
""")
        group_list = sorted(groups.keys())
        projects = registry.get('projects', [])

        for i, name in enumerate(group_list, 1):
            member_count = sum(1 for p in projects if p.get('group') == name)
            print(f"   {i}. ğŸ“‚ {name} ({member_count} projects)")

        print("\n   c. Cancel\n")
        choice = input("   Selection: ").strip().lower()

        if choice == 'c':
            return

        if not choice.isdigit() or not (1 <= int(choice) <= len(group_list)):
            print("   âŒ Invalid selection")
            self.wait_for_enter()
            return

        target_group = group_list[int(choice) - 1]
        member_count = sum(1 for p in projects if p.get('group') == target_group)

        print(f"\n   âš ï¸  Delete group '{target_group}'?")
        if member_count > 0:
            print(f"   ({member_count} projects will be ungrouped)")

        confirm = input("\n   Confirm? [y/N]: ").strip().lower()

        if confirm == 'y':
            # Remove group from projects
            for p in registry['projects']:
                if p.get('group') == target_group:
                    p.pop('group', None)

            # Delete group
            del registry['groups'][target_group]
            self.save_registry(registry)
            print(f"\n   âœ… Deleted group: {target_group}")
        else:
            print("\n   Cancelled.")

        self.wait_for_enter()

    def view_group(self):
        """View members of a group"""
        self.clear_screen()
        registry = self.load_registry()
        groups = registry.get('groups', {})

        if not groups:
            print("\n   No groups created yet.")
            self.wait_for_enter()
            return

        print("""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    ğŸ‘ï¸  View Group                             â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

   Select a group:
""")
        group_list = sorted(groups.keys())
        projects = registry.get('projects', [])

        for i, name in enumerate(group_list, 1):
            member_count = sum(1 for p in projects if p.get('group') == name)
            print(f"   {i}. ğŸ“‚ {name} ({member_count} projects)")

        print("\n   c. Cancel\n")
        choice = input("   Selection: ").strip().lower()

        if choice == 'c':
            return

        if not choice.isdigit() or not (1 <= int(choice) <= len(group_list)):
            print("   âŒ Invalid selection")
            self.wait_for_enter()
            return

        target_group = group_list[int(choice) - 1]
        members = [p for p in projects if p.get('group') == target_group]

        self.clear_screen()
        print(f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘              ğŸ“‚ {target_group:<44} â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
""")
        if groups[target_group].get('description'):
            print(f"   {groups[target_group]['description']}\n")

        if not members:
            print("   No projects in this group.\n")
        else:
            print(f"   {len(members)} projects:\n")
            for proj in members:
                status = "ğŸŒŸ" if proj.get('scf_enabled') else "ğŸ“"
                print(f"   {status} {proj['name']}")
                print(f"      {proj['path']}")

        self.wait_for_enter()

    def add_project(self):
        """Add projects by scanning a directory"""
        self.clear_screen()

        # Find common project directories
        common_paths = []
        for p in [Path.home() / 'projects', Path.home() / 'code', Path.home() / 'work',
                  Path.home() / 'dev', Path.home() / 'src', Path.home() / 'repos']:
            if p.exists() and p.is_dir():
                common_paths.append(p)

        print("""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    â• Add Projects                            â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
""")
        if common_paths:
            print("   Found project directories:\n")
            for i, p in enumerate(common_paths, 1):
                # Count projects in each
                try:
                    count = sum(1 for item in p.iterdir() if item.is_dir() and not item.name.startswith('.'))
                except:
                    count = 0
                print(f"   {i}. {p}  ({count} folders)")
            print(f"\n   Or enter a custom path")
            print(f"\n   c. Cancel\n")

            choice = input("   Selection: ").strip().lower()

            if choice == 'c':
                return
            elif choice.isdigit() and 1 <= int(choice) <= len(common_paths):
                scan_path = common_paths[int(choice) - 1]
            else:
                # Convert Windows backslashes to forward slashes
                scan_path = Path(choice.replace('\\', '/')).expanduser().resolve()
        else:
            print("   Enter a directory to scan for projects.")
            print("   Examples: ~/projects, ~/code, ~/work\n")
            path_input = input("   Scan path (or 'c' to cancel): ").strip()

            if path_input.lower() == 'c':
                return

            # Convert Windows backslashes to forward slashes
            scan_path = Path(path_input.replace('\\', '/')).expanduser().resolve()

        if not scan_path.exists() or not scan_path.is_dir():
            print(f"\n   âŒ Directory not found: {scan_path}")
            self.wait_for_enter()
            return

        # Check if the path itself is a project (not a parent folder of projects)
        is_project = self._is_project_dir(scan_path)

        if is_project:
            # User entered a specific project path - add it directly
            discovered = [self._get_project_info(scan_path)]
        else:
            # Scan for projects inside this directory
            print(f"\n   ğŸ” Scanning {scan_path}...")
            discovered = self._quick_scan(scan_path)

        if not discovered:
            print("\n   No projects found in this directory.")
            self.wait_for_enter()
            return

        # Filter out already registered
        registry = self.load_registry()
        existing = {p['path'] for p in registry.get('projects', [])}
        new_projects = [p for p in discovered if p['path'] not in existing]

        if not new_projects:
            print("\n   All projects in this directory are already registered.")
            self.wait_for_enter()
            return

        # Show found projects
        self.clear_screen()
        print(f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘              ğŸ“‚ Found {len(new_projects)} Projects in {scan_path.name}/              â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
""")
        for i, proj in enumerate(new_projects, 1):
            status = "ğŸŒŸ" if proj.get('scf_enabled') else "ğŸ“"
            # Show relative path from scan_path or full path
            proj_path = Path(proj['path'])
            try:
                rel_path = proj_path.relative_to(scan_path.parent)
            except ValueError:
                rel_path = proj_path
            print(f"   {i:2}. {status} {proj['name']}")
            print(f"       {rel_path}")
            if proj.get('description'):
                print(f"       â””â”€ {proj['description'][:50]}")

        print(f"\n   Selection (1,3,5 or 1-{len(new_projects)}) [all]: ", end="")
        choice = input().strip().lower()

        if choice == 'c':
            return

        # Parse selection (empty = all)
        indices = self._parse_selection(choice, len(new_projects))
        if not indices:
            print("\n   âŒ No valid selection")
            self.wait_for_enter()
            return

        selected = [new_projects[i] for i in indices]

        # Add selected projects with full profile
        added_count = 0
        for proj in selected:
            proj_path = Path(proj['path'])

            # Build comprehensive profile
            proj_info = self._build_project_profile(proj_path)
            proj_info['added_at'] = datetime.now(timezone.utc).isoformat()
            proj_info['last_sync'] = None

            # Update spoke's hub_path if SCF-enabled
            if proj_info.get('scf_enabled'):
                for bs_path in [proj_path / '.scf' / 'BUILDSTATE.json',
                               proj_path / '.scf' / 'buildstate.json',
                               proj_path / 'BUILDSTATE.json',
                               proj_path / 'buildstate.json']:
                    if bs_path.exists():
                        try:
                            with open(bs_path) as f:
                                data = json.load(f)
                            if '_scf_metadata' in data:
                                data['_scf_metadata']['hub_path'] = str(self.hub_path)
                                with open(bs_path, 'w') as f:
                                    json.dump(data, f, indent=2)
                            break
                        except:
                            pass

            registry['projects'].append(proj_info)
            added_count += 1

            # Show what was detected
            print(f"   âœ… {proj_info['name']}")
            if proj_info.get('languages'):
                print(f"      Languages: {', '.join(proj_info['languages'][:3])}")
            if proj_info.get('frameworks'):
                print(f"      Frameworks: {', '.join(proj_info['frameworks'][:3])}")

        self.save_registry(registry)
        print(f"\n   âœ… Added {added_count} projects")
        self.wait_for_enter()

    def _is_project_dir(self, path: Path) -> bool:
        """Check if a directory is itself a project (has .git, package.json, etc.)"""
        indicators = [
            path / '.git',
            path / '.scf',
            path / 'buildstate.json',
            path / 'BUILDSTATE.json',
            path / 'package.json',
            path / 'pyproject.toml',
            path / 'setup.py',
            path / 'Cargo.toml',
            path / 'go.mod',
            path / 'pom.xml',
            path / 'Makefile',
        ]
        return any(ind.exists() for ind in indicators)

    def _get_project_info(self, item: Path) -> dict:
        """Get project info for a single project directory"""
        is_scf = ((item / '.scf').exists() or
                  (item / 'buildstate.json').exists() or
                  (item / 'BUILDSTATE.json').exists())

        proj_info = {
            'name': item.name,
            'path': str(item.resolve()),
            'scf_enabled': is_scf,
            'description': None,
            'project_type': None
        }

        # Read SCF details if available
        if is_scf:
            # Check both uppercase and lowercase variants (Linux is case-sensitive)
            for bs_path in [item / '.scf' / 'BUILDSTATE.json',
                           item / '.scf' / 'buildstate.json',
                           item / 'BUILDSTATE.json',
                           item / 'buildstate.json']:
                if bs_path.exists():
                    try:
                        with open(bs_path) as f:
                            data = json.load(f)
                        if '_project_foundation' in data:
                            foundation = data['_project_foundation']
                            if foundation.get('identity'):
                                proj_info['description'] = foundation['identity'].get('one_liner')
                                proj_info['project_type'] = foundation['identity'].get('type')
                        elif 'project' in data:
                            proj_info['description'] = data['project'].get('description')
                            proj_info['project_type'] = data['project'].get('type')
                        break
                    except:
                        pass

        return proj_info

    def _quick_scan(self, scan_path: Path) -> list:
        """Quick scan a directory for projects"""
        discovered = []

        try:
            for item in scan_path.iterdir():
                if not item.is_dir() or item.name.startswith('.'):
                    continue

                if self._is_project_dir(item):
                    discovered.append(self._get_project_info(item))
        except PermissionError:
            pass

        return sorted(discovered, key=lambda x: (not x['scf_enabled'], x['name'].lower()))

    def _format_size(self, size_bytes: int) -> str:
        """Format bytes to human readable string"""
        if size_bytes < 0:
            sign = "-"
            size_bytes = abs(size_bytes)
        else:
            sign = ""

        for unit in ['B', 'KB', 'MB', 'GB']:
            if abs(size_bytes) < 1024:
                return f"{sign}{size_bytes:.1f}{unit}"
            size_bytes /= 1024
        return f"{sign}{size_bytes:.1f}TB"

    def _parse_selection(self, selection: str, max_val: int, default_all: bool = True) -> list:
        """Parse selection like '1,3,5' or '1-5' or '1,3-5' or 'a' for all

        Args:
            selection: User input string
            max_val: Maximum valid selection number
            default_all: If True, empty input returns all indices
        """
        selection = selection.strip().lower()

        # Handle empty input - default to all if enabled
        if not selection:
            if default_all:
                return list(range(max_val))
            return []

        # Handle 'a' or 'all' for all
        if selection in ('a', 'all'):
            return list(range(max_val))

        indices = set()
        parts = selection.replace(' ', '').split(',')

        for part in parts:
            if not part:
                continue
            if '-' in part:
                try:
                    start, end = part.split('-', 1)
                    for i in range(int(start), int(end) + 1):
                        if 1 <= i <= max_val:
                            indices.add(i - 1)
                except ValueError:
                    continue
            elif part.isdigit():
                i = int(part)
                if 1 <= i <= max_val:
                    indices.add(i - 1)

        return sorted(indices)

    def remove_project(self, projects: list):
        """Remove a project interactively"""
        self.clear_screen()
        print("""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    ğŸ—‘ï¸  Delete Project                         â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

   Select a project to remove from hub:
""")
        for i, proj in enumerate(projects, 1):
            status = "ğŸŒŸ" if proj.get('scf_enabled') else "ğŸ“"
            print(f"   {i:2}. {status} {proj['name']}")
            print(f"       {proj['path']}")

        print("\n   c. Cancel\n")
        choice = input("   Selection: ").strip().lower()

        if choice == 'c':
            return

        if not choice.isdigit() or not (1 <= int(choice) <= len(projects)):
            print("   âŒ Invalid selection")
            self.wait_for_enter()
            return

        proj = projects[int(choice) - 1]
        print(f"\n   âš ï¸  This removes '{proj['name']}' from hub tracking.")
        print(f"   (Project files on disk are NOT deleted)")
        confirm = input(f"\n   Confirm delete? [y/N]: ").strip().lower()

        if confirm == 'y':
            registry = self.load_registry()
            registry['projects'] = [p for p in registry['projects'] if p['name'] != proj['name']]
            self.save_registry(registry)
            print(f"\n   âœ… Removed: {proj['name']}")
        else:
            print("\n   Cancelled.")

        self.wait_for_enter()

    def rescan_projects(self, projects: list):
        """Rescan project(s) to rebuild their profiles"""
        self.clear_screen()
        print("""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    ğŸ”„ Rescan Projects                        â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

   Select project(s) to rescan and rebuild profile:
""")
        for i, proj in enumerate(projects, 1):
            status = "ğŸŒŸ" if proj.get('scf_enabled') else "ğŸ“"
            print(f"   {i:2}. {status} {proj['name']}")
            print(f"       {proj.get('path', 'unknown')}")

        print(f"\n   Selection (1,3,5 or 1-{len(projects)}) [all]: ", end="")
        choice = input().strip().lower()

        if choice == 'c':
            return

        indices = self._parse_selection(choice, len(projects))
        if not indices:
            print("   âŒ No valid selection")
            self.wait_for_enter()
            return

        selected = [projects[i] for i in indices]
        print(f"\n   ğŸ”„ Rescanning {len(selected)} project(s)...\n")

        registry = self.load_registry()
        updated_count = 0

        for proj in selected:
            proj_path = Path(proj.get('path', '')).expanduser()
            print(f"   ğŸ“‚ {proj['name']}...", end=" ")

            if not proj_path.exists():
                print("âŒ Path not found")
                continue

            try:
                # Build fresh profile
                profile = self._build_project_profile(proj_path)

                # Preserve existing fields that shouldn't be overwritten
                profile['group'] = proj.get('group')
                profile['added_at'] = proj.get('added_at')
                profile['last_sync'] = proj.get('last_sync')

                # Track changes
                changes = []
                old_scf = proj.get('scf_enabled', False)
                new_scf = profile.get('scf_enabled', False)
                if old_scf != new_scf:
                    changes.append(f"SCF: {'ğŸ“â†’ğŸŒŸ' if new_scf else 'ğŸŒŸâ†’ğŸ“'}")

                old_size = proj.get('size_bytes', 0)
                new_size = profile.get('size_bytes', 0)
                if old_size and new_size and abs(new_size - old_size) > 1024:
                    diff = new_size - old_size
                    changes.append(f"Size: {'+' if diff > 0 else ''}{self._format_size(diff)}")

                old_files = proj.get('file_count', 0)
                new_files = profile.get('file_count', 0)
                if old_files and new_files and old_files != new_files:
                    diff = new_files - old_files
                    changes.append(f"Files: {'+' if diff > 0 else ''}{diff}")

                # Update in registry
                for i, p in enumerate(registry['projects']):
                    if p.get('path') == proj.get('path') or p.get('name') == proj.get('name'):
                        registry['projects'][i] = profile
                        break

                updated_count += 1
                print("âœ…")

                # Show what was detected
                print(f"       ğŸ“Š {profile.get('file_count', 0)} files, {self._format_size(profile.get('size_bytes', 0))}")
                if profile.get('created_at'):
                    created = profile['created_at'][:10]  # Just date part
                    print(f"       ğŸ“… Started: {created}")
                if profile.get('languages'):
                    print(f"       ğŸ’» {', '.join(profile['languages'][:3])}", end="")
                    if profile.get('frameworks'):
                        print(f" + {', '.join(profile['frameworks'][:2])}")
                    else:
                        print()
                if changes:
                    print(f"       ğŸ”„ Changed: {', '.join(changes)}")

            except Exception as e:
                print(f"âŒ {e}")

        self.save_registry(registry)
        print(f"\n   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
        print(f"   âœ… Updated {updated_count} project profile(s)")
        self.wait_for_enter()

    def _build_project_profile(self, proj_path: Path) -> dict:
        """Build a comprehensive project profile by scanning the folder"""
        profile = {
            'name': proj_path.name,
            'path': str(proj_path.resolve()),
            'scf_enabled': False,
            'description': None,
            'project_type': None,
            'languages': [],
            'frameworks': [],
            'has_tests': False,
            'has_ci': False,
            'size_bytes': 0,
            'file_count': 0,
            'created_at': None,
            'last_scanned': datetime.now(timezone.utc).isoformat()
        }

        # Get folder creation time (earliest file/folder mtime as proxy)
        try:
            # Use .git creation or folder stat
            git_dir = proj_path / '.git'
            if git_dir.exists():
                profile['created_at'] = datetime.fromtimestamp(
                    git_dir.stat().st_mtime, tz=timezone.utc
                ).isoformat()
            else:
                profile['created_at'] = datetime.fromtimestamp(
                    proj_path.stat().st_ctime, tz=timezone.utc
                ).isoformat()
        except:
            pass

        # Calculate size and file count (excluding .git, node_modules, etc.)
        try:
            total_size = 0
            file_count = 0
            skip_dirs = {'.git', 'node_modules', '__pycache__', '.venv', 'venv',
                        'dist', 'build', '.next', 'target', '.cache'}

            for item in proj_path.rglob('*'):
                # Skip large dependency/build directories
                if any(skip in item.parts for skip in skip_dirs):
                    continue
                if item.is_file():
                    try:
                        total_size += item.stat().st_size
                        file_count += 1
                    except:
                        pass

            profile['size_bytes'] = total_size
            profile['file_count'] = file_count
        except:
            pass

        # Check SCF status
        profile['scf_enabled'] = ((proj_path / '.scf').exists() or
                                   (proj_path / 'buildstate.json').exists() or
                                   (proj_path / 'BUILDSTATE.json').exists())

        # Read SCF details if available
        if profile['scf_enabled']:
            for bs_path in [proj_path / '.scf' / 'BUILDSTATE.json',
                           proj_path / '.scf' / 'buildstate.json',
                           proj_path / 'BUILDSTATE.json',
                           proj_path / 'buildstate.json']:
                if bs_path.exists():
                    try:
                        data = json.loads(bs_path.read_text())
                        if '_project_foundation' in data:
                            foundation = data['_project_foundation']
                            if foundation.get('identity'):
                                profile['description'] = foundation['identity'].get('one_liner')
                                profile['project_type'] = foundation['identity'].get('type')
                        elif 'project' in data:
                            profile['description'] = data['project'].get('description')
                            profile['project_type'] = data['project'].get('type')
                        break
                    except:
                        pass

        # Detect languages and frameworks
        languages = set()
        frameworks = set()

        # JavaScript/TypeScript
        if (proj_path / 'package.json').exists():
            languages.add('JavaScript')
            try:
                pkg = json.loads((proj_path / 'package.json').read_text())
                deps = {**pkg.get('dependencies', {}), **pkg.get('devDependencies', {})}

                if 'typescript' in deps or (proj_path / 'tsconfig.json').exists():
                    languages.add('TypeScript')
                if 'react' in deps or '@types/react' in deps:
                    frameworks.add('React')
                if 'next' in deps:
                    frameworks.add('Next.js')
                if 'vue' in deps:
                    frameworks.add('Vue')
                if 'express' in deps:
                    frameworks.add('Express')
                if 'nest' in deps or '@nestjs/core' in deps:
                    frameworks.add('NestJS')

                # Get description from package.json if not from SCF
                if not profile['description'] and pkg.get('description'):
                    profile['description'] = pkg['description']
            except:
                pass

        # Python
        if (proj_path / 'pyproject.toml').exists() or (proj_path / 'setup.py').exists() or (proj_path / 'requirements.txt').exists():
            languages.add('Python')
            # Check for frameworks
            for req_file in ['requirements.txt', 'pyproject.toml', 'setup.py']:
                req_path = proj_path / req_file
                if req_path.exists():
                    try:
                        content = req_path.read_text().lower()
                        if 'django' in content:
                            frameworks.add('Django')
                        if 'flask' in content:
                            frameworks.add('Flask')
                        if 'fastapi' in content:
                            frameworks.add('FastAPI')
                        if 'pytorch' in content or 'torch' in content:
                            frameworks.add('PyTorch')
                        if 'tensorflow' in content:
                            frameworks.add('TensorFlow')
                    except:
                        pass

        # Rust
        if (proj_path / 'Cargo.toml').exists():
            languages.add('Rust')

        # Go
        if (proj_path / 'go.mod').exists():
            languages.add('Go')

        # Java
        if (proj_path / 'pom.xml').exists() or (proj_path / 'build.gradle').exists():
            languages.add('Java')
            if (proj_path / 'pom.xml').exists():
                frameworks.add('Maven')
            if (proj_path / 'build.gradle').exists():
                frameworks.add('Gradle')

        # Check for tests
        test_indicators = ['test', 'tests', 'spec', 'specs', '__tests__', 'test.py', 'test.js', 'test.ts']
        for indicator in test_indicators:
            if (proj_path / indicator).exists():
                profile['has_tests'] = True
                break

        # Check for CI
        ci_indicators = ['.github/workflows', '.gitlab-ci.yml', 'Jenkinsfile', '.circleci', '.travis.yml']
        for indicator in ci_indicators:
            if (proj_path / indicator).exists():
                profile['has_ci'] = True
                break

        profile['languages'] = sorted(list(languages))
        profile['frameworks'] = sorted(list(frameworks))

        return profile

    def view_project_select(self, projects: list):
        """Select a project to view"""
        print("\n   Enter project number to view (or 'c' to cancel): ", end="")
        choice = input().strip()

        if choice.lower() == 'c':
            return

        if choice.isdigit() and 1 <= int(choice) <= len(projects):
            self.view_project(projects[int(choice) - 1])

    def view_project(self, proj: dict):
        """View detailed project info"""
        self.clear_screen()
        status = "ğŸŒŸ SCF-enabled" if proj.get('scf_enabled') else "ğŸ“ Regular"

        print(f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  ğŸ“¦ {proj['name']:<52} â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

   Status:     {status}
   Path:       {proj['path']}
   Type:       {proj.get('type', 'unknown')}
   Added:      {proj.get('added_at', 'unknown').split('T')[0]}
   Last sync:  {proj.get('last_sync', 'never') if proj.get('last_sync') else 'never'}
""")
        # If SCF-enabled, read more details
        if proj.get('scf_enabled'):
            proj_path = Path(proj['path'])
            for bs_path in [proj_path / '.scf' / 'BUILDSTATE.json', proj_path / 'buildstate.json']:
                if bs_path.exists():
                    try:
                        with open(bs_path) as f:
                            data = json.load(f)

                        if '_project_foundation' in data:
                            foundation = data['_project_foundation']
                            if foundation.get('identity'):
                                print(f"   Foundation: {foundation['identity'].get('one_liner', 'No description')}")

                        if 'features' in data and data['features']:
                            print(f"\n   âœ¨ Features ({len(data['features'])}):")
                            for feat in data['features'][:5]:
                                print(f"      â€¢ {feat.get('name', 'unnamed')}")

                        if 'decisions' in data and data['decisions']:
                            print(f"\n   ğŸ“ Recent Decisions ({len(data['decisions'])}):")
                            for dec in data['decisions'][:3]:
                                print(f"      â€¢ {dec.get('decision', 'unnamed')[:50]}")

                        break
                    except:
                        pass

        print("""
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   1. ğŸ§  Learn from this project
   2. ğŸ“š Teach this project
   3. ğŸ”„ Sync this project
   4. ğŸ“‚ Open in terminal

   b. Back
""")
        choice = self.get_choice(4)

        if choice == '1':
            self.learn_from_project(proj)
        elif choice == '2':
            self.teach_project(proj)
        elif choice == '3':
            self.sync_project(proj)
        elif choice == '4':
            import os
            os.system(f'cd "{proj["path"]}" && $SHELL')

    def learn_from_project(self, proj: dict):
        """Learn from a specific project"""
        print(f"\n   ğŸ§  Learning from {proj['name']}...")

        proj_path = Path(proj['path'])
        signals_path = proj_path / '.scf' / 'spoke-signals.jsonl'

        if not signals_path.exists():
            signals_path = proj_path / 'spoke-signals.jsonl'

        if signals_path.exists():
            with open(signals_path) as f:
                signals = [json.loads(line) for line in f if line.strip()]
                high_impact = [s for s in signals if s.get('offers')]
                print(f"   Found {len(high_impact)} high-impact learnings")
        else:
            print("   No signals found in this project")

        self.wait_for_enter()

    def teach_project(self, proj: dict):
        """Teach a specific project"""
        print(f"\n   ğŸ“š Teaching {proj['name']}...")

        proj_path = Path(proj['path'])
        kb_sync_path = proj_path / '.scf' / 'kb-sync.json'

        if kb_sync_path.exists():
            try:
                with open(kb_sync_path) as f:
                    kb_sync = json.load(f)
                kb_sync['last_sync_date'] = datetime.now(timezone.utc).isoformat()
                kb_sync['hub_kb_version'] = datetime.now(timezone.utc).isoformat()
                with open(kb_sync_path, 'w') as f:
                    json.dump(kb_sync, f, indent=2)
                print("   âœ… Updated knowledge sync")
            except:
                print("   âŒ Failed to update")
        else:
            print("   âš ï¸  No kb-sync.json found")

        # Update registry
        registry = self.load_registry()
        for p in registry['projects']:
            if p['name'] == proj['name']:
                p['last_sync'] = datetime.now(timezone.utc).isoformat()
        self.save_registry(registry)

        self.wait_for_enter()

    def sync_project(self, proj: dict):
        """Sync a project"""
        print(f"\n   ğŸ”„ Syncing {proj['name']}...")
        self.learn_from_project(proj)
        self.teach_project(proj)

    def scan_menu(self):
        """Scan for new projects"""
        self.clear_screen()
        print("""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    ğŸ” Scan for Projects                      â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
""")
        registry_dir = self.hub_path / '.scf-registry'
        self.hub_manager._discover_existing_projects(self.hub_path, registry_dir)
        self.wait_for_enter()

    def learn_menu(self):
        """Learn from all projects"""
        self.clear_screen()
        print("""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    ğŸ§  Learn from Projects                    â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
""")
        registry = self.load_registry()
        projects = [p for p in registry.get('projects', []) if p.get('scf_enabled')]

        if not projects:
            print("   No SCF-enabled projects to learn from.")
            self.wait_for_enter()
            return

        print(f"   Found {len(projects)} SCF-enabled projects\n")

        learned_count = 0
        for proj in projects:
            proj_path = Path(proj['path'])
            signals_path = proj_path / '.scf' / 'spoke-signals.jsonl'

            if not signals_path.exists():
                signals_path = proj_path / 'spoke-signals.jsonl'

            if signals_path.exists():
                print(f"   ğŸ“– Reading from {proj['name']}...")
                with open(signals_path) as f:
                    signals = [json.loads(line) for line in f if line.strip()]
                    high_impact = [s for s in signals if s.get('offers')]
                    if high_impact:
                        learned_count += len(high_impact)
                        print(f"      Found {len(high_impact)} learnings")

        print(f"\n   âœ… Gathered {learned_count} total learnings")
        self.wait_for_enter()

    def teach_menu(self):
        """Teach projects - push hub learnings to spokes safely"""
        self.clear_screen()
        print("""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    ğŸ“š Teach Projects                         â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
""")
        registry = self.load_registry()
        projects = [p for p in registry.get('projects', []) if p.get('scf_enabled')]

        if not projects:
            print("   No SCF-enabled projects to teach.")
            self.wait_for_enter()
            return

        # First, scan each project for existing SCF data
        print("   Scanning projects for existing SCF data...\n")

        project_info = []
        for proj in projects:
            proj_path = Path(proj['path']).expanduser()
            info = {
                'proj': proj,
                'path': proj_path,
                'existing_files': [],
                'decisions_count': 0,
                'signals_count': 0,
                'learnings_to_push': 0
            }

            if not proj_path.exists():
                project_info.append(info)
                continue

            # Find all SCF files (both .scf/ and legacy root files)
            scf_dir = proj_path / '.scf'
            if scf_dir.exists():
                info['existing_files'].extend([f.name for f in scf_dir.glob('*') if f.is_file()])

            # Check for legacy root files
            for legacy in ['buildstate.json', 'BUILDSTATE.json', 'buildstate.md', 'BUILDSTATE.md']:
                if (proj_path / legacy).exists():
                    info['existing_files'].append(f"(root)/{legacy}")

            # Count existing decisions
            for bs_path in [scf_dir / 'BUILDSTATE.json', scf_dir / 'buildstate.json',
                           proj_path / 'BUILDSTATE.json', proj_path / 'buildstate.json']:
                if bs_path.exists():
                    try:
                        data = json.loads(bs_path.read_text())
                        info['decisions_count'] = len(data.get('decisions', []))
                        break
                    except:
                        pass

            # Count signals
            for sig_path in [scf_dir / 'spoke-signals.jsonl', proj_path / 'spoke-signals.jsonl']:
                if sig_path.exists():
                    try:
                        info['signals_count'] = sum(1 for line in open(sig_path) if line.strip())
                    except:
                        pass
                    break

            # Check hub learnings that could be pushed
            learnings_dir = self.hub_path / 'learnings'
            if learnings_dir.exists():
                info['learnings_to_push'] = len(list(learnings_dir.glob('*.json')))

            project_info.append(info)

        # Display what we found
        print("   Found existing SCF data:\n")
        for i, info in enumerate(project_info, 1):
            proj = info['proj']
            files_count = len(info['existing_files'])
            print(f"   {i}. {proj['name']}")
            if files_count:
                print(f"      ğŸ“‚ {files_count} SCF files found")
                print(f"      ğŸ“Š {info['decisions_count']} decisions, {info['signals_count']} signals")
            else:
                print(f"      ğŸ“­ No existing SCF files")

        # Hub learnings summary
        learnings_dir = self.hub_path / 'learnings'
        hub_learnings = list(learnings_dir.glob('*.json')) if learnings_dir.exists() else []
        print(f"\n   Hub has {len(hub_learnings)} learning file(s) to share")

        print(f"""
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   What 'Teach' does:
   â€¢ Updates kb-sync.json timestamps
   â€¢ Preserves ALL existing decisions and signals
   â€¢ Does NOT overwrite buildstate files
   â€¢ Merges learnings, never deletes
""")
        print(f"\n   Selection (1,3,5 or 1-{len(projects)}) [all]: ", end="")
        selection = input().strip().lower()

        if selection in ('b', 'c'):
            return

        indices = self._parse_selection(selection, len(projects))
        if not indices:
            print("   âŒ No valid selection")
            self.wait_for_enter()
            return

        selected_info = [project_info[i] for i in indices]

        print(f"\n   Teaching {len(selected_info)} project(s)...\n")

        taught_count = 0
        for info in selected_info:
            proj = info['proj']
            proj_path = info['path']

            if not proj_path.exists():
                print(f"   â€¢ {proj['name']}... âŒ Path not found")
                continue

            print(f"   â€¢ {proj['name']}...", end=" ")

            try:
                scf_dir = proj_path / '.scf'
                scf_dir.mkdir(exist_ok=True)

                # Update or create kb-sync.json (merge, don't overwrite)
                kb_sync_path = scf_dir / 'kb-sync.json'
                kb_sync = {}
                if kb_sync_path.exists():
                    try:
                        kb_sync = json.loads(kb_sync_path.read_text())
                    except:
                        pass

                kb_sync['last_sync_date'] = datetime.now(timezone.utc).isoformat()
                kb_sync['hub_kb_version'] = datetime.now(timezone.utc).isoformat()
                kb_sync['hub_path'] = str(self.hub_path)
                kb_sync['framework_path'] = str(self.framework_path)

                with open(kb_sync_path, 'w') as f:
                    json.dump(kb_sync, f, indent=2)

                # Update registry
                proj['last_sync'] = datetime.now(timezone.utc).isoformat()
                taught_count += 1

                if info['existing_files']:
                    print(f"âœ… Synced (preserved {len(info['existing_files'])} files)")
                else:
                    print("âœ… Synced")

            except Exception as e:
                print(f"âŒ {e}")

        self.save_registry(registry)
        print(f"\n   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
        print(f"   âœ… Taught {taught_count} project(s)")
        print(f"   â„¹ï¸  No existing SCF data was modified or deleted")
        self.wait_for_enter()

    def stats_menu(self):
        """Show detailed statistics with actionable recommendations"""
        while True:
            self.clear_screen()
            registry = self.load_registry()
            projects = registry.get('projects', [])
            scf_enabled = [p for p in projects if p.get('scf_enabled')]
            regular = [p for p in projects if not p.get('scf_enabled')]
            never_synced = [p for p in scf_enabled if not p.get('last_sync')]

            learnings_dir = self.hub_path / 'learnings'
            learning_count = len(list(learnings_dir.glob('*.json'))) if learnings_dir.exists() else 0

            # Build actionable recommendations
            actions = []
            if regular:
                actions.append(('enable', f"Enable SCF on {len(regular)} project(s)", regular))
            if never_synced:
                actions.append(('sync', f"Sync {len(never_synced)} project(s) that never synced", never_synced))
            if len(projects) == 0:
                actions.append(('scan', "Scan for projects to add", None))
            if learning_count == 0 and scf_enabled:
                actions.append(('learn', "Learn patterns from SCF-enabled projects", scf_enabled))

            print(f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    ğŸ“Š Hub Statistics                         â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

   ğŸ“ Projects
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   Total registered:    {len(projects)}
   SCF-enabled:         {len(scf_enabled)}
   Regular:             {len(regular)}
   Never synced:        {len(never_synced)}

   ğŸ§  Learnings
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   Patterns stored:     {learning_count}
""")

            if actions:
                print("   ğŸ’¡ Recommended Actions")
                print("   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
                for i, (_, desc, _) in enumerate(actions, 1):
                    print(f"   {i}. {desc}")
                print()

            if not actions:
                print("   âœ… Everything looks good!")
                print()

            print("   b. Back")

            choice = self.get_choice(len(actions))

            if choice == 'b':
                return

            try:
                idx = int(choice) - 1
                if 0 <= idx < len(actions):
                    action_type, desc, items = actions[idx]
                    self._execute_recommendation(action_type, items)
            except ValueError:
                pass

    def _execute_recommendation(self, action_type: str, items):
        """Execute a recommendation action"""
        if action_type == 'enable':
            self._enable_scf_batch(items)
        elif action_type == 'sync':
            self._sync_projects_batch(items)
        elif action_type == 'scan':
            self.add_project()  # Reuse add project flow which scans
        elif action_type == 'learn':
            self._learn_from_projects(items)

    def _enable_scf_batch(self, projects: list):
        """Enable SCF on multiple projects with preview and verification"""
        self.clear_screen()
        print("\n   ğŸš€ Enable SCF on Projects")
        print("   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n")

        # Preview what will happen for each project
        print("   Preview - checking each project:\n")
        project_status = []

        for proj in projects:
            proj_path = Path(proj.get('path', '')).expanduser()
            status = {'proj': proj, 'path': proj_path, 'actions': [], 'existing': []}

            if not proj_path.exists():
                status['actions'].append("âŒ Path not found")
                project_status.append(status)
                continue

            scf_dir = proj_path / '.scf'

            # Check for existing SCF files
            existing_files = []
            if scf_dir.exists():
                existing_files = list(scf_dir.glob('*'))
            # Also check root for legacy buildstate
            if (proj_path / 'buildstate.json').exists():
                existing_files.append(proj_path / 'buildstate.json')
            if (proj_path / 'BUILDSTATE.json').exists():
                existing_files.append(proj_path / 'BUILDSTATE.json')

            if existing_files:
                status['existing'] = [f.name for f in existing_files]
                status['actions'].append(f"âš ï¸  Has {len(existing_files)} existing SCF file(s) - will PRESERVE")
            else:
                status['actions'].append("ğŸ“„ Will create new .scf/ with templates")

            # Check what templates would be added
            templates_dir = self.framework_path / 'templates' / 'spoke'
            if templates_dir.exists():
                new_templates = []
                for t in templates_dir.glob('*'):
                    if t.is_file():
                        dest = scf_dir / t.name
                        if not dest.exists():
                            new_templates.append(t.name)
                if new_templates:
                    status['actions'].append(f"â• Will add: {', '.join(new_templates[:3])}{'...' if len(new_templates) > 3 else ''}")

            project_status.append(status)

        # Display preview
        for i, status in enumerate(project_status, 1):
            proj = status['proj']
            print(f"   {i}. {proj['name']}")
            for action in status['actions']:
                print(f"      {action}")
            if status['existing']:
                print(f"      ğŸ“‚ Existing: {', '.join(status['existing'][:4])}{'...' if len(status['existing']) > 4 else ''}")
            print()

        # Confirm
        print("   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
        print("   âš ï¸  Existing SCF files will NOT be overwritten")
        confirm = input("\n   Proceed? [Y/n]: ").strip().lower()

        if confirm == 'n':
            print("\n   Cancelled.")
            self.wait_for_enter()
            return

        print(f"\n   Enabling SCF...")

        for status in project_status:
            proj = status['proj']
            proj_path = status['path']

            if not proj_path.exists():
                continue

            print(f"   â€¢ {proj['name']}...", end=" ")
            try:
                # Initialize SCF in the project
                scf_dir = proj_path / '.scf'
                scf_dir.mkdir(exist_ok=True)

                # Copy templates (only if not exists)
                templates_dir = self.framework_path / 'templates' / 'spoke'
                added = []
                if templates_dir.exists():
                    import shutil
                    for template_file in templates_dir.glob('*'):
                        if template_file.is_file():
                            dest = scf_dir / template_file.name
                            if not dest.exists():
                                shutil.copy(template_file, dest)
                                added.append(template_file.name)

                # Update registry
                registry = self.load_registry()
                for p in registry.get('projects', []):
                    if p['name'] == proj['name']:
                        p['scf_enabled'] = True
                        break
                self.save_registry(registry)

                if added:
                    print(f"âœ… Added {len(added)} file(s)")
                elif status['existing']:
                    print(f"âœ… Preserved {len(status['existing'])} existing file(s)")
                else:
                    print("âœ…")
            except Exception as e:
                print(f"âŒ {e}")

        self.wait_for_enter()

    def _sync_projects_batch(self, projects: list):
        """Sync multiple projects"""
        self.clear_screen()
        print("\n   ğŸ”„ Sync Projects")
        print("   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n")

        for i, proj in enumerate(projects, 1):
            print(f"   {i}. {proj['name']}")

        print(f"\n   Selection (1,3,5 or 1-{len(projects)}) [all]: ", end="")
        selection = input().strip().lower()
        if selection in ('b', 'c'):
            return

        indices = self._parse_selection(selection, len(projects))
        if not indices:
            print("   No valid selection")
            self.wait_for_enter()
            return

        selected = [projects[i] for i in indices]
        print(f"\n   Syncing {len(selected)} project(s)...")

        for proj in selected:
            proj_path = Path(proj['path']).expanduser()
            print(f"   â€¢ {proj['name']}...", end=" ")

            if not proj_path.exists():
                print("âŒ Path not found")
                continue

            try:
                # Run sync for this project
                result = subprocess.run(
                    [sys.executable, str(self.framework_path / 'scf'), 'sync', str(proj_path)],
                    capture_output=True, text=True, timeout=60
                )
                if result.returncode == 0:
                    # Update last_sync in registry
                    registry = self.load_registry()
                    for p in registry.get('projects', []):
                        if p['name'] == proj['name']:
                            p['last_sync'] = datetime.now(timezone.utc).isoformat()
                            break
                    self.save_registry(registry)
                    print("âœ…")
                else:
                    print(f"âš ï¸  {result.stderr[:50] if result.stderr else 'Unknown error'}")
            except subprocess.TimeoutExpired:
                print("âš ï¸  Timeout")
            except Exception as e:
                print(f"âŒ {e}")

        self.wait_for_enter()

    def _learn_from_projects(self, projects: list):
        """Learn patterns from projects"""
        self.clear_screen()
        print("\n   ğŸ§  Learn from Projects")
        print("   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n")

        for i, proj in enumerate(projects, 1):
            print(f"   {i}. {proj['name']}")

        print(f"\n   Selection (1,3,5 or 1-{len(projects)}) [all]: ", end="")
        selection = input().strip().lower()
        if selection in ('b', 'c'):
            return

        indices = self._parse_selection(selection, len(projects))
        if not indices:
            print("   No valid selection")
            self.wait_for_enter()
            return

        selected = [projects[i] for i in indices]
        print(f"\n   Learning from {len(selected)} project(s)...")

        learnings_dir = self.hub_path / 'learnings'
        learnings_dir.mkdir(exist_ok=True)

        total_learnings = 0

        for proj in selected:
            proj_path = Path(proj['path']).expanduser()
            print(f"\n   ğŸ“‚ {proj['name']}")

            if not proj_path.exists():
                print("      âŒ Path not found")
                continue

            # Look for signals and decisions
            scf_dir = proj_path / '.scf'
            buildstate_path = scf_dir / 'BUILDSTATE.json'
            signals_path = scf_dir / 'spoke-signals.jsonl'

            project_learnings = []

            # Extract high-impact decisions from BUILDSTATE.json
            if buildstate_path.exists():
                try:
                    buildstate = json.loads(buildstate_path.read_text())
                    decisions = buildstate.get('decisions', [])
                    high_impact = [d for d in decisions if d.get('impact', 0) >= 8]
                    for decision in high_impact:
                        project_learnings.append({
                            'type': 'decision',
                            'source_project': proj['name'],
                            'source_path': str(proj_path),
                            'date': decision.get('date'),
                            'topic': decision.get('decision'),
                            'rationale': decision.get('rationale'),
                            'impact': decision.get('impact'),
                            'learned_at': datetime.now(timezone.utc).isoformat()
                        })
                    if high_impact:
                        print(f"      â€¢ Found {len(high_impact)} high-impact decisions")
                except Exception as e:
                    print(f"      âš ï¸  Error reading BUILDSTATE: {e}")

            # Extract offers from spoke-signals.jsonl
            if signals_path.exists():
                try:
                    offers = []
                    with open(signals_path) as f:
                        for line in f:
                            if line.strip():
                                signal = json.loads(line)
                                for offer in signal.get('offers', []):
                                    if offer.get('impact', 0) >= 8:
                                        offers.append({
                                            'type': offer.get('type', 'pattern'),
                                            'source_project': proj['name'],
                                            'source_path': str(proj_path),
                                            'date': signal.get('timestamp'),
                                            'topic': offer.get('topic'),
                                            'context': offer.get('context'),
                                            'impact': offer.get('impact'),
                                            'learned_at': datetime.now(timezone.utc).isoformat()
                                        })
                    project_learnings.extend(offers)
                    if offers:
                        print(f"      â€¢ Found {len(offers)} signaled learnings")
                except Exception as e:
                    print(f"      âš ï¸  Error reading signals: {e}")

            # Save learnings
            if project_learnings:
                learning_file = learnings_dir / f"{proj['name']}.json"
                existing = []
                if learning_file.exists():
                    try:
                        existing = json.loads(learning_file.read_text())
                    except:
                        pass

                # Merge, avoiding duplicates by topic
                existing_topics = {l.get('topic') for l in existing}
                new_learnings = [l for l in project_learnings if l.get('topic') not in existing_topics]

                if new_learnings:
                    all_learnings = existing + new_learnings
                    with open(learning_file, 'w') as f:
                        json.dump(all_learnings, f, indent=2)
                    print(f"      âœ… Saved {len(new_learnings)} new learning(s)")
                    total_learnings += len(new_learnings)
                else:
                    print(f"      â„¹ï¸  No new learnings (already captured)")
            else:
                print(f"      â„¹ï¸  No high-impact learnings found")

        print(f"\n   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
        print(f"   ğŸ“Š Total new learnings captured: {total_learnings}")

        self.wait_for_enter()

    def settings_menu(self):
        """Hub settings menu"""
        while True:
            self.clear_screen()
            profile = self.load_profile()

            print(f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    âš™ï¸  Hub Settings                           â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

   Current Settings:
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   ğŸ‘¤ Name:      {profile.get('user', {}).get('name', 'Not set')}
   ğŸ’¼ Focus:     {profile.get('work_style', {}).get('description', 'Not set')}
   ğŸ¤– AI Style:  {profile.get('work_style', {}).get('ai_collaboration_style', 'collaborative')}
   ğŸ“ Hub Path:  {self.hub_path}

   1. âœï¸  Edit name
   2. âœï¸  Edit focus
   3. âœï¸  Edit AI collaboration style
   4. ğŸ“‚ Open hub-profile.json

   b. Back
""")
            choice = self.get_choice(4)

            if choice == 'b':
                return
            elif choice == '1':
                new_name = input("\n   Enter new name: ").strip()
                if new_name:
                    profile['user']['name'] = new_name
                    self._save_profile(profile)
                    print("   âœ… Updated!")
                    self.wait_for_enter()
            elif choice == '2':
                new_focus = input("\n   Enter your focus/role: ").strip()
                if new_focus:
                    profile['work_style']['description'] = new_focus
                    self._save_profile(profile)
                    print("   âœ… Updated!")
                    self.wait_for_enter()
            elif choice == '3':
                print("\n   AI Collaboration Style:")
                print("   1. Autonomous - AI takes initiative")
                print("   2. Collaborative - Discuss first")
                print("   3. Supervised - Always ask")
                style_choice = input("   > ").strip()
                styles = {'1': 'autonomous', '2': 'collaborative', '3': 'supervised'}
                if style_choice in styles:
                    profile['work_style']['ai_collaboration_style'] = styles[style_choice]
                    self._save_profile(profile)
                    print("   âœ… Updated!")
                    self.wait_for_enter()
            elif choice == '4':
                import os
                editor = os.environ.get('EDITOR', 'nano')
                os.system(f'{editor} "{self.hub_path}/hub-profile.json"')

    def _save_profile(self, profile: dict):
        """Save hub profile"""
        profile_path = self.hub_path / 'hub-profile.json'
        with open(profile_path, 'w') as f:
            json.dump(profile, f, indent=2)


class SCFCommands:
    """Main SCF command implementations"""

    @staticmethod
    def cmd_init(args):
        """Initialize SCF in a project (spoke mode) or setup hub"""
        project_path = Path(args.path).resolve()

        if args.hub:
            print("ğŸ—ï¸  Setting up SCF Hub...")
            print("Use 'scf hub create' for guided hub setup.")
        elif args.guided:
            SCFCommands._guided_init(project_path, args)
        else:
            print(f"ğŸš€ Initializing SCF in: {project_path.name}")
            # Use existing teach.py init logic
            hub_path = Path(__file__).parent.resolve()
            init_project(project_path, hub_path, args.verbose)

    @staticmethod
    def _guided_init(project_path: Path, args):
        """Guided initialization with foundation questions"""
        print(f"\nğŸš€ Guided SCF Setup for: {project_path.name}\n")
        print("Let's establish your project foundation.\n")

        # Gather foundation info
        print("ğŸ“‹ Project Identity:\n")

        name = input("   Project name: ").strip() or project_path.name

        print("\n   What type of project is this?")
        print("   [1] Code - Software development")
        print("   [2] Research - Investigation, analysis")
        print("   [3] Writing - Documentation, content")
        print("   [4] Design - UI/UX, architecture")
        print("   [5] Hybrid - Mix of above")

        type_map = {'1': 'code', '2': 'research', '3': 'writing', '4': 'design', '5': 'hybrid'}
        while True:
            type_choice = input("   > ").strip()
            if type_choice in type_map:
                project_type = type_map[type_choice]
                break
            print("   Please enter 1-5")

        one_liner = input("\n   One-sentence description: ").strip()
        success = input("   What does 'done' look like? ").strip()

        print("\nğŸ“‹ Boundaries:\n")
        in_scope = input("   What's IN scope? (comma-separated): ").strip()
        out_scope = input("   What's OUT of scope? (comma-separated): ").strip()

        print("\nğŸ“‹ AI Collaboration:\n")
        print("   How should AI work with you?")
        print("   [1] Autonomous - Take initiative")
        print("   [2] Collaborative - Discuss first")
        print("   [3] Supervised - Always ask")

        style_map = {'1': 'autonomous', '2': 'collaborative', '3': 'supervised'}
        while True:
            style_choice = input("   > ").strip()
            if style_choice in style_map:
                ai_style = style_map[style_choice]
                break
            print("   Please enter 1-3")

        # Initialize with foundation
        hub_path = Path(__file__).parent.resolve()
        init_project(project_path, hub_path, args.verbose)

        # Update buildstate with foundation
        scf_dir = project_path / '.scf'
        buildstate_path = scf_dir / 'BUILDSTATE.json'

        if buildstate_path.exists():
            with open(buildstate_path) as f:
                buildstate = json.load(f)
        else:
            buildstate = {}

        # Add foundation
        buildstate['_project_foundation'] = {
            "completed": True,
            "completed_at": datetime.now(timezone.utc).isoformat(),
            "completed_with": "scf init --guided",
            "identity": {
                "type": project_type,
                "name": name,
                "one_liner": one_liner,
                "success_looks_like": success
            },
            "boundaries": {
                "in_scope": [s.strip() for s in in_scope.split(',') if s.strip()],
                "out_of_scope": [s.strip() for s in out_scope.split(',') if s.strip()],
                "constraints": []
            },
            "approach": {
                "ai_collaboration_style": ai_style
            },
            "philosophy": {
                "core_principle": "AI as responsible partner, not just enabler",
                "behaviors": [
                    "Detect scope drift and flag before enabling",
                    "Require explicit acknowledgment for direction changes"
                ]
            },
            "evolution_log": [{
                "date": datetime.now().strftime("%Y-%m-%d"),
                "change": "Project foundation established",
                "acknowledged_by": "User via guided setup",
                "ai_partner": "scf CLI"
            }]
        }

        # Update project info
        buildstate['project'] = {
            "name": name,
            "type": project_type,
            "description": one_liner
        }

        with open(buildstate_path, 'w') as f:
            json.dump(buildstate, f, indent=2)

        print(f"\nâœ… Project foundation established!")
        print(f"   AI assistants will now work within your defined boundaries.")

    @staticmethod
    def cmd_sync(args):
        """Sync project with hub or check sync status"""
        project_path = Path(args.path or ".").resolve()

        if args.status:
            print(f"ğŸ” Checking sync status for: {project_path.name}")
            check_sync_status(project_path)
        else:
            print(f"ğŸ”„ Syncing {project_path.name} with hub...")
            hub_path = Path(__file__).parent.resolve()
            update_project(project_path, hub_path, args.verbose)

    @staticmethod
    def cmd_hub(args):
        """Hub management commands"""
        framework_path = Path(__file__).parent.resolve()
        hub_manager = SCFHubManager(framework_path)

        # Find hub for most operations
        hub_path = hub_manager.find_hub()

        # Launch interactive mode if no action or explicit --interactive
        if args.action is None or (hasattr(args, 'interactive') and args.interactive):
            if not hub_path:
                print("âŒ No hub found. Let's create one!\n")
                hub_manager.create_hub(Path("~/scf-hub").expanduser())
                hub_path = hub_manager.find_hub()

            menu = SCFHubMenu(hub_path, hub_manager, framework_path)
            menu.run()
            return

        if args.action == "help":
            SCFCommands._hub_help()

        elif args.action == "create":
            create_path = Path(args.path or "~/scf-hub").expanduser()
            hub_manager.create_hub(create_path, interactive=not args.non_interactive)

        elif args.action == "locate":
            if hub_path:
                print(f"âœ… Hub found at: {hub_path}")
            else:
                print("âŒ No hub found.")
                print("\nTo create a hub, run: scf hub create")

        elif args.action == "status":
            SCFCommands._hub_status(hub_path)

        elif args.action == "stats":
            SCFCommands._hub_stats(hub_path, hub_manager)

        elif args.action == "projects":
            SCFCommands._hub_projects(hub_path, args)

        elif args.action == "learn":
            SCFCommands._hub_learn(hub_path, hub_manager, args)

        elif args.action == "teach":
            SCFCommands._hub_teach(hub_path, hub_manager, args)

        elif args.action == "scan":
            SCFCommands._hub_scan(hub_path, hub_manager)

    @staticmethod
    def _hub_help():
        """Show hub-specific help"""
        print("""
ğŸ“Š SCF Hub Commands
==================

  scf hub status              Show hub status and health
  scf hub stats               Detailed statistics on projects and learnings
  scf hub locate              Find hub location

Project Management:
  scf hub projects            List all registered projects
  scf hub projects --add <path>       Add a project to hub
  scf hub projects --remove <name>    Remove a project from hub
  scf hub projects --info <name>      Show project details
  scf hub scan                Scan directories for new projects

Learning & Teaching:
  scf hub learn               Gather learnings from all spokes
  scf hub learn <project>     Learn from specific project
  scf hub teach               Push learnings to all spokes
  scf hub teach <project>     Teach specific project

Setup:
  scf hub create              Create a new hub (interactive)
  scf hub create <path>       Create hub at specific location

Examples:
  scf hub projects --add ~/projects/my-app
  scf hub learn session-continuity-framework
  scf hub teach --all
""")

    @staticmethod
    def _hub_status(hub_path: Path):
        """Show hub status"""
        if not hub_path:
            print("âŒ No hub configured. Run: scf hub create")
            return

        print(f"ğŸ“Š Hub Status")
        print("=" * 50)
        print(f"\nğŸ“ Location: {hub_path}\n")

        # Show hub info
        profile_path = hub_path / 'hub-profile.json'
        if profile_path.exists():
            with open(profile_path) as f:
                profile = json.load(f)
            print(f"ğŸ‘¤ User: {profile.get('user', {}).get('name', 'Unknown')}")
            print(f"ğŸ’¼ Focus: {profile.get('work_style', {}).get('description', 'Not set')}")
            print(f"ğŸ¤– AI Style: {profile.get('work_style', {}).get('ai_collaboration_style', 'collaborative')}")
            created = profile.get('hub_config', {}).get('created_at', 'Unknown')
            if created != 'Unknown':
                created = created.split('T')[0]
            print(f"ğŸ“… Created: {created}")

        # Count and list projects
        registry_path = hub_path / '.scf-registry' / 'spoke-projects.json'
        if registry_path.exists():
            with open(registry_path) as f:
                registry = json.load(f)
            projects = registry.get('projects', [])
            scf_enabled = sum(1 for p in projects if p.get('scf_enabled'))
            print(f"\nğŸ“ Projects: {len(projects)} total ({scf_enabled} SCF-enabled)")

            if projects:
                print("\n   Recent projects:")
                for proj in projects[:5]:
                    status = "ğŸŒŸ" if proj.get('scf_enabled') else "ğŸ“"
                    print(f"   {status} {proj['name']}")
                if len(projects) > 5:
                    print(f"   ... and {len(projects) - 5} more")

        # Check learnings
        learnings_dir = hub_path / 'learnings'
        if learnings_dir.exists():
            learning_files = list(learnings_dir.glob('*.json'))
            print(f"\nğŸ§  Learnings: {len(learning_files)} patterns stored")

        print(f"\nğŸ’¡ Run 'scf hub stats' for detailed statistics")

    @staticmethod
    def _hub_stats(hub_path: Path, hub_manager):
        """Show detailed hub statistics"""
        if not hub_path:
            print("âŒ No hub configured. Run: scf hub create")
            return

        print(f"ğŸ“Š Hub Statistics")
        print("=" * 50)

        registry_path = hub_path / '.scf-registry' / 'spoke-projects.json'
        if not registry_path.exists():
            print("\nâŒ No project registry found")
            return

        with open(registry_path) as f:
            registry = json.load(f)

        projects = registry.get('projects', [])
        scf_enabled = [p for p in projects if p.get('scf_enabled')]
        regular = [p for p in projects if not p.get('scf_enabled')]

        print(f"\nğŸ“ Projects Overview")
        print(f"   Total registered: {len(projects)}")
        print(f"   SCF-enabled:      {len(scf_enabled)}")
        print(f"   Regular:          {len(regular)}")

        # Sync status
        needs_sync = []
        never_synced = []
        for proj in projects:
            if proj.get('scf_enabled'):
                if not proj.get('last_sync'):
                    never_synced.append(proj['name'])
                # Could check actual sync dates here

        if never_synced:
            print(f"\nâš ï¸  Never synced: {len(never_synced)} projects")
            for name in never_synced[:3]:
                print(f"      â€¢ {name}")

        # Learnings stats
        learnings_dir = hub_path / 'learnings'
        print(f"\nğŸ§  Learnings")
        if learnings_dir.exists():
            learning_files = list(learnings_dir.glob('*.json'))
            print(f"   Patterns stored: {len(learning_files)}")
        else:
            print(f"   Patterns stored: 0")
            print(f"   ğŸ’¡ Run 'scf hub learn' to gather learnings from spokes")

        # Recommendations
        print(f"\nğŸ’¡ Recommendations")
        if regular:
            print(f"   â€¢ {len(regular)} projects could be SCF-enabled")
        if never_synced:
            print(f"   â€¢ {len(never_synced)} projects need initial sync")
        if not scf_enabled:
            print(f"   â€¢ Run 'scf hub scan' to discover more projects")

    @staticmethod
    def _hub_projects(hub_path: Path, args):
        """List and manage hub projects"""
        if not hub_path:
            print("âŒ No hub configured. Run: scf hub create")
            return

        registry_path = hub_path / '.scf-registry' / 'spoke-projects.json'

        # Handle --add
        if args.add:
            SCFCommands._hub_projects_add(hub_path, registry_path, args.add)
            return

        # Handle --remove
        if args.remove:
            SCFCommands._hub_projects_remove(registry_path, args.remove)
            return

        # Handle --info
        if args.info:
            SCFCommands._hub_projects_info(registry_path, args.info)
            return

        # Default: list all projects
        if not registry_path.exists():
            print("ğŸ“ No projects registered yet")
            print("   Run 'scf hub scan' to discover projects")
            return

        with open(registry_path) as f:
            registry = json.load(f)

        projects = registry.get('projects', [])
        if not projects:
            print("ğŸ“ No projects registered yet")
            return

        print(f"ğŸ“ Registered Projects ({len(projects)})")
        print("=" * 50)

        for proj in sorted(projects, key=lambda x: x['name'].lower()):
            status = "ğŸŒŸ" if proj.get('scf_enabled') else "ğŸ“"
            sync = proj.get('last_sync', 'never')
            if sync != 'never':
                sync = sync.split('T')[0]
            print(f"\n{status} {proj['name']}")
            print(f"   Path: {proj['path']}")
            print(f"   Type: {proj.get('type', 'unknown')}")
            print(f"   Last sync: {sync}")

    @staticmethod
    def _hub_projects_add(hub_path: Path, registry_path: Path, project_path: str):
        """Add a project to the hub"""
        proj_path = Path(project_path).expanduser().resolve()

        if not proj_path.exists():
            print(f"âŒ Path not found: {proj_path}")
            return

        # Load or create registry
        if registry_path.exists():
            with open(registry_path) as f:
                registry = json.load(f)
        else:
            registry = {"version": "1.0", "projects": []}

        # Check if already registered
        existing = {p['path'] for p in registry.get('projects', [])}
        if str(proj_path) in existing:
            print(f"âš ï¸  Project already registered: {proj_path.name}")
            return

        # Detect project info
        is_scf = (proj_path / '.scf').exists() or (proj_path / 'buildstate.json').exists()

        proj_info = {
            'name': proj_path.name,
            'path': str(proj_path),
            'type': 'unknown',
            'scf_enabled': is_scf,
            'added_at': datetime.now(timezone.utc).isoformat(),
            'last_sync': None
        }

        # Read SCF details if available
        if is_scf:
            for bs_path in [proj_path / '.scf' / 'BUILDSTATE.json', proj_path / 'buildstate.json']:
                if bs_path.exists():
                    try:
                        with open(bs_path) as f:
                            data = json.load(f)
                        proj_info['type'] = data.get('project', {}).get('type', 'unknown')

                        # Update spoke's hub_path
                        if '_scf_metadata' in data:
                            data['_scf_metadata']['hub_path'] = str(hub_path)
                            with open(bs_path, 'w') as f:
                                json.dump(data, f, indent=2)
                        break
                    except:
                        pass

        registry['projects'].append(proj_info)

        with open(registry_path, 'w') as f:
            json.dump(registry, f, indent=2)

        status = "ğŸŒŸ SCF-enabled" if is_scf else "ğŸ“ Regular"
        print(f"âœ… Added: {proj_path.name} ({status})")

    @staticmethod
    def _hub_projects_remove(registry_path: Path, project_name: str):
        """Remove a project from the hub"""
        if not registry_path.exists():
            print("âŒ No projects registered")
            return

        with open(registry_path) as f:
            registry = json.load(f)

        projects = registry.get('projects', [])
        original_count = len(projects)

        # Filter out the project (match by name or path)
        registry['projects'] = [
            p for p in projects
            if p['name'].lower() != project_name.lower() and
               not p['path'].endswith(project_name)
        ]

        if len(registry['projects']) == original_count:
            print(f"âŒ Project not found: {project_name}")
            return

        with open(registry_path, 'w') as f:
            json.dump(registry, f, indent=2)

        print(f"âœ… Removed: {project_name}")

    @staticmethod
    def _hub_projects_info(registry_path: Path, project_name: str):
        """Show detailed project info"""
        if not registry_path.exists():
            print("âŒ No projects registered")
            return

        with open(registry_path) as f:
            registry = json.load(f)

        # Find project
        proj = None
        for p in registry.get('projects', []):
            if p['name'].lower() == project_name.lower() or p['path'].endswith(project_name):
                proj = p
                break

        if not proj:
            print(f"âŒ Project not found: {project_name}")
            return

        print(f"ğŸ“¦ Project: {proj['name']}")
        print("=" * 50)
        print(f"   Path:        {proj['path']}")
        print(f"   Type:        {proj.get('type', 'unknown')}")
        print(f"   SCF-enabled: {'Yes' if proj.get('scf_enabled') else 'No'}")
        print(f"   Added:       {proj.get('added_at', 'unknown').split('T')[0]}")
        print(f"   Last sync:   {proj.get('last_sync', 'never')}")

        # If SCF-enabled, read more details
        if proj.get('scf_enabled'):
            proj_path = Path(proj['path'])
            for bs_path in [proj_path / '.scf' / 'BUILDSTATE.json', proj_path / 'buildstate.json']:
                if bs_path.exists():
                    try:
                        with open(bs_path) as f:
                            data = json.load(f)

                        if '_project_foundation' in data:
                            foundation = data['_project_foundation']
                            if foundation.get('identity'):
                                print(f"\nğŸ“‹ Foundation:")
                                print(f"   {foundation['identity'].get('one_liner', 'No description')}")

                        if 'features' in data and data['features']:
                            print(f"\nâœ¨ Features: {len(data['features'])}")
                            for feat in data['features'][:3]:
                                print(f"   â€¢ {feat.get('name', 'unnamed')}")

                        if 'decisions' in data and data['decisions']:
                            print(f"\nğŸ“ Decisions: {len(data['decisions'])}")

                        break
                    except:
                        pass

    @staticmethod
    def _hub_scan(hub_path: Path, hub_manager):
        """Scan for new projects"""
        if not hub_path:
            print("âŒ No hub configured. Run: scf hub create")
            return

        registry_dir = hub_path / '.scf-registry'
        hub_manager._discover_existing_projects(hub_path, registry_dir)

    @staticmethod
    def _hub_learn(hub_path: Path, hub_manager, args):
        """Gather learnings from spokes"""
        if not hub_path:
            print("âŒ No hub configured. Run: scf hub create")
            return

        target = args.target if hasattr(args, 'target') and args.target else None

        print(f"ğŸ§  Learning from {'project: ' + target if target else 'all spokes'}...")

        registry_path = hub_path / '.scf-registry' / 'spoke-projects.json'
        if not registry_path.exists():
            print("âŒ No projects registered")
            return

        with open(registry_path) as f:
            registry = json.load(f)

        projects = [p for p in registry.get('projects', []) if p.get('scf_enabled')]

        if target:
            projects = [p for p in projects if p['name'].lower() == target.lower()]
            if not projects:
                print(f"âŒ SCF-enabled project not found: {target}")
                return

        learnings_dir = hub_path / 'learnings'
        learnings_dir.mkdir(exist_ok=True)

        learned_count = 0
        for proj in projects:
            proj_path = Path(proj['path'])
            signals_path = proj_path / '.scf' / 'spoke-signals.jsonl'

            if not signals_path.exists():
                signals_path = proj_path / 'spoke-signals.jsonl'

            if signals_path.exists():
                print(f"   ğŸ“– Reading signals from {proj['name']}...")
                # Read and process signals
                # For now, just count them
                with open(signals_path) as f:
                    signals = [json.loads(line) for line in f if line.strip()]
                    high_impact = [s for s in signals if s.get('offers')]
                    if high_impact:
                        learned_count += len(high_impact)
                        print(f"      Found {len(high_impact)} high-impact learnings")

        print(f"\nâœ… Gathered {learned_count} learnings from {len(projects)} projects")
        print(f"   ğŸ’¡ Run 'scf hub teach' to push learnings to other spokes")

    @staticmethod
    def _hub_teach(hub_path: Path, hub_manager, args):
        """Push learnings to spokes"""
        if not hub_path:
            print("âŒ No hub configured. Run: scf hub create")
            return

        target = args.target if hasattr(args, 'target') and args.target else None

        print(f"ğŸ“š Teaching {'project: ' + target if target else 'all spokes'}...")

        registry_path = hub_path / '.scf-registry' / 'spoke-projects.json'
        if not registry_path.exists():
            print("âŒ No projects registered")
            return

        with open(registry_path) as f:
            registry = json.load(f)

        projects = [p for p in registry.get('projects', []) if p.get('scf_enabled')]

        if target:
            projects = [p for p in projects if p['name'].lower() == target.lower()]
            if not projects:
                print(f"âŒ SCF-enabled project not found: {target}")
                return

        taught_count = 0
        for proj in projects:
            proj_path = Path(proj['path'])
            print(f"   ğŸ“ Updating {proj['name']}...")

            # Update kb-sync.json
            kb_sync_path = proj_path / '.scf' / 'kb-sync.json'
            if kb_sync_path.exists():
                try:
                    with open(kb_sync_path) as f:
                        kb_sync = json.load(f)
                    kb_sync['last_sync_date'] = datetime.now(timezone.utc).isoformat()
                    kb_sync['hub_kb_version'] = datetime.now(timezone.utc).isoformat()
                    with open(kb_sync_path, 'w') as f:
                        json.dump(kb_sync, f, indent=2)
                    taught_count += 1
                except:
                    pass

            # Update last_sync in registry
            proj['last_sync'] = datetime.now(timezone.utc).isoformat()

        # Save registry
        with open(registry_path, 'w') as f:
            json.dump(registry, f, indent=2)

        print(f"\nâœ… Updated {taught_count} projects")

    @staticmethod
    def cmd_server(args):
        """Start/stop/status local SCF server"""
        try:
            from scf_local_server import SCFLocalServer
        except ImportError:
            print("âŒ Server module not available")
            return

        if args.action == "start":
            print("ğŸŒ Starting SCF local server...")
            server = SCFLocalServer(port=args.port)
            print(f"âœ… Server running on http://localhost:{args.port}")

        elif args.action == "stop":
            print("ğŸ›‘ Stopping SCF server...")

        elif args.action == "status":
            print("ğŸ“Š Server status: checking...")

    @staticmethod
    def cmd_projects(args):
        """Project discovery and management (hub features)"""
        if args.action == "scan":
            print("ğŸ” Scanning for SCF projects...")
            try:
                hunter_main()
            except:
                print("   Scanning current directory tree...")

        elif args.action == "health":
            print("ğŸ¥ Project health overview:")
            # Show health dashboard

        elif args.action == "learn":
            print("ğŸ§  Learning from project patterns...")


def create_parser():
    """Create the unified argument parser"""
    parser = argparse.ArgumentParser(
        description="SCF - Session Continuity Framework",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  scf init                    # Initialize current directory as SCF project
  scf init --guided           # Guided setup with foundation questions
  scf hub create              # Create your personal hub
  scf hub create ~/my-hub     # Create hub at specific location
  scf sync                    # Sync current project with hub
  scf sync --status           # Check sync status
  scf projects scan           # Discover projects

For more help: scf <command> --help
        """
    )

    parser.add_argument('--verbose', '-v', action='store_true', help='Verbose output')

    # Subcommands
    subparsers = parser.add_subparsers(dest='command', help='Available commands')

    # Init command
    init_parser = subparsers.add_parser('init', help='Initialize SCF in project')
    init_parser.add_argument('path', nargs='?', default='.', help='Project path (default: current directory)')
    init_parser.add_argument('--hub', action='store_true', help='[Deprecated] Use "scf hub create" instead')
    init_parser.add_argument('--guided', '-g', action='store_true', help='Guided setup with foundation questions')
    init_parser.add_argument('--fresh', action='store_true', help='Reset existing SCF files')

    # Hub command
    hub_parser = subparsers.add_parser('hub', help='Hub management (run "scf hub" for full help)')
    hub_parser.add_argument('action', nargs='?', choices=['create', 'locate', 'status', 'stats', 'projects', 'scan', 'learn', 'teach', 'help'],
                           help='Hub action')
    hub_parser.add_argument('target', nargs='?', help='Target project for learn/teach')
    hub_parser.add_argument('path', nargs='?', help='Hub path for create (default: ~/scf-hub)')
    hub_parser.add_argument('--non-interactive', action='store_true', help='Skip interactive prompts')
    hub_parser.add_argument('--add', metavar='PATH', help='Add project to hub')
    hub_parser.add_argument('--remove', metavar='NAME', help='Remove project from hub')
    hub_parser.add_argument('--info', metavar='NAME', help='Show project details')

    # Sync command
    sync_parser = subparsers.add_parser('sync', help='Sync with hub or check status')
    sync_parser.add_argument('path', nargs='?', help='Project path (default: current directory)')
    sync_parser.add_argument('--status', action='store_true', help='Check sync status only')

    # Server command
    server_parser = subparsers.add_parser('server', help='Local server management')
    server_parser.add_argument('action', choices=['start', 'stop', 'status'], help='Server action')
    server_parser.add_argument('--port', type=int, default=8765, help='Server port (default: 8765)')

    # Projects command (hub features)
    projects_parser = subparsers.add_parser('projects', help='Project discovery and management')
    projects_parser.add_argument('action', choices=['scan', 'health', 'learn'], help='Projects action')

    return parser


def main():
    """Main entry point for unified SCF CLI"""
    parser = create_parser()

    # If no arguments, show onboarding
    if len(sys.argv) == 1:
        onboarding = SCFOnboarding()
        onboarding.show_welcome()
        role = onboarding.choose_role()

        if role == "hub":
            print("\nğŸ—ï¸  Let's set up your SCF Hub:")
            print("Run: scf hub create")
        else:
            print(f"\nğŸ’» Let's add SCF to your current project:")
            print("Run: scf init --guided")
        return

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        return

    # Route to appropriate command
    try:
        if args.command == 'init':
            SCFCommands.cmd_init(args)
        elif args.command == 'hub':
            SCFCommands.cmd_hub(args)
        elif args.command == 'sync':
            SCFCommands.cmd_sync(args)
        elif args.command == 'server':
            SCFCommands.cmd_server(args)
        elif args.command == 'projects':
            SCFCommands.cmd_projects(args)
        else:
            parser.print_help()

    except KeyboardInterrupt:
        print("\n\nâš ï¸  Operation cancelled by user")
    except Exception as e:
        if hasattr(args, 'verbose') and args.verbose:
            import traceback
            traceback.print_exc()
        else:
            print(f"âŒ Error: {e}")
            print("Use --verbose for detailed error info")


if __name__ == '__main__':
    main()
