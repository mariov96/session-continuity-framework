#!/usr/bin/env python3
"""
SCF - Session Continuity Framework
Unified Command Line Interface

This replaces the 25+ separate Python scripts with a single, intuitive entry point.
Provides role-based onboarding and progressive complexity disclosure.
"""

import argparse
import sys
import json
import shutil
import subprocess
import hashlib
from pathlib import Path
from typing import Optional
from datetime import datetime, timezone, timedelta

# Import existing SCF modules
try:
    from teach import main as teach_main, init_project, update_project
    from scf_enhanced_overview import generate_enhanced_overview
    from buildstate_hunter_learner import main as hunter_main
    from scf_sync_checker import check_sync_status
except ImportError as e:
    # Allow partial imports for hub-only operations
    pass

class SCFOnboarding:
    """Handles user onboarding and role selection"""

    def show_welcome(self):
        """Display welcome message and explain SCF concept"""
        print("""
ğŸš€ Welcome to Session Continuity Framework (SCF)

SCF gives your AI assistants perfect memory across all your development sessions.
Never lose context, never repeat explanations, always stay in flow.

Choose your role:
""")

    def choose_role(self) -> str:
        """Let user choose between hub and spoke modes"""
        print("1. ğŸ“Š Project Manager (Hub) - Manage multiple projects from one central location")
        print("2. ğŸ’» Solo Developer (Spoke) - Add AI memory to a single project")
        print("3. â“ Learn More - Understand the difference")

        while True:
            choice = input("\nEnter your choice (1/2/3): ").strip()
            if choice == "1":
                return "hub"
            elif choice == "2":
                return "spoke"
            elif choice == "3":
                self.explain_hub_spoke()
            else:
                print("Please enter 1, 2, or 3")

    def explain_hub_spoke(self):
        """Explain hub vs spoke concept clearly"""
        print("""
ğŸ—ï¸  Hub vs Spoke - Simple Explanation:

ğŸ¯ SPOKE MODE (Solo Developer):
   - You work on ONE project
   - SCF adds "memory" to that project
   - AI assistants remember all your conversations
   - Perfect for: Individual projects, focused development

ğŸ“Š HUB MODE (Project Manager):
   - You manage MULTIPLE projects
   - Central dashboard shows all project health
   - Share learnings between projects
   - Perfect for: Teams, consultants, multiple client projects

Most people start with SPOKE mode for their current project.
""")


class SCFHubManager:
    """Manages SCF Hub creation and configuration"""

    def __init__(self, framework_path: Path):
        self.framework_path = framework_path
        self.templates_dir = framework_path / 'templates' / 'hub'

    def create_hub(self, hub_path: Path, interactive: bool = True) -> bool:
        """Create a new SCF hub at the specified location"""
        hub_path = hub_path.expanduser().resolve()

        print(f"\nğŸ—ï¸  Creating SCF Hub at: {hub_path}\n")

        # Create hub directory
        hub_path.mkdir(parents=True, exist_ok=True)

        # Create .scf directory (hub is also a spoke tracking itself)
        scf_dir = hub_path / '.scf'
        scf_dir.mkdir(exist_ok=True)

        # Create .scf-registry directory
        registry_dir = hub_path / '.scf-registry'
        registry_dir.mkdir(exist_ok=True)
        (registry_dir / 'spokes').mkdir(exist_ok=True)

        # Gather user info if interactive
        user_info = {}
        if interactive:
            user_info = self._gather_user_info()

        # Create hub-profile.json
        self._create_hub_profile(hub_path, user_info)

        # Create spoke-projects.json
        self._create_spoke_registry(registry_dir)

        # Create hub's own buildstate (it's a spoke tracking itself)
        self._create_hub_buildstate(scf_dir, hub_path)

        # Create learnings directory
        learnings_dir = hub_path / 'learnings'
        learnings_dir.mkdir(exist_ok=True)

        print(f"\nâœ… Hub created successfully at: {hub_path}")
        print(f"\nğŸ“ Structure created:")
        print(f"   {hub_path}/")
        print(f"   â”œâ”€â”€ .scf/                  # Hub's own buildstate")
        print(f"   â”œâ”€â”€ .scf-registry/         # Project registry")
        print(f"   â”‚   â”œâ”€â”€ spokes/            # Individual spoke tracking")
        print(f"   â”‚   â””â”€â”€ spoke-projects.json")
        print(f"   â”œâ”€â”€ hub-profile.json       # Your preferences")
        print(f"   â””â”€â”€ learnings/             # Cross-project patterns")

        # Discover existing projects
        if interactive:
            self._discover_existing_projects(hub_path, registry_dir)

        print(f"\nğŸš€ Next steps:")
        print(f"   1. Run 'scf hub status' to see connected projects")
        print(f"   2. Run 'scf init <path>' to add more projects")

        return True

    def _discover_existing_projects(self, hub_path: Path, registry_dir: Path):
        """Interactively discover and intake existing projects"""
        print(f"\nğŸ“‚ Project Discovery")
        print(f"=" * 50)

        discover = input("\nDo you have existing projects to discover? [Y/n]: ").strip().lower()
        if discover == 'n':
            print("   Skipping project discovery.")
            return

        # Get scan locations
        scan_paths = []
        print("\nEnter directories to scan for projects (one per line).")
        print("Common locations: ~/projects, ~/code, ~/work")
        print("Press Enter with empty line when done.\n")

        while True:
            path_input = input("   Scan path: ").strip()
            if not path_input:
                break
            scan_path = Path(path_input).expanduser()
            if scan_path.exists() and scan_path.is_dir():
                scan_paths.append(scan_path)
                print(f"   âœ“ Added: {scan_path}")
            else:
                print(f"   âœ— Path not found: {scan_path}")

        if not scan_paths:
            # Default to common locations
            default_paths = [Path.home() / 'projects', Path.home() / 'code']
            for dp in default_paths:
                if dp.exists():
                    scan_paths.append(dp)
            if scan_paths:
                print(f"\n   Using default paths: {', '.join(str(p) for p in scan_paths)}")

        if not scan_paths:
            print("   No valid paths to scan.")
            return

        # Load registry to get known projects
        registry_path = registry_dir / 'spoke-projects.json'
        known_paths = set()
        if registry_path.exists():
            try:
                registry = json.loads(registry_path.read_text())
                known_paths = {p.get('path') for p in registry.get('projects', []) if p.get('path')}
                if known_paths:
                    print(f"   (Skipping {len(known_paths)} already registered projects)")
            except:
                pass

        # Scan for projects
        print(f"\nğŸ” Scanning for projects...")
        discovered = self._scan_for_projects(scan_paths, known_paths)

        if not discovered:
            print("   No projects found.")
            return

        # Separate SCF-enabled from regular projects
        scf_projects = [p for p in discovered if p.get('scf_enabled')]
        regular_projects = [p for p in discovered if not p.get('scf_enabled')]

        print(f"\nğŸ“Š Found {len(discovered)} projects:")
        print(f"   â€¢ {len(scf_projects)} SCF-enabled (have .scf/ folder)")
        print(f"   â€¢ {len(regular_projects)} regular projects")

        # Present SCF-enabled projects first
        if scf_projects:
            print(f"\nğŸŒŸ SCF-Enabled Projects (already have context):")
            print("-" * 50)
            for proj in scf_projects:
                self._present_project(proj, is_scf=True)

        # Present regular projects
        if regular_projects:
            print(f"\nğŸ“ Regular Projects (can add SCF):")
            print("-" * 50)
            for proj in regular_projects:
                self._present_project(proj, is_scf=False)

        # Let user select which to intake
        print(f"\nğŸ“¥ Project Intake")
        print("-" * 50)
        print("For each project, choose: [Y]es intake, [N]o skip, [A]ll remaining, [Q]uit\n")

        intake_list = []
        skip_remaining = False
        intake_remaining = False

        for proj in discovered:
            if skip_remaining:
                break
            if intake_remaining:
                intake_list.append(proj)
                continue

            status = "ğŸŒŸ SCF" if proj.get('scf_enabled') else "ğŸ“ New"
            print(f"{status} {proj['name']}")
            if proj.get('scf_enabled') and proj.get('description'):
                print(f"      â””â”€ {proj['description'][:60]}...")

            choice = input(f"   Intake? [Y/n/a/q]: ").strip().lower()

            if choice == 'q':
                skip_remaining = True
            elif choice == 'a':
                intake_remaining = True
                intake_list.append(proj)
            elif choice != 'n':
                intake_list.append(proj)

        # Register selected projects
        if intake_list:
            self._register_projects(registry_dir, intake_list, hub_path)
            print(f"\nâœ… Registered {len(intake_list)} projects with hub")
        else:
            print("\n   No projects selected for intake.")

    def _scan_for_projects(self, scan_paths: list, known_paths: set = None) -> list:
        """Scan directories for projects (looks for git repos or common project markers)

        Args:
            scan_paths: List of directories to scan
            known_paths: Set of paths already in registry (will be skipped)
        """
        discovered = []
        seen_paths = set()
        known_paths = known_paths or set()

        for scan_path in scan_paths:
            # Look for immediate subdirectories that look like projects
            try:
                for item in scan_path.iterdir():
                    if not item.is_dir():
                        continue
                    if item.name.startswith('.'):
                        continue
                    if str(item.resolve()) in seen_paths:
                        continue
                    # Skip projects already in registry
                    if str(item.resolve()) in known_paths:
                        continue

                    # Check if it's a project
                    is_git = (item / '.git').exists()
                    is_scf = (item / '.scf').exists() or (item / 'buildstate.json').exists()
                    has_package = (item / 'package.json').exists()
                    has_pyproject = (item / 'pyproject.toml').exists() or (item / 'setup.py').exists()
                    has_cargo = (item / 'Cargo.toml').exists()

                    if is_git or is_scf or has_package or has_pyproject or has_cargo:
                        proj_info = {
                            'name': item.name,
                            'path': str(item.resolve()),
                            'scf_enabled': is_scf,
                            'has_git': is_git,
                            'description': None,
                            'project_type': None
                        }

                        # If SCF-enabled, read additional details
                        if is_scf:
                            proj_info.update(self._read_scf_details(item))

                        discovered.append(proj_info)
                        seen_paths.add(str(item.resolve()))

            except PermissionError:
                continue

        return sorted(discovered, key=lambda x: (not x['scf_enabled'], x['name'].lower()))

    def _read_scf_details(self, project_path: Path) -> dict:
        """Read details from SCF-enabled project"""
        details = {}

        # Try .scf/BUILDSTATE.json first, then buildstate.json
        buildstate_paths = [
            project_path / '.scf' / 'BUILDSTATE.json',
            project_path / 'buildstate.json'
        ]

        for bs_path in buildstate_paths:
            if bs_path.exists():
                try:
                    with open(bs_path) as f:
                        data = json.load(f)

                    # Extract useful info
                    if 'project' in data:
                        details['description'] = data['project'].get('description')
                        details['project_type'] = data['project'].get('type')

                    if '_project_foundation' in data:
                        foundation = data['_project_foundation']
                        if foundation.get('identity'):
                            details['description'] = details.get('description') or foundation['identity'].get('one_liner')
                            details['project_type'] = details.get('project_type') or foundation['identity'].get('type')

                    if '_scf_metadata' in data:
                        details['scf_version'] = data['_scf_metadata'].get('version')
                        details['hub_path'] = data['_scf_metadata'].get('hub_path')

                    break
                except (json.JSONDecodeError, KeyError):
                    pass

        return details

    def _present_project(self, proj: dict, is_scf: bool):
        """Display project info"""
        print(f"\n   ğŸ“¦ {proj['name']}")
        print(f"      Path: {proj['path']}")
        if is_scf:
            if proj.get('description'):
                print(f"      Desc: {proj['description']}")
            if proj.get('project_type'):
                print(f"      Type: {proj['project_type']}")
            if proj.get('scf_version'):
                print(f"      SCF:  v{proj['scf_version']}")
        else:
            markers = []
            if proj.get('has_git'):
                markers.append('git')
            print(f"      Markers: {', '.join(markers) if markers else 'directory'}")

    def _register_projects(self, registry_dir: Path, projects: list, hub_path: Path):
        """Register projects in the spoke registry"""
        registry_path = registry_dir / 'spoke-projects.json'

        # Load existing registry
        if registry_path.exists():
            with open(registry_path) as f:
                registry = json.load(f)
        else:
            registry = {"version": "1.0", "projects": [], "last_scan": None}

        # Add projects
        existing_paths = {p.get('path') for p in registry.get('projects', [])}

        for proj in projects:
            if proj['path'] not in existing_paths:
                registry['projects'].append({
                    'name': proj['name'],
                    'path': proj['path'],
                    'type': proj.get('project_type', 'unknown'),
                    'scf_enabled': proj.get('scf_enabled', False),
                    'added_at': datetime.now(timezone.utc).isoformat(),
                    'last_sync': None
                })

                # Update spoke's hub_path if SCF-enabled
                if proj.get('scf_enabled'):
                    self._update_spoke_hub_path(Path(proj['path']), hub_path)

        registry['last_scan'] = datetime.now(timezone.utc).isoformat()

        with open(registry_path, 'w') as f:
            json.dump(registry, f, indent=2)

    def _update_spoke_hub_path(self, project_path: Path, hub_path: Path):
        """Update a spoke's hub_path to point to this hub"""
        buildstate_paths = [
            project_path / '.scf' / 'BUILDSTATE.json',
            project_path / 'buildstate.json'
        ]

        for bs_path in buildstate_paths:
            if bs_path.exists():
                try:
                    with open(bs_path) as f:
                        data = json.load(f)

                    if '_scf_metadata' in data:
                        data['_scf_metadata']['hub_path'] = str(hub_path)

                        with open(bs_path, 'w') as f:
                            json.dump(data, f, indent=2)
                        break
                except (json.JSONDecodeError, KeyError):
                    pass

    def _gather_user_info(self) -> dict:
        """Interactive user info gathering"""
        print("ğŸ“‹ Let's personalize your hub:\n")

        name = input("   What name should AI partners call you? ").strip()

        print("\n   What's your primary development focus?")
        print("   (e.g., 'Full-stack web, Python automation')")
        focus = input("   > ").strip()

        print("\n   How do you prefer AI collaboration?")
        print("   [1] Autonomous - Take initiative, check in on big decisions")
        print("   [2] Collaborative - Discuss approach before implementing")
        print("   [3] Supervised - Always ask before acting")

        while True:
            style_choice = input("   > ").strip()
            if style_choice == "1":
                style = "autonomous"
                break
            elif style_choice == "2":
                style = "collaborative"
                break
            elif style_choice == "3":
                style = "supervised"
                break
            else:
                print("   Please enter 1, 2, or 3")

        return {
            'name': name,
            'focus': focus,
            'style': style
        }

    def _create_hub_profile(self, hub_path: Path, user_info: dict):
        """Create hub-profile.json with user info"""
        profile_template = self.templates_dir / 'hub-profile.json'

        if profile_template.exists():
            with open(profile_template) as f:
                profile = json.load(f)
        else:
            profile = {
                "user": {"name": None},
                "work_style": {"description": None},
                "hub_config": {}
            }

        # Fill in user info
        profile['user']['name'] = user_info.get('name', 'Developer')
        profile['work_style']['description'] = user_info.get('focus', '')
        profile['work_style']['ai_collaboration_style'] = user_info.get('style', 'collaborative')
        profile['hub_config']['created_at'] = datetime.now(timezone.utc).isoformat()
        profile['hub_config']['hub_path'] = str(hub_path)
        profile['hub_config']['framework_path'] = str(self.framework_path)

        profile_path = hub_path / 'hub-profile.json'
        with open(profile_path, 'w') as f:
            json.dump(profile, f, indent=2)

        print(f"   âœ… Created hub-profile.json")

    def _create_spoke_registry(self, registry_dir: Path):
        """Create spoke-projects.json registry"""
        registry_template = self.templates_dir / 'spoke-projects.json'

        if registry_template.exists():
            shutil.copy2(registry_template, registry_dir / 'spoke-projects.json')
        else:
            registry = {
                "version": "1.0",
                "projects": [],
                "last_scan": None
            }
            with open(registry_dir / 'spoke-projects.json', 'w') as f:
                json.dump(registry, f, indent=2)

        print(f"   âœ… Created spoke registry")

    def _create_hub_buildstate(self, scf_dir: Path, hub_path: Path):
        """Create hub's own buildstate (hub tracks itself as a spoke)"""
        buildstate = {
            "_scf_metadata": {
                "version": "2.2.0",
                "structure_version": "v2",
                "description": "SCF Hub - Your personal learning center",
                "is_hub": True,
                "hub_path": str(hub_path)
            },
            "_project_foundation": {
                "completed": True,
                "completed_at": datetime.now(timezone.utc).isoformat(),
                "identity": {
                    "type": "hub",
                    "name": "SCF Hub",
                    "one_liner": "Central hub for cross-project learnings",
                    "success_looks_like": "All projects connected, learnings flowing"
                },
                "boundaries": {
                    "in_scope": ["User preferences", "Project registry", "Cross-project learnings"],
                    "out_of_scope": ["Individual project code", "Framework development"]
                }
            },
            "_session_state": {
                "last_modified_by": "scf hub create",
                "last_modified_at": datetime.now(timezone.utc).isoformat(),
                "session_count": 1
            },
            "project": {
                "name": "SCF Hub",
                "type": "hub",
                "created": datetime.now(timezone.utc).isoformat()
            }
        }

        with open(scf_dir / 'BUILDSTATE.json', 'w') as f:
            json.dump(buildstate, f, indent=2)

        print(f"   âœ… Created hub buildstate")

    @staticmethod
    def find_hub() -> Optional[Path]:
        """Find existing hub location"""
        # Check common locations
        common_paths = [
            Path.home() / 'scf-hub',
            Path.home() / '.scf-hub',
            Path.home() / 'projects' / 'scf-hub'
        ]

        for path in common_paths:
            if (path / 'hub-profile.json').exists():
                return path

        # Check environment variable
        import os
        env_hub = os.environ.get('SCF_HUB_PATH')
        if env_hub:
            env_path = Path(env_hub).expanduser()
            if env_path.exists():
                return env_path

        return None


class SCFHubMenu:
    """Interactive menu-driven interface for SCF Hub"""

    def __init__(self, hub_path: Path, hub_manager, framework_path: Path):
        self.hub_path = hub_path
        self.hub_manager = hub_manager
        self.framework_path = framework_path
        self.registry_path = hub_path / '.scf-registry' / 'spoke-projects.json'

    def clear_screen(self):
        """Clear terminal screen"""
        import os
        os.system('clear' if os.name != 'nt' else 'cls')

    def wait_for_enter(self):
        """Wait for user to press Enter"""
        input("\n   Press Enter to continue...")

    def get_choice(self, max_choice: int, allow_back: bool = True) -> str:
        """Get user menu choice"""
        while True:
            choice = input("\n   Enter choice: ").strip().lower()
            if choice == 'q':
                return 'q'
            if allow_back and choice in ('b', 'back', '0'):
                return 'b'
            if choice.isdigit() and 1 <= int(choice) <= max_choice:
                return choice
            print(f"   Please enter 1-{max_choice}" + (", b for back, or q to quit" if allow_back else " or q to quit"))

    def load_registry(self) -> dict:
        """Load project registry"""
        if self.registry_path.exists():
            with open(self.registry_path) as f:
                return json.load(f)
        return {"version": "1.0", "projects": []}

    def save_registry(self, registry: dict):
        """Save project registry"""
        with open(self.registry_path, 'w') as f:
            json.dump(registry, f, indent=2)

    def load_profile(self) -> dict:
        """Load hub profile"""
        profile_path = self.hub_path / 'hub-profile.json'
        if profile_path.exists():
            with open(profile_path) as f:
                return json.load(f)
        return {}

    def _get_signal_hash(self, signal: dict) -> str:
        """Compute a unique hash for a signal based on its content."""
        # Use timestamp + type + first offer description for uniqueness
        parts = [
            signal.get('timestamp', ''),
            signal.get('type', ''),
        ]
        # Include offers content if present
        for offer in signal.get('offers', []):
            parts.append(offer.get('description', offer.get('pattern', '')))
        content = '|'.join(str(p) for p in parts)
        return hashlib.sha256(content.encode()).hexdigest()[:16]

    def _load_learned_signals(self) -> dict:
        """Load the registry of learned signals."""
        learned_file = self.hub_path / '.scf-registry' / 'learned-signals.json'
        if learned_file.exists():
            try:
                return json.loads(learned_file.read_text())
            except:
                pass
        return {'version': '1.0', 'signals': {}}

    def _save_learned_signals(self, data: dict):
        """Save the learned signals registry."""
        learned_file = self.hub_path / '.scf-registry' / 'learned-signals.json'
        learned_file.parent.mkdir(parents=True, exist_ok=True)
        with open(learned_file, 'w') as f:
            json.dump(data, f, indent=2)

    def _get_hub_version(self) -> str:
        """Get current hub version hash based on learnings content."""
        learnings_dir = self.hub_path / 'learnings'
        if not learnings_dir.exists():
            return 'empty'
        # Hash based on learning files and their modification times
        parts = []
        for f in sorted(learnings_dir.glob('*.json')):
            parts.append(f"{f.name}:{f.stat().st_mtime}")
        content = '|'.join(parts)
        return hashlib.sha256(content.encode()).hexdigest()[:12]

    def run(self):
        """Main menu loop"""
        while True:
            action = self.main_menu()
            if action == 'q':
                print("\nğŸ‘‹ Goodbye!\n")
                break

    def _get_recent_error_count(self) -> int:
        """Count errors from the last 24 hours"""
        error_log = self.hub_path / 'logs' / 'errors.jsonl'
        if not error_log.exists():
            return 0

        count = 0
        cutoff = datetime.now(timezone.utc) - timedelta(hours=24)
        try:
            with open(error_log) as f:
                for line in f:
                    if line.strip():
                        try:
                            entry = json.loads(line)
                            ts = datetime.fromisoformat(entry['timestamp'].replace('Z', '+00:00'))
                            if ts > cutoff:
                                count += len(entry.get('errors', []))
                        except:
                            pass
        except:
            pass
        return count

    def _generate_signal_opportunity_prompt(self, project_name: str, hub_learnings_info: dict) -> str:
        """Generate a prompt encouraging spoke LLM to signal back learnings."""
        now = datetime.now(timezone.utc).isoformat()

        # Build list of what was just taught
        taught_areas = []
        if hub_learnings_info.get('ide'):
            taught_areas.append(f"IDE configurations: {', '.join(hub_learnings_info['ide'][:5])}")
        if hub_learnings_info.get('patterns'):
            taught_areas.append(f"Language/workflow patterns: {', '.join(hub_learnings_info['patterns'][:5])}")
        if hub_learnings_info.get('other'):
            taught_areas.append(f"Project learnings: {len(hub_learnings_info['other'])} files")

        taught_section = '\n'.join(f"- {area}" for area in taught_areas) if taught_areas else "- General hub knowledge"

        return f'''# ğŸ”„ Signal Opportunity Check
> Last updated: {now}

## What You Just Received From Hub

This project was just synced with the SCF hub. New knowledge available:

{taught_section}

## ğŸ¯ Your Turn: Look for Learnings to Signal Back!

Now that you've received learnings from the ecosystem, take a moment to consider what **this project** might contribute back. The best learnings come from real work - things you've discovered, patterns you've established, or optimizations you've made.

### Areas to Check (especially those similar to what you just learned)

{'**IDE/Editor Configurations** (high value - you just received IDE configs!)' if hub_learnings_info.get('ide') else '**IDE/Editor Configurations**'}
- [ ] `.vscode/settings.json` - Any project-specific settings worth sharing?
- [ ] `.vscode/tasks.json` - Useful task configurations?
- [ ] `.vscode/launch.json` - Debug configurations that work well?
- [ ] Editor-specific files (`.editorconfig`, prettier configs, etc.)

**Build & Development Patterns**
- [ ] Build optimizations that improved performance
- [ ] Development workflow shortcuts
- [ ] Testing configurations that caught real bugs
- [ ] CI/CD patterns that work well

**Code Patterns & Decisions**
- [ ] Architectural decisions with clear rationale
- [ ] Error handling patterns that proved robust
- [ ] Performance optimizations with measured impact
- [ ] API design patterns worth replicating

**Troubleshooting & Fixes**
- [ ] Bug fixes with non-obvious root causes
- [ ] Environment setup gotchas and solutions
- [ ] Dependency conflicts and resolutions

### Quality Filter (Signal if...)

âœ… **DO signal** if the learning:
- Has clear rationale (not just "we did X")
- Would benefit other projects in this ecosystem
- Solves a real problem you encountered
- Has measurable or observable impact
- Is specific enough to be actionable

âŒ **DON'T signal** if it's:
- Project-specific with no broader applicability
- Common knowledge in the language/framework
- Incomplete or experimental
- Just boilerplate or scaffolding

### How to Signal

Add to `.scf/spoke-signals.jsonl`:

```json
{{"type": "pattern", "topic": "Your discovery", "impact": 8, "rationale": "Why this matters...", "context": "When to apply", "date": "{now[:10]}"}}
```

Impact scale: 1-10 (7+ = worth propagating to ecosystem)

---

ğŸ’¡ **Remember**: You don't need to find something every session. Quality over quantity!
The best signals are things you'd want to tell yourself if you were starting a similar project.
'''

    def main_menu(self) -> str:
        """Display main hub menu"""
        self.clear_screen()
        profile = self.load_profile()
        registry = self.load_registry()
        projects = registry.get('projects', [])
        scf_count = sum(1 for p in projects if p.get('scf_enabled'))

        user_name = profile.get('user', {}).get('name', 'Developer')

        # Count learnings
        learnings_dir = self.hub_path / 'learnings'
        learning_count = len(list(learnings_dir.glob('*.json'))) if learnings_dir.exists() else 0

        # Count recent errors (last 24h)
        recent_errors = self._get_recent_error_count()

        # Build dynamic header line with proper padding
        info_line = f"ğŸ‘¤ {user_name}  ğŸ“ {len(projects)} projects ({scf_count} SCF)"
        # Box inner width is 62 chars (64 - 2 for borders)
        padding = 62 - len(info_line) - 2  # -2 for leading spaces
        header_content = f"  {info_line}{' ' * padding}"

        # Error indicator line if recent errors
        error_line = ""
        if recent_errors > 0:
            error_info = f"âš ï¸  {recent_errors} issue(s) detected - review with LLM for fixes"
            error_padding = 62 - len(error_info) - 2
            error_line = f"\nâ•‘  {error_info}{' ' * error_padding}â•‘"

        print(f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    ğŸ“Š SCF Hub Manager                        â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘{header_content}â•‘{error_line}
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

   1. ğŸ“ Projects        - View and manage projects
   2. ğŸ“‚ Groups          - Organize projects into groups
   3. ğŸ” Scan            - Discover new projects
   4. ğŸ§  Learn           - Gather learnings from projects
   5. ğŸ“š Teach           - Push learnings to projects
   6. ğŸ“– Knowledge Base  - Browse learnings ({learning_count} files)
   7. ğŸ“Š Statistics      - View detailed stats
   8. âš™ï¸ Settings        - Hub configuration

   q. Quit
""")
        choice = self.get_choice(8, allow_back=False)

        if choice == '1':
            self.projects_menu()
        elif choice == '2':
            self.groups_menu()
        elif choice == '3':
            self.scan_menu()
        elif choice == '4':
            self.learn_menu()
        elif choice == '5':
            self.teach_menu()
        elif choice == '6':
            self.knowledge_base_menu()
        elif choice == '7':
            self.stats_menu()
        elif choice == '8':
            self.settings_menu()

        return choice

    def projects_menu(self):
        """Projects management menu"""
        while True:
            self.clear_screen()
            registry = self.load_registry()
            projects = registry.get('projects', [])

            # Quick refresh of SCF status for each project
            status_changed = False
            for proj in projects:
                proj_path = Path(proj.get('path', '')).expanduser()
                if proj_path.exists():
                    current_scf = ((proj_path / '.scf').exists() or
                                   (proj_path / 'buildstate.json').exists() or
                                   (proj_path / 'BUILDSTATE.json').exists())
                    if proj.get('scf_enabled') != current_scf:
                        proj['scf_enabled'] = current_scf
                        status_changed = True

            if status_changed:
                self.save_registry(registry)

            title = f"ğŸ“ Projects ({len(projects)})"
            title_padding = (62 - len(title)) // 2
            title_line = f"{' ' * title_padding}{title}{' ' * (62 - title_padding - len(title))}"
            print(f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘{title_line}â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
""")
            if not projects:
                print("   No projects registered yet.\n")
                print("   1. â• Add a project")
                print("   2. ğŸ” Scan for projects")
                print("\n   b. Back to main menu")

                choice = self.get_choice(2)
                if choice == '1':
                    self.add_project()
                elif choice == '2':
                    self.scan_menu()
                elif choice in ('b', 'q'):
                    return
            else:
                # Organize projects by group
                groups = registry.get('groups', {})
                grouped = {}
                ungrouped = []

                for proj in projects:
                    grp = proj.get('group')
                    if grp:
                        if grp not in grouped:
                            grouped[grp] = []
                        grouped[grp].append(proj)
                    else:
                        ungrouped.append(proj)

                # Display grouped projects first
                idx = 1
                project_index_map = {}  # Map display number to project

                for group_name in sorted(grouped.keys()):
                    group_info = groups.get(group_name, {})
                    desc = f" - {group_info.get('description', '')}" if group_info.get('description') else ""
                    print(f"   ğŸ“‚ {group_name}{desc}")

                    for proj in grouped[group_name]:
                        status = "ğŸŒŸ" if proj.get('scf_enabled') else "ğŸ“"
                        size_info = f" ({proj['file_count']} files)" if proj.get('file_count') else ""
                        print(f"   {idx:2}. {status} {proj['name']}{size_info}")
                        project_index_map[idx] = proj
                        idx += 1
                    print()  # Space between groups

                # Display ungrouped projects
                if ungrouped:
                    if grouped:
                        print(f"   ğŸ“ Ungrouped")
                    for proj in ungrouped:
                        status = "ğŸŒŸ" if proj.get('scf_enabled') else "ğŸ“"
                        size_info = f" ({proj['file_count']} files)" if proj.get('file_count') else ""
                        print(f"   {idx:2}. {status} {proj['name']}{size_info}")
                        project_index_map[idx] = proj
                        idx += 1

                print(f"""
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   a. â• Add projects (scan a folder)
   r. ğŸ”„ Rescan project(s)
   d. ğŸ—‘ï¸  Delete a project
   v. ğŸ‘ï¸  View project details
   l. ğŸ“‹ List verbose (detailed view)

   b. Back to main menu
""")
                choice = input("   Enter choice (number or letter): ").strip().lower()

                if choice == 'b':
                    return
                elif choice == 'q':
                    return
                elif choice == 'a':
                    self.add_project()
                elif choice == 'r':
                    self.rescan_projects(projects)
                elif choice == 'd':
                    self.remove_project(projects)
                elif choice == 'v':
                    self.view_project_select(projects)
                elif choice == 'l':
                    self.list_projects_verbose(projects)
                elif choice.isdigit():
                    num = int(choice)
                    if num in project_index_map:
                        self.view_project(project_index_map[num])

    def list_projects_verbose(self, projects: list):
        """Show detailed view of all projects"""
        self.clear_screen()
        title = f"ğŸ“‹ Projects - Detailed View ({len(projects)})"
        title_padding = (62 - len(title)) // 2
        title_line = f"{' ' * title_padding}{title}{' ' * (62 - title_padding - len(title))}"
        print(f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘{title_line}â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
""")
        # Summary stats
        scf_count = sum(1 for p in projects if p.get('scf_enabled'))
        total_files = sum(p.get('file_count', 0) for p in projects)
        total_size = sum(p.get('size_bytes', 0) for p in projects)

        print(f"   Summary: {scf_count} SCF-enabled, {len(projects) - scf_count} regular")
        print(f"   Total: {total_files:,} files, {self._format_size(total_size)}")
        print(f"   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n")

        for i, proj in enumerate(projects, 1):
            status = "ğŸŒŸ" if proj.get('scf_enabled') else "ğŸ“"
            group = f"[{proj.get('group')}] " if proj.get('group') else ""

            print(f"   {i:2}. {status} {group}{proj['name']}")
            print(f"       Path: {proj.get('path', 'unknown')}")

            # Size and files
            files = proj.get('file_count', 0)
            size = proj.get('size_bytes', 0)
            if files or size:
                print(f"       Size: {self._format_size(size)} ({files:,} files)")

            # Languages and frameworks
            langs = proj.get('languages', [])
            frameworks = proj.get('frameworks', [])
            if langs:
                tech = ', '.join(langs[:3])
                if frameworks:
                    tech += f" + {', '.join(frameworks[:2])}"
                print(f"       Tech: {tech}")

            # Dates
            created = proj.get('created_at', '')[:10] if proj.get('created_at') else None
            scanned = proj.get('last_scanned', '')[:10] if proj.get('last_scanned') else None
            added = proj.get('added_at', '')[:10] if proj.get('added_at') else None

            dates = []
            if created:
                dates.append(f"Started: {created}")
            if added:
                dates.append(f"Added: {added}")
            if scanned:
                dates.append(f"Scanned: {scanned}")
            if dates:
                print(f"       Dates: {' | '.join(dates)}")

            # Features
            features = []
            if proj.get('has_tests'):
                features.append("tests")
            if proj.get('has_ci'):
                features.append("CI/CD")
            if proj.get('scf_enabled'):
                features.append("SCF")
            if features:
                print(f"       Features: {', '.join(features)}")

            # Git info
            git = proj.get('git')
            if git and git.get('has_repo'):
                git_line = f"       Git: {git.get('branch', '?')}"
                if git.get('commit_hash_short'):
                    git_line += f" @ {git['commit_hash_short']}"
                if git.get('has_remote'):
                    if git.get('is_pushed'):
                        git_line += " âœ… pushed"
                    elif git.get('unpushed_count'):
                        git_line += f" â¬†ï¸ {git['unpushed_count']} unpushed"
                    else:
                        git_line += " â¬†ï¸ unpushed"
                else:
                    git_line += " (no remote)"
                if git.get('has_uncommitted'):
                    git_line += " ğŸ“ uncommitted"
                print(git_line)

                if git.get('remote_url'):
                    # Clean up remote URL for display
                    remote = git['remote_url']
                    if remote.startswith('git@github.com:'):
                        remote = remote.replace('git@github.com:', 'github.com/')
                    if remote.endswith('.git'):
                        remote = remote[:-4]
                    print(f"       Repo: {remote}")

            # Description
            if proj.get('description'):
                desc = proj['description'][:60] + "..." if len(proj.get('description', '')) > 60 else proj['description']
                print(f"       Desc: {desc}")

            print()  # Blank line between projects

        self.wait_for_enter()

    def groups_menu(self):
        """Groups management menu"""
        while True:
            self.clear_screen()
            registry = self.load_registry()
            groups = registry.get('groups', {})
            projects = registry.get('projects', [])

            print(f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    ğŸ“‚ Project Groups                         â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
""")
            if not groups:
                print("   No groups created yet.\n")
            else:
                for name, info in sorted(groups.items()):
                    member_count = sum(1 for p in projects if p.get('group') == name)
                    desc = info.get('description', '')
                    print(f"   ğŸ“‚ {name} ({member_count} projects)")
                    if desc:
                        print(f"      â””â”€ {desc}")
                print()

            # Show ungrouped projects
            ungrouped = [p for p in projects if not p.get('group')]
            if ungrouped:
                print(f"   ğŸ“ Ungrouped: {len(ungrouped)} projects\n")

            print("""   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   1. â• Create new group
   2. âœï¸  Assign projects to group
   3. â– Remove projects from group
   4. ğŸ—‘ï¸  Delete a group
   5. ğŸ‘ï¸  View group members

   b. Back to main menu
""")
            choice = self.get_choice(5)

            if choice == 'b':
                return
            elif choice == '1':
                self.create_group()
            elif choice == '2':
                self.assign_to_group()
            elif choice == '3':
                self.remove_from_group()
            elif choice == '4':
                self.delete_group()
            elif choice == '5':
                self.view_group()

    def create_group(self):
        """Create a new group"""
        self.clear_screen()
        print("""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    â• Create Group                            â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
""")
        name = input("   Group name (e.g., work, personal, client-x): ").strip().lower()

        if not name:
            return

        # Sanitize name
        name = name.replace(' ', '-')

        registry = self.load_registry()
        if 'groups' not in registry:
            registry['groups'] = {}

        if name in registry['groups']:
            print(f"\n   âš ï¸  Group '{name}' already exists")
            self.wait_for_enter()
            return

        desc = input("   Description (optional): ").strip()

        registry['groups'][name] = {
            'description': desc,
            'created_at': datetime.now(timezone.utc).isoformat()
        }
        self.save_registry(registry)

        print(f"\n   âœ… Created group: {name}")
        self.wait_for_enter()

    def assign_to_group(self):
        """Assign projects to a group"""
        self.clear_screen()
        registry = self.load_registry()
        groups = registry.get('groups', {})
        projects = registry.get('projects', [])

        if not groups:
            print("\n   âŒ No groups created yet. Create a group first.")
            self.wait_for_enter()
            return

        print("""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    âœï¸  Assign to Group                        â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

   Select a group:
""")
        group_list = sorted(groups.keys())
        for i, name in enumerate(group_list, 1):
            print(f"   {i}. ğŸ“‚ {name}")

        print("\n   c. Cancel\n")
        choice = input("   Selection: ").strip().lower()

        if choice == 'c':
            return

        if not choice.isdigit() or not (1 <= int(choice) <= len(group_list)):
            print("   âŒ Invalid selection")
            self.wait_for_enter()
            return

        target_group = group_list[int(choice) - 1]

        # Show projects not in this group
        self.clear_screen()
        available = [p for p in projects if p.get('group') != target_group]

        if not available:
            print(f"\n   All projects are already in '{target_group}'")
            self.wait_for_enter()
            return

        print(f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘              Assign to: {target_group:<36} â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

   Select projects to add to this group:
""")
        for i, proj in enumerate(available, 1):
            status = "ğŸŒŸ" if proj.get('scf_enabled') else "ğŸ“"
            current = f" [{proj.get('group')}]" if proj.get('group') else ""
            print(f"   {i:2}. {status} {proj['name']}{current}")

        print(f"\n   Selection (1,3,5 or 1-{len(available)}) [all]: ", end="")
        sel = input().strip().lower()

        if sel == 'c':
            return

        selected_indices = self._parse_selection(sel, len(available))
        if not selected_indices:
            print("   âŒ No valid selection")
            self.wait_for_enter()
            return

        # Update projects
        count = 0
        for idx in selected_indices:
            proj_name = available[idx]['name']
            for p in registry['projects']:
                if p['name'] == proj_name:
                    p['group'] = target_group
                    count += 1
                    break

        self.save_registry(registry)
        print(f"\n   âœ… Added {count} projects to '{target_group}'")
        self.wait_for_enter()

    def remove_from_group(self):
        """Remove projects from their group"""
        self.clear_screen()
        registry = self.load_registry()
        projects = registry.get('projects', [])

        # Get projects that have a group
        grouped = [p for p in projects if p.get('group')]

        if not grouped:
            print("\n   No projects are assigned to groups.")
            self.wait_for_enter()
            return

        print("""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    â– Remove from Group                       â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

   Select projects to ungroup:
""")
        for i, proj in enumerate(grouped, 1):
            status = "ğŸŒŸ" if proj.get('scf_enabled') else "ğŸ“"
            print(f"   {i:2}. {status} {proj['name']} [{proj.get('group')}]")

        print(f"\n   Selection (1,3,5 or 1-{len(grouped)}) [all]: ", end="")
        sel = input().strip().lower()

        if sel == 'c':
            return

        selected_indices = self._parse_selection(sel, len(grouped))
        if not selected_indices:
            print("   âŒ No valid selection")
            self.wait_for_enter()
            return

        # Update projects
        count = 0
        for idx in selected_indices:
            proj_name = grouped[idx]['name']
            for p in registry['projects']:
                if p['name'] == proj_name:
                    p.pop('group', None)
                    count += 1
                    break

        self.save_registry(registry)
        print(f"\n   âœ… Removed {count} projects from their groups")
        self.wait_for_enter()

    def delete_group(self):
        """Delete a group"""
        self.clear_screen()
        registry = self.load_registry()
        groups = registry.get('groups', {})

        if not groups:
            print("\n   No groups to delete.")
            self.wait_for_enter()
            return

        print("""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    ğŸ—‘ï¸  Delete Group                           â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

   Select a group to delete:
""")
        group_list = sorted(groups.keys())
        projects = registry.get('projects', [])

        for i, name in enumerate(group_list, 1):
            member_count = sum(1 for p in projects if p.get('group') == name)
            print(f"   {i}. ğŸ“‚ {name} ({member_count} projects)")

        print("\n   c. Cancel\n")
        choice = input("   Selection: ").strip().lower()

        if choice == 'c':
            return

        if not choice.isdigit() or not (1 <= int(choice) <= len(group_list)):
            print("   âŒ Invalid selection")
            self.wait_for_enter()
            return

        target_group = group_list[int(choice) - 1]
        member_count = sum(1 for p in projects if p.get('group') == target_group)

        print(f"\n   âš ï¸  Delete group '{target_group}'?")
        if member_count > 0:
            print(f"   ({member_count} projects will be ungrouped)")

        confirm = input("\n   Confirm? [y/N]: ").strip().lower()

        if confirm == 'y':
            # Remove group from projects
            for p in registry['projects']:
                if p.get('group') == target_group:
                    p.pop('group', None)

            # Delete group
            del registry['groups'][target_group]
            self.save_registry(registry)
            print(f"\n   âœ… Deleted group: {target_group}")
        else:
            print("\n   Cancelled.")

        self.wait_for_enter()

    def view_group(self):
        """View members of a group"""
        self.clear_screen()
        registry = self.load_registry()
        groups = registry.get('groups', {})

        if not groups:
            print("\n   No groups created yet.")
            self.wait_for_enter()
            return

        print("""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    ğŸ‘ï¸  View Group                             â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

   Select a group:
""")
        group_list = sorted(groups.keys())
        projects = registry.get('projects', [])

        for i, name in enumerate(group_list, 1):
            member_count = sum(1 for p in projects if p.get('group') == name)
            print(f"   {i}. ğŸ“‚ {name} ({member_count} projects)")

        print("\n   c. Cancel\n")
        choice = input("   Selection: ").strip().lower()

        if choice == 'c':
            return

        if not choice.isdigit() or not (1 <= int(choice) <= len(group_list)):
            print("   âŒ Invalid selection")
            self.wait_for_enter()
            return

        target_group = group_list[int(choice) - 1]
        members = [p for p in projects if p.get('group') == target_group]

        self.clear_screen()
        print(f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘              ğŸ“‚ {target_group:<44} â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
""")
        if groups[target_group].get('description'):
            print(f"   {groups[target_group]['description']}\n")

        if not members:
            print("   No projects in this group.\n")
        else:
            print(f"   {len(members)} projects:\n")
            for proj in members:
                status = "ğŸŒŸ" if proj.get('scf_enabled') else "ğŸ“"
                print(f"   {status} {proj['name']}")
                print(f"      {proj['path']}")

        self.wait_for_enter()

    def add_project(self):
        """Add projects by scanning a directory"""
        self.clear_screen()

        # Find common project directories
        common_paths = []
        for p in [Path.home() / 'projects', Path.home() / 'code', Path.home() / 'work',
                  Path.home() / 'dev', Path.home() / 'src', Path.home() / 'repos']:
            if p.exists() and p.is_dir():
                common_paths.append(p)

        print("""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    â• Add Projects                            â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
""")
        if common_paths:
            print("   Found project directories:\n")
            for i, p in enumerate(common_paths, 1):
                # Count projects in each
                try:
                    count = sum(1 for item in p.iterdir() if item.is_dir() and not item.name.startswith('.'))
                except:
                    count = 0
                print(f"   {i}. {p}  ({count} folders)")
            print(f"\n   p. Enter a custom path")
            print(f"   c. Cancel\n")

            choice = input("   Selection: ").strip()

            if choice.lower() == 'c':
                return
            elif choice.lower() == 'p':
                # Prompt for custom path
                path_input = input("\n   Enter path (or 'c' to cancel): ").strip()
                if path_input.lower() == 'c':
                    return
                scan_path = Path(path_input.replace('\\', '/')).expanduser().resolve()
            elif choice.isdigit() and 1 <= int(choice) <= len(common_paths):
                scan_path = common_paths[int(choice) - 1]
            else:
                # Check if user entered a path directly (starts with / or ~ or contains /)
                if choice.startswith('/') or choice.startswith('~') or '/' in choice or '\\' in choice:
                    scan_path = Path(choice.replace('\\', '/')).expanduser().resolve()
                else:
                    print(f"\n   âŒ Invalid selection - please enter 1-{len(common_paths)}, 'p' for path, or 'c' to cancel")
                    self.wait_for_enter()
                    return
        else:
            print("   Enter a directory to scan for projects.")
            print("   Examples: ~/projects, ~/code, ~/work")
            print("\n   c. Cancel\n")
            path_input = input("   Scan path: ").strip()

            if path_input.lower() == 'c':
                return

            # Convert Windows backslashes to forward slashes
            scan_path = Path(path_input.replace('\\', '/')).expanduser().resolve()

        if not scan_path.exists() or not scan_path.is_dir():
            print(f"\n   âŒ Directory not found: {scan_path}")
            self.wait_for_enter()
            return

        # Check if the path itself is a project (not a parent folder of projects)
        is_project = self._is_project_dir(scan_path)

        if is_project:
            # User entered a specific project path - add it directly
            discovered = [self._get_project_info(scan_path)]
        else:
            # Scan for projects inside this directory
            print(f"\n   ğŸ” Scanning {scan_path}...")
            discovered = self._quick_scan(scan_path)

        if not discovered:
            print("\n   No projects found in this directory.")
            self.wait_for_enter()
            return

        # Filter out already registered
        registry = self.load_registry()
        existing = {p['path'] for p in registry.get('projects', [])}
        new_projects = [p for p in discovered if p['path'] not in existing]

        if not new_projects:
            print("\n   All projects in this directory are already registered.")
            self.wait_for_enter()
            return

        # Show found projects
        self.clear_screen()
        title = f"ğŸ“‚ Found {len(new_projects)} Projects in {scan_path.name}/"
        title_padding = (62 - len(title)) // 2
        title_line = f"{' ' * title_padding}{title}{' ' * (62 - title_padding - len(title))}"
        print(f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘{title_line}â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
""")
        for i, proj in enumerate(new_projects, 1):
            status = "ğŸŒŸ" if proj.get('scf_enabled') else "ğŸ“"
            # Show relative path from scan_path or full path
            proj_path = Path(proj['path'])
            try:
                rel_path = proj_path.relative_to(scan_path.parent)
            except ValueError:
                rel_path = proj_path
            print(f"   {i:2}. {status} {proj['name']}")
            print(f"       {rel_path}")
            if proj.get('description'):
                print(f"       â””â”€ {proj['description'][:50]}")

        print(f"\n   Selection (1,3,5 or 1-{len(new_projects)} or 'a' for all) [all]")
        print("   c. Cancel\n")
        choice = input("   > ").strip().lower()

        # Parse selection (empty = all)
        indices = self._parse_selection(choice, len(new_projects))
        if indices is None:  # Explicit cancel
            return
        if not indices:
            print("\n   âŒ No valid selection - please enter numbers from the list above")
            self.wait_for_enter()
            return

        selected = [new_projects[i] for i in indices]

        # Add selected projects with full profile
        added_count = 0
        for proj in selected:
            proj_path = Path(proj['path'])

            # Build comprehensive profile
            proj_info = self._build_project_profile(proj_path)
            proj_info['added_at'] = datetime.now(timezone.utc).isoformat()
            proj_info['last_sync'] = None

            # Update spoke's hub_path if SCF-enabled
            if proj_info.get('scf_enabled'):
                for bs_path in [proj_path / '.scf' / 'BUILDSTATE.json',
                               proj_path / '.scf' / 'buildstate.json',
                               proj_path / 'BUILDSTATE.json',
                               proj_path / 'buildstate.json']:
                    if bs_path.exists():
                        try:
                            with open(bs_path) as f:
                                data = json.load(f)
                            if '_scf_metadata' in data:
                                data['_scf_metadata']['hub_path'] = str(self.hub_path)
                                with open(bs_path, 'w') as f:
                                    json.dump(data, f, indent=2)
                            break
                        except:
                            pass

            registry['projects'].append(proj_info)
            added_count += 1

            # Show what was detected
            print(f"   âœ… {proj_info['name']}")
            if proj_info.get('languages'):
                print(f"      Languages: {', '.join(proj_info['languages'][:3])}")
            if proj_info.get('frameworks'):
                print(f"      Frameworks: {', '.join(proj_info['frameworks'][:3])}")

        self.save_registry(registry)
        print(f"\n   âœ… Added {added_count} project(s)")

        # Offer to add more
        print("\n   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
        another = input("   Add another project? [y/N]: ").strip().lower()
        if another == 'y':
            self.add_project()  # Recursive call to add more

    def _is_project_dir(self, path: Path) -> bool:
        """Check if a directory is itself a project (has .git, package.json, etc.)"""
        indicators = [
            path / '.git',
            path / '.scf',
            path / 'buildstate.json',
            path / 'BUILDSTATE.json',
            path / 'package.json',
            path / 'pyproject.toml',
            path / 'setup.py',
            path / 'Cargo.toml',
            path / 'go.mod',
            path / 'pom.xml',
            path / 'Makefile',
        ]
        return any(ind.exists() for ind in indicators)

    def _get_project_info(self, item: Path) -> dict:
        """Get project info for a single project directory"""
        is_scf = ((item / '.scf').exists() or
                  (item / 'buildstate.json').exists() or
                  (item / 'BUILDSTATE.json').exists())

        proj_info = {
            'name': item.name,
            'path': str(item.resolve()),
            'scf_enabled': is_scf,
            'description': None,
            'project_type': None
        }

        # Read SCF details if available
        if is_scf:
            # Check both uppercase and lowercase variants (Linux is case-sensitive)
            for bs_path in [item / '.scf' / 'BUILDSTATE.json',
                           item / '.scf' / 'buildstate.json',
                           item / 'BUILDSTATE.json',
                           item / 'buildstate.json']:
                if bs_path.exists():
                    try:
                        with open(bs_path) as f:
                            data = json.load(f)
                        if '_project_foundation' in data:
                            foundation = data['_project_foundation']
                            if foundation.get('identity'):
                                proj_info['description'] = foundation['identity'].get('one_liner')
                                proj_info['project_type'] = foundation['identity'].get('type')
                        elif 'project' in data:
                            proj_info['description'] = data['project'].get('description')
                            proj_info['project_type'] = data['project'].get('type')
                        break
                    except:
                        pass

        return proj_info

    def _quick_scan(self, scan_path: Path) -> list:
        """Quick scan a directory for projects"""
        discovered = []

        try:
            for item in scan_path.iterdir():
                if not item.is_dir() or item.name.startswith('.'):
                    continue

                if self._is_project_dir(item):
                    discovered.append(self._get_project_info(item))
        except PermissionError:
            pass

        return sorted(discovered, key=lambda x: (not x['scf_enabled'], x['name'].lower()))

    def _consolidate_scf_files(self, proj_path: Path) -> dict:
        """Consolidate and normalize legacy SCF files to canonical locations.

        Returns dict with consolidation results:
        - migrated: list of files migrated
        - merged: list of data merged
        - cleaned: list of legacy files removed
        - errors: list of any errors encountered
        - corrupt_lines_cleaned: count of invalid JSON lines removed
        """
        result = {
            'migrated': [],
            'merged': [],
            'cleaned': [],
            'errors': [],
            'corrupt_lines_cleaned': 0
        }

        scf_dir = proj_path / '.scf'
        scf_dir.mkdir(exist_ok=True)

        canonical_buildstate = scf_dir / 'BUILDSTATE.json'
        canonical_signals = scf_dir / 'spoke-signals.jsonl'

        # Define legacy locations to check
        legacy_buildstates = [
            proj_path / 'buildstate.json',
            proj_path / 'BUILDSTATE.json',
            scf_dir / 'buildstate.json',  # lowercase in .scf
        ]

        legacy_signals = [
            proj_path / 'spoke-signals.jsonl',
        ]

        # ========== Consolidate BUILDSTATE ==========
        merged_buildstate = None

        # First, load canonical if it exists
        if canonical_buildstate.exists():
            try:
                content = canonical_buildstate.read_text().strip()
                if content:
                    data = json.loads(content)
                    if isinstance(data, dict):
                        merged_buildstate = data
                    else:
                        result['errors'].append(f"Invalid canonical BUILDSTATE: expected dict, got {type(data).__name__}")
            except Exception as e:
                result['errors'].append(f"Error reading canonical BUILDSTATE: {e}")

        # Check and merge legacy buildstates
        for legacy_path in legacy_buildstates:
            if legacy_path.exists() and legacy_path != canonical_buildstate:
                try:
                    content = legacy_path.read_text().strip()
                    if not content:
                        # Empty file - just remove it
                        legacy_path.unlink()
                        result['cleaned'].append(str(legacy_path.relative_to(proj_path)))
                        continue

                    legacy_data = json.loads(content)

                    # Validate it's a dict, not a string or other type
                    if not isinstance(legacy_data, dict):
                        result['errors'].append(f"Invalid buildstate in {legacy_path.name}: expected dict, got {type(legacy_data).__name__}")
                        continue

                    if merged_buildstate is None:
                        # First buildstate found - use as base
                        merged_buildstate = legacy_data
                        result['migrated'].append(str(legacy_path.relative_to(proj_path)))
                    else:
                        # Merge into existing
                        merged_buildstate = self._merge_buildstate(merged_buildstate, legacy_data)
                        result['merged'].append(str(legacy_path.relative_to(proj_path)))

                    # Remove legacy file
                    legacy_path.unlink()
                    result['cleaned'].append(str(legacy_path.relative_to(proj_path)))

                except json.JSONDecodeError as e:
                    result['errors'].append(f"Invalid JSON in {legacy_path.name}: {e}")
                except Exception as e:
                    result['errors'].append(f"Error processing {legacy_path.name}: {e}")

        # Write consolidated buildstate
        if merged_buildstate is not None:
            # Update metadata
            if '_scf_metadata' not in merged_buildstate:
                merged_buildstate['_scf_metadata'] = {}

            merged_buildstate['_scf_metadata']['version'] = '2.2.0'
            merged_buildstate['_scf_metadata']['structure_version'] = 'v2'
            merged_buildstate['_scf_metadata']['last_consolidated'] = datetime.now(timezone.utc).isoformat()
            merged_buildstate['_scf_metadata']['hub_path'] = str(self.hub_path)

            try:
                with open(canonical_buildstate, 'w') as f:
                    json.dump(merged_buildstate, f, indent=2)
            except Exception as e:
                result['errors'].append(f"Error writing consolidated BUILDSTATE: {e}")

        # ========== Consolidate spoke-signals.jsonl ==========
        all_signals = []
        canonical_corrupt_count = 0
        canonical_had_corrupt = False

        # Load canonical signals first
        if canonical_signals.exists():
            try:
                with open(canonical_signals) as f:
                    for line in f:
                        line = line.strip()
                        if line:
                            try:
                                all_signals.append(json.loads(line))
                            except json.JSONDecodeError:
                                canonical_corrupt_count += 1
                                canonical_had_corrupt = True
                if canonical_corrupt_count > 0:
                    result['corrupt_lines_cleaned'] += canonical_corrupt_count
            except Exception as e:
                result['errors'].append(f"Error reading canonical signals: {e}")

        # Check and merge legacy signals
        legacy_had_signals = False
        for legacy_path in legacy_signals:
            if legacy_path.exists() and legacy_path != canonical_signals:
                try:
                    legacy_signals_data = []
                    legacy_corrupt = 0
                    with open(legacy_path) as f:
                        for line in f:
                            line = line.strip()
                            if line:
                                try:
                                    legacy_signals_data.append(json.loads(line))
                                except json.JSONDecodeError:
                                    legacy_corrupt += 1

                    if legacy_corrupt > 0:
                        result['corrupt_lines_cleaned'] += legacy_corrupt

                    if legacy_signals_data:
                        # Merge signals (avoid duplicates by timestamp)
                        existing_timestamps = {s.get('timestamp') for s in all_signals}
                        new_signals = [s for s in legacy_signals_data
                                      if s.get('timestamp') not in existing_timestamps]
                        all_signals.extend(new_signals)
                        legacy_had_signals = True

                        if new_signals:
                            result['merged'].append(f"{legacy_path.name} ({len(new_signals)} signals)")

                    # Remove legacy file
                    legacy_path.unlink()
                    result['cleaned'].append(str(legacy_path.relative_to(proj_path)))

                except Exception as e:
                    result['errors'].append(f"Error processing {legacy_path.name}: {e}")

        # Write consolidated signals if we have any AND (had corrupt lines to clean OR merged legacy files)
        needs_rewrite = canonical_had_corrupt or legacy_had_signals
        if all_signals and needs_rewrite:
            try:
                with open(canonical_signals, 'w') as f:
                    for signal in all_signals:
                        f.write(json.dumps(signal) + '\n')
            except Exception as e:
                result['errors'].append(f"Error writing consolidated signals: {e}")
        elif canonical_had_corrupt and not all_signals:
            # Had corrupt file with no valid signals - remove it
            try:
                canonical_signals.unlink()
                result['cleaned'].append('spoke-signals.jsonl (all corrupt)')
            except Exception as e:
                result['errors'].append(f"Error removing corrupt signals file: {e}")

        return result

    def _merge_buildstate(self, base: dict, incoming: dict) -> dict:
        """Merge two buildstate dicts, preferring newer/more complete data."""
        merged = base.copy()

        # Helper to normalize decisions (can be list or dict with impact levels)
        def normalize_decisions(decisions):
            if isinstance(decisions, list):
                return [d for d in decisions if isinstance(d, dict)]
            elif isinstance(decisions, dict):
                # Format: {"high_impact": [...], "medium_impact": [...], ...}
                all_decisions = []
                for impact_level in ['high_impact', 'medium_impact', 'low_impact']:
                    items = decisions.get(impact_level, [])
                    if isinstance(items, list):
                        all_decisions.extend([d for d in items if isinstance(d, dict)])
                return all_decisions
            return []

        # Merge decisions (avoid duplicates by decision text or title)
        base_decisions = normalize_decisions(merged.get('decisions', []))
        incoming_decisions = normalize_decisions(incoming.get('decisions', []))

        existing_decision_ids = set()
        for d in base_decisions:
            existing_decision_ids.add(d.get('decision', d.get('title', '')))

        for decision in incoming_decisions:
            decision_id = decision.get('decision', decision.get('title', ''))
            if decision_id and decision_id not in existing_decision_ids:
                base_decisions.append(decision)
                existing_decision_ids.add(decision_id)
        merged['decisions'] = base_decisions

        # Merge features (avoid duplicates by name)
        base_features = merged.get('features', [])
        incoming_features = incoming.get('features', [])

        # Ensure features are lists of dicts
        if not isinstance(base_features, list):
            base_features = []
        if not isinstance(incoming_features, list):
            incoming_features = []

        existing_feature_names = {f.get('name', '') for f in base_features if isinstance(f, dict)}
        for feature in incoming_features:
            if isinstance(feature, dict) and feature.get('name', '') not in existing_feature_names:
                base_features.append(feature)
        merged['features'] = base_features

        # Merge next_steps (avoid duplicates)
        base_next = set(merged.get('next_steps', []))
        incoming_next = set(incoming.get('next_steps', []))
        merged['next_steps'] = list(base_next | incoming_next)

        # Prefer newer metadata
        if '_scf_metadata' in incoming:
            if '_scf_metadata' not in merged:
                merged['_scf_metadata'] = incoming['_scf_metadata']
            else:
                # Merge metadata, prefer incoming for most fields
                for key in incoming['_scf_metadata']:
                    if key not in merged['_scf_metadata']:
                        merged['_scf_metadata'][key] = incoming['_scf_metadata'][key]

        # Preserve project foundation if present in either
        if '_project_foundation' in incoming and '_project_foundation' not in merged:
            merged['_project_foundation'] = incoming['_project_foundation']

        # Preserve project info
        if 'project' in incoming and 'project' not in merged:
            merged['project'] = incoming['project']

        # Preserve stack info
        if 'stack' in incoming and 'stack' not in merged:
            merged['stack'] = incoming['stack']

        return merged

    def _log_errors(self, operation: str, errors: list):
        """Log errors to hub's error log file"""
        try:
            log_dir = self.hub_path / 'logs'
            log_dir.mkdir(exist_ok=True)
            log_file = log_dir / 'errors.jsonl'

            with open(log_file, 'a') as f:
                entry = {
                    'timestamp': datetime.now(timezone.utc).isoformat(),
                    'operation': operation,
                    'errors': errors
                }
                f.write(json.dumps(entry) + '\n')
        except Exception:
            pass  # Don't fail on logging failure

    def _format_size(self, size_bytes: int) -> str:
        """Format bytes to human readable string"""
        if size_bytes < 0:
            sign = "-"
            size_bytes = abs(size_bytes)
        else:
            sign = ""

        for unit in ['B', 'KB', 'MB', 'GB']:
            if abs(size_bytes) < 1024:
                return f"{sign}{size_bytes:.1f}{unit}"
            size_bytes /= 1024
        return f"{sign}{size_bytes:.1f}TB"

    def _parse_selection(self, selection: str, max_val: int, default_all: bool = True) -> list:
        """Parse selection like '1,3,5' or '1-5' or '1,3-5' or 'a' for all

        Args:
            selection: User input string
            max_val: Maximum valid selection number
            default_all: If True, empty input returns all indices
        """
        selection = selection.strip().lower()

        # Handle cancel
        if selection in ('c', 'cancel'):
            return None  # Explicit cancel signal

        # Handle empty input - default to all if enabled
        if not selection:
            if default_all:
                return list(range(max_val))
            return []

        # Handle 'a' or 'all' for all
        if selection in ('a', 'all'):
            return list(range(max_val))

        indices = set()
        parts = selection.replace(' ', '').split(',')

        for part in parts:
            if not part:
                continue
            if '-' in part:
                try:
                    start, end = part.split('-', 1)
                    for i in range(int(start), int(end) + 1):
                        if 1 <= i <= max_val:
                            indices.add(i - 1)
                except ValueError:
                    continue
            elif part.isdigit():
                i = int(part)
                if 1 <= i <= max_val:
                    indices.add(i - 1)

        return sorted(indices)

    def _display_projects_by_group(self, projects: list, registry: dict = None, show_numbers: bool = True) -> dict:
        """Display projects organized by group. Returns map of number -> project.

        Args:
            projects: List of project dicts
            registry: Optional registry containing group info
            show_numbers: Whether to show numbered selections

        Returns:
            Dict mapping display number (1-indexed) to project dict
        """
        if registry is None:
            registry = self.load_registry()

        groups = registry.get('groups', {})
        grouped = {}
        ungrouped = []

        for proj in projects:
            grp = proj.get('group')
            if grp:
                if grp not in grouped:
                    grouped[grp] = []
                grouped[grp].append(proj)
            else:
                ungrouped.append(proj)

        idx = 1
        project_map = {}

        # Display grouped projects first
        for group_name in sorted(grouped.keys()):
            group_info = groups.get(group_name, {})
            desc = f" - {group_info.get('description', '')}" if group_info.get('description') else ""
            print(f"   ğŸ“‚ {group_name}{desc}")

            for proj in grouped[group_name]:
                status = "ğŸŒŸ" if proj.get('scf_enabled') else "ğŸ“"
                size_info = f" ({proj['file_count']} files)" if proj.get('file_count') else ""

                # Git status indicator
                git_indicator = ""
                git = proj.get('git')
                if git and git.get('has_repo'):
                    if git.get('has_uncommitted'):
                        git_indicator = " ğŸ“"
                    elif git.get('has_remote') and not git.get('is_pushed'):
                        git_indicator = " â¬†ï¸"

                if show_numbers:
                    print(f"   {idx:2}. {status} {proj['name']}{size_info}{git_indicator}")
                else:
                    print(f"       {status} {proj['name']}{size_info}{git_indicator}")
                project_map[idx] = proj
                idx += 1
            print()  # Space between groups

        # Display ungrouped projects
        if ungrouped:
            if grouped:
                print(f"   ğŸ“ Ungrouped")
            for proj in ungrouped:
                status = "ğŸŒŸ" if proj.get('scf_enabled') else "ğŸ“"
                size_info = f" ({proj['file_count']} files)" if proj.get('file_count') else ""

                # Git status indicator
                git_indicator = ""
                git = proj.get('git')
                if git and git.get('has_repo'):
                    if git.get('has_uncommitted'):
                        git_indicator = " ğŸ“"
                    elif git.get('has_remote') and not git.get('is_pushed'):
                        git_indicator = " â¬†ï¸"

                if show_numbers:
                    print(f"   {idx:2}. {status} {proj['name']}{size_info}{git_indicator}")
                else:
                    print(f"       {status} {proj['name']}{size_info}{git_indicator}")
                project_map[idx] = proj
                idx += 1

        return project_map

    def remove_project(self, projects: list):
        """Remove a project interactively"""
        self.clear_screen()
        registry = self.load_registry()

        print("""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    ğŸ—‘ï¸  Delete Project                         â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

   Select a project to remove from hub:
""")
        # Display projects by group
        project_map = self._display_projects_by_group(projects, registry)

        print("\n   c. Cancel\n")
        choice = input("   Selection: ").strip().lower()

        if choice == 'c':
            return

        if not choice.isdigit() or int(choice) not in project_map:
            print("   âŒ Invalid selection - please enter a number from the list above")
            self.wait_for_enter()
            return

        proj = project_map[int(choice)]
        print(f"\n   âš ï¸  This removes '{proj['name']}' from hub tracking.")
        print(f"   (Project files on disk are NOT deleted)")
        print("\n   [y] Yes, remove  [n/Enter] Cancel")
        confirm = input("\n   Confirm: ").strip().lower()

        if confirm == 'y':
            registry['projects'] = [p for p in registry['projects'] if p['name'] != proj['name']]
            self.save_registry(registry)
            print(f"\n   âœ… Removed: {proj['name']}")
        else:
            print("\n   Cancelled.")

        self.wait_for_enter()

    def rescan_projects(self, projects: list):
        """Rescan project(s) to rebuild their profiles"""
        self.clear_screen()
        registry = self.load_registry()

        print("""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    ğŸ”„ Rescan Projects                        â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

   Select project(s) to rescan and rebuild profile:
""")
        # Display projects by group
        project_map = self._display_projects_by_group(projects, registry)

        print(f"\n   Selection (1,3,5 or 1-{len(projects)} or 'a' for all) [all]")
        print("   c. Cancel\n")
        choice = input("   > ").strip().lower()

        indices = self._parse_selection(choice, len(projects))
        if indices is None:  # Explicit cancel
            return
        if not indices:
            print("   âŒ No valid selection - please enter numbers from the list above")
            self.wait_for_enter()
            return

        # Map indices to actual projects using project_map
        selected = [project_map[i + 1] for i in indices if (i + 1) in project_map]
        if not selected:
            print("   âŒ No valid projects selected")
            self.wait_for_enter()
            return
        print(f"\n   ğŸ”„ Rescanning {len(selected)} project(s)...\n")

        registry = self.load_registry()
        updated_count = 0

        for proj in selected:
            proj_path = Path(proj.get('path', '')).expanduser()
            print(f"   ğŸ“‚ {proj['name']}...", end=" ")

            if not proj_path.exists():
                print("âŒ Path not found")
                continue

            try:
                # Build fresh profile
                profile = self._build_project_profile(proj_path)

                # Preserve existing fields that shouldn't be overwritten
                profile['group'] = proj.get('group')
                profile['added_at'] = proj.get('added_at')
                profile['last_sync'] = proj.get('last_sync')

                # Track changes
                changes = []
                old_scf = proj.get('scf_enabled', False)
                new_scf = profile.get('scf_enabled', False)
                if old_scf != new_scf:
                    changes.append(f"SCF: {'ğŸ“â†’ğŸŒŸ' if new_scf else 'ğŸŒŸâ†’ğŸ“'}")

                old_size = proj.get('size_bytes', 0)
                new_size = profile.get('size_bytes', 0)
                if old_size and new_size and abs(new_size - old_size) > 1024:
                    diff = new_size - old_size
                    changes.append(f"Size: {'+' if diff > 0 else ''}{self._format_size(diff)}")

                old_files = proj.get('file_count', 0)
                new_files = profile.get('file_count', 0)
                if old_files and new_files and old_files != new_files:
                    diff = new_files - old_files
                    changes.append(f"Files: {'+' if diff > 0 else ''}{diff}")

                # Update in registry
                for i, p in enumerate(registry['projects']):
                    if p.get('path') == proj.get('path') or p.get('name') == proj.get('name'):
                        registry['projects'][i] = profile
                        break

                updated_count += 1
                print("âœ…")

                # Show what was detected
                print(f"       ğŸ“Š {profile.get('file_count', 0)} files, {self._format_size(profile.get('size_bytes', 0))}")
                if profile.get('created_at'):
                    created = profile['created_at'][:10]  # Just date part
                    print(f"       ğŸ“… Started: {created}")
                if profile.get('languages'):
                    print(f"       ğŸ’» {', '.join(profile['languages'][:3])}", end="")
                    if profile.get('frameworks'):
                        print(f" + {', '.join(profile['frameworks'][:2])}")
                    else:
                        print()
                if changes:
                    print(f"       ğŸ”„ Changed: {', '.join(changes)}")

            except Exception as e:
                print(f"âŒ {e}")

        self.save_registry(registry)
        print(f"\n   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
        print(f"   âœ… Updated {updated_count} project profile(s)")
        self.wait_for_enter()

    def _get_git_info(self, proj_path: Path) -> dict:
        """Extract git repository information from a project"""
        git_info = {
            'has_repo': True,
            'remote_url': None,
            'branch': None,
            'commit_hash': None,
            'commit_hash_short': None,
            'commit_date': None,
            'commit_message': None,
            'has_remote': False,
            'is_pushed': None,  # None if no remote, True/False if has remote
            'unpushed_count': 0,
            'has_uncommitted': False
        }

        try:
            # Get remote URL
            result = subprocess.run(
                ['git', 'remote', 'get-url', 'origin'],
                cwd=proj_path, capture_output=True, text=True, timeout=5
            )
            if result.returncode == 0:
                git_info['remote_url'] = result.stdout.strip()
                git_info['has_remote'] = True

            # Get current branch
            result = subprocess.run(
                ['git', 'branch', '--show-current'],
                cwd=proj_path, capture_output=True, text=True, timeout=5
            )
            if result.returncode == 0:
                git_info['branch'] = result.stdout.strip()

            # Get latest commit info
            result = subprocess.run(
                ['git', 'log', '-1', '--format=%H|%h|%ci|%s'],
                cwd=proj_path, capture_output=True, text=True, timeout=5
            )
            if result.returncode == 0 and result.stdout.strip():
                parts = result.stdout.strip().split('|', 3)
                if len(parts) >= 4:
                    git_info['commit_hash'] = parts[0]
                    git_info['commit_hash_short'] = parts[1]
                    git_info['commit_date'] = parts[2]
                    git_info['commit_message'] = parts[3][:60]  # Truncate

            # Check for uncommitted changes
            result = subprocess.run(
                ['git', 'status', '--porcelain'],
                cwd=proj_path, capture_output=True, text=True, timeout=5
            )
            if result.returncode == 0:
                git_info['has_uncommitted'] = len(result.stdout.strip()) > 0

            # Check if pushed (only if has remote)
            if git_info['has_remote'] and git_info['branch']:
                result = subprocess.run(
                    ['git', 'rev-list', '--count', f'origin/{git_info["branch"]}..HEAD'],
                    cwd=proj_path, capture_output=True, text=True, timeout=5
                )
                if result.returncode == 0:
                    unpushed = int(result.stdout.strip())
                    git_info['unpushed_count'] = unpushed
                    git_info['is_pushed'] = unpushed == 0
                else:
                    # Remote branch might not exist
                    git_info['is_pushed'] = False

        except Exception:
            pass

        return git_info

    def _build_project_profile(self, proj_path: Path) -> dict:
        """Build a comprehensive project profile by scanning the folder"""
        profile = {
            'name': proj_path.name,
            'path': str(proj_path.resolve()),
            'scf_enabled': False,
            'description': None,
            'project_type': None,
            'languages': [],
            'frameworks': [],
            'has_tests': False,
            'has_ci': False,
            'size_bytes': 0,
            'file_count': 0,
            'created_at': None,
            'last_scanned': datetime.now(timezone.utc).isoformat(),
            # Git tracking
            'git': None  # Will be populated if git repo exists
        }

        # Get folder creation time (earliest file/folder mtime as proxy)
        try:
            # Use .git creation or folder stat
            git_dir = proj_path / '.git'
            if git_dir.exists():
                profile['created_at'] = datetime.fromtimestamp(
                    git_dir.stat().st_mtime, tz=timezone.utc
                ).isoformat()

                # Extract git info
                profile['git'] = self._get_git_info(proj_path)
            else:
                profile['created_at'] = datetime.fromtimestamp(
                    proj_path.stat().st_ctime, tz=timezone.utc
                ).isoformat()
        except:
            pass

        # Calculate size and file count (excluding .git, node_modules, etc.)
        try:
            total_size = 0
            file_count = 0
            skip_dirs = {'.git', 'node_modules', '__pycache__', '.venv', 'venv',
                        'dist', 'build', '.next', 'target', '.cache'}

            for item in proj_path.rglob('*'):
                # Skip large dependency/build directories
                if any(skip in item.parts for skip in skip_dirs):
                    continue
                if item.is_file():
                    try:
                        total_size += item.stat().st_size
                        file_count += 1
                    except:
                        pass

            profile['size_bytes'] = total_size
            profile['file_count'] = file_count
        except:
            pass

        # Check SCF status
        profile['scf_enabled'] = ((proj_path / '.scf').exists() or
                                   (proj_path / 'buildstate.json').exists() or
                                   (proj_path / 'BUILDSTATE.json').exists())

        # Read SCF details if available
        if profile['scf_enabled']:
            for bs_path in [proj_path / '.scf' / 'BUILDSTATE.json',
                           proj_path / '.scf' / 'buildstate.json',
                           proj_path / 'BUILDSTATE.json',
                           proj_path / 'buildstate.json']:
                if bs_path.exists():
                    try:
                        data = json.loads(bs_path.read_text())
                        if '_project_foundation' in data:
                            foundation = data['_project_foundation']
                            if foundation.get('identity'):
                                profile['description'] = foundation['identity'].get('one_liner')
                                profile['project_type'] = foundation['identity'].get('type')
                        elif 'project' in data:
                            profile['description'] = data['project'].get('description')
                            profile['project_type'] = data['project'].get('type')
                        break
                    except:
                        pass

        # Detect languages and frameworks
        languages = set()
        frameworks = set()

        # JavaScript/TypeScript
        if (proj_path / 'package.json').exists():
            languages.add('JavaScript')
            try:
                pkg = json.loads((proj_path / 'package.json').read_text())
                deps = {**pkg.get('dependencies', {}), **pkg.get('devDependencies', {})}

                if 'typescript' in deps or (proj_path / 'tsconfig.json').exists():
                    languages.add('TypeScript')
                if 'react' in deps or '@types/react' in deps:
                    frameworks.add('React')
                if 'next' in deps:
                    frameworks.add('Next.js')
                if 'vue' in deps:
                    frameworks.add('Vue')
                if 'express' in deps:
                    frameworks.add('Express')
                if 'nest' in deps or '@nestjs/core' in deps:
                    frameworks.add('NestJS')

                # Get description from package.json if not from SCF
                if not profile['description'] and pkg.get('description'):
                    profile['description'] = pkg['description']
            except:
                pass

        # Python
        if (proj_path / 'pyproject.toml').exists() or (proj_path / 'setup.py').exists() or (proj_path / 'requirements.txt').exists():
            languages.add('Python')
            # Check for frameworks
            for req_file in ['requirements.txt', 'pyproject.toml', 'setup.py']:
                req_path = proj_path / req_file
                if req_path.exists():
                    try:
                        content = req_path.read_text().lower()
                        if 'django' in content:
                            frameworks.add('Django')
                        if 'flask' in content:
                            frameworks.add('Flask')
                        if 'fastapi' in content:
                            frameworks.add('FastAPI')
                        if 'pytorch' in content or 'torch' in content:
                            frameworks.add('PyTorch')
                        if 'tensorflow' in content:
                            frameworks.add('TensorFlow')
                    except:
                        pass

        # Rust
        if (proj_path / 'Cargo.toml').exists():
            languages.add('Rust')

        # Go
        if (proj_path / 'go.mod').exists():
            languages.add('Go')

        # Java
        if (proj_path / 'pom.xml').exists() or (proj_path / 'build.gradle').exists():
            languages.add('Java')
            if (proj_path / 'pom.xml').exists():
                frameworks.add('Maven')
            if (proj_path / 'build.gradle').exists():
                frameworks.add('Gradle')

        # Check for tests
        test_indicators = ['test', 'tests', 'spec', 'specs', '__tests__', 'test.py', 'test.js', 'test.ts']
        for indicator in test_indicators:
            if (proj_path / indicator).exists():
                profile['has_tests'] = True
                break

        # Check for CI
        ci_indicators = ['.github/workflows', '.gitlab-ci.yml', 'Jenkinsfile', '.circleci', '.travis.yml']
        for indicator in ci_indicators:
            if (proj_path / indicator).exists():
                profile['has_ci'] = True
                break

        profile['languages'] = sorted(list(languages))
        profile['frameworks'] = sorted(list(frameworks))

        return profile

    def view_project_select(self, projects: list):
        """Select a project to view"""
        # The project_map from projects_menu contains correct mapping
        print("\n   Enter project number to view (or 'c' to cancel): ", end="")
        choice = input().strip().lower()

        if choice == 'c':
            return

        if not choice.isdigit():
            print("   âŒ Invalid selection - please enter a number")
            self.wait_for_enter()
            return

        num = int(choice)
        if num < 1 or num > len(projects):
            print("   âŒ Invalid selection - number out of range")
            self.wait_for_enter()
            return

        self.view_project(projects[num - 1])

    def view_project(self, proj: dict):
        """View detailed project info"""
        self.clear_screen()
        status = "ğŸŒŸ SCF-enabled" if proj.get('scf_enabled') else "ğŸ“ Regular"

        print(f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  ğŸ“¦ {proj['name']:<52} â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

   Status:     {status}
   Path:       {proj['path']}
   Type:       {proj.get('type', 'unknown')}
   Added:      {proj.get('added_at', 'unknown').split('T')[0]}
   Last sync:  {proj.get('last_sync', 'never') if proj.get('last_sync') else 'never'}
""")
        # If SCF-enabled, read more details
        if proj.get('scf_enabled'):
            proj_path = Path(proj['path'])
            for bs_path in [proj_path / '.scf' / 'BUILDSTATE.json', proj_path / 'buildstate.json']:
                if bs_path.exists():
                    try:
                        with open(bs_path) as f:
                            data = json.load(f)

                        if '_project_foundation' in data:
                            foundation = data['_project_foundation']
                            if foundation.get('identity'):
                                print(f"   Foundation: {foundation['identity'].get('one_liner', 'No description')}")

                        if 'features' in data and data['features']:
                            print(f"\n   âœ¨ Features ({len(data['features'])}):")
                            for feat in data['features'][:5]:
                                print(f"      â€¢ {feat.get('name', 'unnamed')}")

                        if 'decisions' in data and data['decisions']:
                            print(f"\n   ğŸ“ Recent Decisions ({len(data['decisions'])}):")
                            for dec in data['decisions'][:3]:
                                print(f"      â€¢ {dec.get('decision', 'unnamed')[:50]}")

                        break
                    except:
                        pass

        print("""
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   1. ğŸ§  Learn from this project
   2. ğŸ“š Teach this project
   3. ğŸ”„ Sync this project
   4. ğŸ“‚ Open in terminal

   b. Back
""")
        choice = self.get_choice(4)

        if choice == '1':
            self.learn_from_project(proj)
        elif choice == '2':
            self.teach_project(proj)
        elif choice == '3':
            self.sync_project(proj)
        elif choice == '4':
            import os
            os.system(f'cd "{proj["path"]}" && $SHELL')

    def learn_from_project(self, proj: dict):
        """Learn from a specific project"""
        print(f"\n   ğŸ§  Learning from {proj['name']}...")

        proj_path = Path(proj['path'])
        signals_path = proj_path / '.scf' / 'spoke-signals.jsonl'

        if not signals_path.exists():
            signals_path = proj_path / 'spoke-signals.jsonl'

        if signals_path.exists():
            with open(signals_path) as f:
                signals = []
                for line in f:
                    if line.strip():
                        try:
                            signals.append(json.loads(line))
                        except json.JSONDecodeError:
                            pass  # Skip corrupt lines
                high_impact = [s for s in signals if isinstance(s, dict) and s.get('offers')]
                print(f"   Found {len(high_impact)} high-impact learnings")
        else:
            print("   No signals found in this project")

        self.wait_for_enter()

    def teach_project(self, proj: dict):
        """Teach a specific project"""
        print(f"\n   ğŸ“š Teaching {proj['name']}...")

        proj_path = Path(proj['path'])
        kb_sync_path = proj_path / '.scf' / 'kb-sync.json'

        if kb_sync_path.exists():
            try:
                with open(kb_sync_path) as f:
                    kb_sync = json.load(f)
                kb_sync['last_sync_date'] = datetime.now(timezone.utc).isoformat()
                kb_sync['hub_kb_version'] = datetime.now(timezone.utc).isoformat()
                with open(kb_sync_path, 'w') as f:
                    json.dump(kb_sync, f, indent=2)
                print("   âœ… Updated knowledge sync")
            except:
                print("   âŒ Failed to update")
        else:
            print("   âš ï¸  No kb-sync.json found")

        # Update registry
        registry = self.load_registry()
        for p in registry['projects']:
            if p['name'] == proj['name']:
                p['last_sync'] = datetime.now(timezone.utc).isoformat()
        self.save_registry(registry)

        self.wait_for_enter()

    def sync_project(self, proj: dict):
        """Sync a project"""
        print(f"\n   ğŸ”„ Syncing {proj['name']}...")
        self.learn_from_project(proj)
        self.teach_project(proj)

    def scan_menu(self):
        """Scan for new projects"""
        self.clear_screen()
        print("""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    ğŸ” Scan for Projects                      â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
""")
        registry_dir = self.hub_path / '.scf-registry'
        self.hub_manager._discover_existing_projects(self.hub_path, registry_dir)
        self.wait_for_enter()

    def learn_menu(self):
        """Learn from all projects - extract and persist high-impact learnings to hub"""
        self.clear_screen()
        print("""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    ğŸ§  Learn from Projects                    â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
""")
        registry = self.load_registry()
        projects = [p for p in registry.get('projects', []) if p.get('scf_enabled')]

        if not projects:
            print("   No SCF-enabled projects to learn from.")
            self.wait_for_enter()
            return

        print(f"   Found {len(projects)} SCF-enabled projects\n")

        # Load learned signals registry (tracks what we've already seen by hash)
        learned_registry = self._load_learned_signals()
        learned_hashes = learned_registry.get('signals', {})

        # Ensure learnings directory exists
        learnings_dir = self.hub_path / 'learnings'
        learnings_dir.mkdir(exist_ok=True)

        # Track results per project
        learning_details = []
        errors = []
        total_corrupt_cleaned = 0

        # Categorization counters
        type_counts = {'decisions': 0, 'signals': 0, 'patterns': 0, 'ide_configs': 0}

        for proj in projects:
            proj_path = Path(proj['path']).expanduser()
            spoke_id = proj['name']
            proj_slug = spoke_id.lower().replace(' ', '-').replace('_', '-')

            proj_detail = {
                'name': spoke_id,
                'slug': proj_slug,
                'new_learnings': [],
                'known_count': 0,
                'actions': [],
                'contributed': False,
                'potential_signals': []  # Decisions that could be signaled
            }

            print(f"   ğŸ“– Reading from {spoke_id}...", end=" ")

            if not proj_path.exists():
                print("âŒ Path not found")
                proj_detail['actions'].append('path not found')
                learning_details.append(proj_detail)
                continue

            try:
                # First, consolidate any legacy/corrupt SCF files
                consolidation = self._consolidate_scf_files(proj_path)
                if consolidation['errors']:
                    errors.extend([f"{spoke_id}: {e}" for e in consolidation['errors']])
                if consolidation['corrupt_lines_cleaned'] > 0:
                    total_corrupt_cleaned += consolidation['corrupt_lines_cleaned']

                # Load existing hub learnings for this project
                hub_learning_path = learnings_dir / f"{proj_slug}.json"
                existing_learnings = {'project': spoke_id, 'learnings': [], 'last_updated': None}
                if hub_learning_path.exists():
                    try:
                        data = json.loads(hub_learning_path.read_text())
                        # Handle both old format (list) and new format (dict)
                        if isinstance(data, list):
                            existing_learnings = {'project': spoke_id, 'learnings': data, 'last_updated': None}
                        elif isinstance(data, dict):
                            existing_learnings = data
                            if 'learnings' not in existing_learnings:
                                existing_learnings['learnings'] = []
                    except:
                        pass

                existing_hashes = {self._get_learning_hash(l) for l in existing_learnings.get('learnings', []) if isinstance(l, dict)}
                spoke_learned_hashes = learned_hashes.get(spoke_id, {})

                # ========== Read signals ==========
                signals_path = proj_path / '.scf' / 'spoke-signals.jsonl'
                if not signals_path.exists():
                    signals_path = proj_path / 'spoke-signals.jsonl'

                if signals_path.exists():
                    with open(signals_path) as f:
                        for line_num, line in enumerate(f, 1):
                            line = line.strip()
                            if not line:
                                continue
                            try:
                                signal = json.loads(line)
                                if not isinstance(signal, dict):
                                    continue

                                for offer in signal.get('offers', []):
                                    if not isinstance(offer, dict):
                                        continue
                                    impact = offer.get('impact', 0)
                                    if impact < 8:
                                        continue

                                    # Build learning entry
                                    learning = {
                                        'type': offer.get('type', 'signal'),
                                        'topic': offer.get('topic', offer.get('description', 'Unknown')),
                                        'impact': impact,
                                        'context': offer.get('context', ''),
                                        'source': 'spoke-signals.jsonl',
                                        'timestamp': signal.get('timestamp', datetime.now(timezone.utc).isoformat()),
                                        'by': signal.get('by', 'unknown')
                                    }

                                    learning_hash = self._get_learning_hash(learning)

                                    if learning_hash in existing_hashes or learning_hash in spoke_learned_hashes:
                                        proj_detail['known_count'] += 1
                                    else:
                                        proj_detail['new_learnings'].append(learning)
                                        existing_hashes.add(learning_hash)
                                        # Track by type
                                        ltype = learning['type'].lower()
                                        if 'ide' in ltype or 'config' in ltype:
                                            type_counts['ide_configs'] += 1
                                        elif 'pattern' in ltype:
                                            type_counts['patterns'] += 1
                                        else:
                                            type_counts['signals'] += 1

                            except json.JSONDecodeError as e:
                                errors.append(f"{spoke_id}/spoke-signals.jsonl line {line_num}: {e}")

                # ========== Read BUILDSTATE decisions ==========
                buildstate_data = None
                for bs_name in ['BUILDSTATE.json', 'buildstate.json']:
                    for bs_path in [proj_path / '.scf' / bs_name, proj_path / bs_name]:
                        if bs_path.exists():
                            try:
                                content = bs_path.read_text().strip()
                                if content:
                                    data = json.loads(content)
                                    if isinstance(data, dict):
                                        buildstate_data = data
                                        break
                            except json.JSONDecodeError as e:
                                errors.append(f"{spoke_id}/{bs_name}: {e}")
                    if buildstate_data:
                        break

                if buildstate_data:
                    decisions = buildstate_data.get('decisions', [])
                    # Handle both list and dict formats
                    if isinstance(decisions, dict):
                        all_decisions = []
                        for level in ['high_impact', 'medium_impact', 'low_impact']:
                            all_decisions.extend(decisions.get(level, []))
                        decisions = all_decisions

                    for decision in decisions:
                        if not isinstance(decision, dict):
                            continue
                        impact = decision.get('impact', 0)

                        # Track potential signals (impact 7+) for suggestions
                        if 7 <= impact < 8:
                            proj_detail['potential_signals'].append({
                                'topic': decision.get('decision', decision.get('title', 'Unknown')),
                                'impact': impact
                            })

                        if impact < 8:
                            continue

                        learning = {
                            'type': 'decision',
                            'topic': decision.get('decision', decision.get('title', 'Unknown')),
                            'impact': impact,
                            'rationale': decision.get('rationale', ''),
                            'context': decision.get('context', ''),
                            'source': 'BUILDSTATE.json',
                            'date': decision.get('date', datetime.now().date().isoformat()),
                            'by': decision.get('by', 'unknown')
                        }

                        learning_hash = self._get_learning_hash(learning)

                        if learning_hash in existing_hashes or learning_hash in spoke_learned_hashes:
                            proj_detail['known_count'] += 1
                        else:
                            proj_detail['new_learnings'].append(learning)
                            existing_hashes.add(learning_hash)
                            type_counts['decisions'] += 1

                # ========== Persist new learnings to hub ==========
                if proj_detail['new_learnings']:
                    # Add new learnings to existing
                    existing_learnings['learnings'].extend(proj_detail['new_learnings'])
                    existing_learnings['last_updated'] = datetime.now(timezone.utc).isoformat()
                    existing_learnings['project'] = spoke_id

                    # Write to hub
                    with open(hub_learning_path, 'w') as f:
                        json.dump(existing_learnings, f, indent=2)

                    # Mark as learned in registry
                    if spoke_id not in learned_hashes:
                        learned_hashes[spoke_id] = {}
                    for learning in proj_detail['new_learnings']:
                        lhash = self._get_learning_hash(learning)
                        learned_hashes[spoke_id][lhash] = datetime.now(timezone.utc).isoformat()

                    proj_detail['contributed'] = True
                    proj_detail['actions'].append(f"persisted {len(proj_detail['new_learnings'])} to hub")

                # Build status message
                new_count = len(proj_detail['new_learnings'])
                known_count = proj_detail['known_count']

                if new_count > 0:
                    print(f"âœ… {new_count} new" + (f", {known_count} known" if known_count else ""))
                elif known_count > 0:
                    print(f"â„¹ï¸ {known_count} already learned")
                    proj_detail['actions'].append('already learned')
                elif proj_detail['potential_signals']:
                    print(f"ğŸ’¡ {len(proj_detail['potential_signals'])} potential (impact 7)")
                    proj_detail['actions'].append('has potential signals')
                else:
                    print("â„¹ï¸ No high-impact items")
                    proj_detail['actions'].append('no high-impact')

                learning_details.append(proj_detail)

            except Exception as e:
                print(f"âŒ Error")
                errors.append(f"{spoke_id}: {type(e).__name__}: {e}")
                proj_detail['actions'].append('error')
                learning_details.append(proj_detail)

        # Save learned signals registry
        new_total = sum(len(d['new_learnings']) for d in learning_details)
        if new_total > 0:
            learned_registry['signals'] = learned_hashes
            learned_registry['last_updated'] = datetime.now(timezone.utc).isoformat()
            self._save_learned_signals(learned_registry)

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # DETAILED SUMMARY
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        print(f"\n   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
        print(f"   ğŸ“Š LEARNING SUMMARY")
        print(f"   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")

        # Per-project breakdown
        print(f"\n   By Project: (ğŸŸ¢ new learnings | ğŸŸ¡ already known | ğŸ’¡ potential | âšª none)")
        contributors = 0
        consumers = 0
        dormant = 0

        for detail in learning_details:
            new_count = len(detail['new_learnings'])
            known_count = detail['known_count']

            if new_count > 0:
                icon = 'ğŸŸ¢'
                contributors += 1
                actions = f"persisted {new_count}"
                if known_count:
                    actions += f", {known_count} known"
            elif known_count > 0:
                icon = 'ğŸŸ¡'
                consumers += 1
                actions = f"{known_count} already learned"
            elif detail['potential_signals']:
                icon = 'ğŸ’¡'
                dormant += 1
                actions = f"{len(detail['potential_signals'])} potential signals"
            else:
                icon = 'âšª'
                dormant += 1
                actions = 'no high-impact items'

            print(f"      {icon} {detail['name']}: {actions}")

        # Overall stats
        known_total = sum(d['known_count'] for d in learning_details)
        print(f"\n   Overall: {new_total} new, {known_total} already known")

        # Learnings by type
        if any(type_counts.values()):
            print(f"\n   By Type:")
            if type_counts['decisions']:
                print(f"      ğŸ—ï¸  Decisions: {type_counts['decisions']}")
            if type_counts['signals']:
                print(f"      ğŸ“¡ Signals: {type_counts['signals']}")
            if type_counts['patterns']:
                print(f"      ğŸ“ Patterns: {type_counts['patterns']}")
            if type_counts['ide_configs']:
                print(f"      ğŸ”§ IDE Configs: {type_counts['ide_configs']}")

        # Contribution health
        print(f"\n   Ecosystem Health:")
        print(f"      ğŸ“¤ Contributors: {contributors} (actively sharing)")
        print(f"      ğŸ“¥ Consumers: {consumers} (have learnings, nothing new)")
        print(f"      ğŸ’¤ Dormant: {dormant} (no high-impact items)")

        # Suggestions for potential signals
        potential_projects = [d for d in learning_details if d['potential_signals']]
        if potential_projects:
            print(f"\n   ğŸ’¡ Potential Signals (impact 7, consider raising to 8):")
            for detail in potential_projects[:3]:
                signals_preview = ', '.join(s['topic'][:30] for s in detail['potential_signals'][:2])
                more = f" +{len(detail['potential_signals'])-2}" if len(detail['potential_signals']) > 2 else ""
                print(f"      â€¢ {detail['name']}: {signals_preview}{more}")

        # Corruption cleanup
        if total_corrupt_cleaned:
            print(f"\n   ğŸ§¹ Cleaned {total_corrupt_cleaned} corrupt line(s)")

        # Errors
        if errors:
            print(f"\n   âš ï¸ {len(errors)} error(s) encountered:")
            for err in errors[:5]:
                print(f"      â€¢ {err[:70]}{'...' if len(err) > 70 else ''}")
            if len(errors) > 5:
                print(f"      ... and {len(errors) - 5} more")
            self._log_errors('learn_menu', errors)

        # Final message
        if new_total > 0:
            print(f"\n   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
            print(f"   âœ… {new_total} learning(s) persisted to hub!")
            print(f"      Run 'Teach' to share with other projects.")

        self.wait_for_enter()

    def _get_learning_hash(self, learning: dict) -> str:
        """Compute a unique hash for a learning based on its content."""
        parts = [
            learning.get('type', ''),
            learning.get('topic', ''),
            str(learning.get('impact', 0)),
        ]
        content = '|'.join(str(p) for p in parts)
        return hashlib.sha256(content.encode()).hexdigest()[:16]

    def teach_menu(self):
        """Teach projects - push hub learnings to spokes safely"""
        self.clear_screen()
        print("""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    ğŸ“š Teach Projects                         â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
""")
        registry = self.load_registry()
        projects = [p for p in registry.get('projects', []) if p.get('scf_enabled')]

        if not projects:
            print("   No SCF-enabled projects to teach.")
            self.wait_for_enter()
            return

        # First, scan each project for existing SCF data
        print("   Scanning projects for existing SCF data...\n")

        project_info = []
        for proj in projects:
            proj_path = Path(proj['path']).expanduser()
            info = {
                'proj': proj,
                'path': proj_path,
                'existing_files': [],
                'decisions_count': 0,
                'signals_count': 0,
                'learnings_to_push': 0
            }

            if not proj_path.exists():
                project_info.append(info)
                continue

            # Find all SCF files (both .scf/ and legacy root files)
            scf_dir = proj_path / '.scf'
            if scf_dir.exists():
                info['existing_files'].extend([f.name for f in scf_dir.glob('*') if f.is_file()])

            # Check for legacy root files
            for legacy in ['buildstate.json', 'BUILDSTATE.json', 'buildstate.md', 'BUILDSTATE.md']:
                if (proj_path / legacy).exists():
                    info['existing_files'].append(f"(root)/{legacy}")

            # Count existing decisions
            for bs_path in [scf_dir / 'BUILDSTATE.json', scf_dir / 'buildstate.json',
                           proj_path / 'BUILDSTATE.json', proj_path / 'buildstate.json']:
                if bs_path.exists():
                    try:
                        data = json.loads(bs_path.read_text())
                        info['decisions_count'] = len(data.get('decisions', []))
                        break
                    except:
                        pass

            # Count signals
            for sig_path in [scf_dir / 'spoke-signals.jsonl', proj_path / 'spoke-signals.jsonl']:
                if sig_path.exists():
                    try:
                        info['signals_count'] = sum(1 for line in open(sig_path) if line.strip())
                    except:
                        pass
                    break

            # Check hub learnings that could be pushed
            learnings_dir = self.hub_path / 'learnings'
            if learnings_dir.exists():
                info['learnings_to_push'] = len(list(learnings_dir.glob('*.json')))

            project_info.append(info)

        # Display what we found - organized by group
        print("   Found existing SCF data:\n")

        # Build info map for group display
        info_map = {info['proj']['name']: info for info in project_info}

        # Organize by groups
        groups = registry.get('groups', {})
        grouped = {}
        ungrouped = []

        for info in project_info:
            proj = info['proj']
            grp = proj.get('group')
            if grp:
                if grp not in grouped:
                    grouped[grp] = []
                grouped[grp].append(info)
            else:
                ungrouped.append(info)

        idx = 1
        info_index_map = {}  # Map display number to info

        for group_name in sorted(grouped.keys()):
            group_desc = groups.get(group_name, {}).get('description', '')
            desc_str = f" - {group_desc}" if group_desc else ""
            print(f"   ğŸ“‚ {group_name}{desc_str}")

            for info in grouped[group_name]:
                proj = info['proj']
                files_count = len(info['existing_files'])
                print(f"   {idx:2}. {proj['name']}")
                if files_count:
                    print(f"       ğŸ“‚ {files_count} SCF files, {info['decisions_count']} decisions, {info['signals_count']} signals")
                else:
                    print(f"       ğŸ“­ No existing SCF files")
                info_index_map[idx] = info
                idx += 1
            print()

        if ungrouped:
            if grouped:
                print(f"   ğŸ“ Ungrouped")
            for info in ungrouped:
                proj = info['proj']
                files_count = len(info['existing_files'])
                print(f"   {idx:2}. {proj['name']}")
                if files_count:
                    print(f"       ğŸ“‚ {files_count} SCF files, {info['decisions_count']} decisions, {info['signals_count']} signals")
                else:
                    print(f"       ğŸ“­ No existing SCF files")
                info_index_map[idx] = info
                idx += 1

        # Hub learnings summary
        learnings_dir = self.hub_path / 'learnings'
        hub_learnings = list(learnings_dir.glob('*.json')) if learnings_dir.exists() else []
        print(f"\n   Hub has {len(hub_learnings)} learning file(s) to share")

        print(f"""
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   What 'Teach' does:
   â€¢ Updates kb-sync.json timestamps
   â€¢ Preserves ALL existing decisions and signals
   â€¢ Does NOT overwrite buildstate files
   â€¢ Merges learnings, never deletes
""")
        print(f"   Selection (1,3,5 or 1-{len(projects)} or 'a' for all) [all]")
        print("   c. Cancel\n")
        selection = input("   > ").strip().lower()

        indices = self._parse_selection(selection, len(projects))
        if indices is None:  # Explicit cancel
            return
        if not indices:
            print("   âŒ No valid selection - please enter numbers from the list above")
            self.wait_for_enter()
            return

        selected_info = [info_index_map[i + 1] for i in indices if (i + 1) in info_index_map]
        if not selected_info:
            print("   âŒ No valid projects selected")
            self.wait_for_enter()
            return

        print(f"\n   Teaching {len(selected_info)} project(s)...\n")

        # Gather hub learnings info for detailed feedback
        learnings_dir = self.hub_path / 'learnings'
        hub_learnings_info = {'total': 0, 'ide': [], 'patterns': [], 'other': []}
        if learnings_dir.exists():
            for lf in learnings_dir.rglob('*.json'):
                hub_learnings_info['total'] += 1
                rel_path = lf.relative_to(learnings_dir)
                if str(rel_path).startswith('ide/'):
                    hub_learnings_info['ide'].append(lf.stem)
                elif str(rel_path).startswith('languages/') or str(rel_path).startswith('workflows/'):
                    hub_learnings_info['patterns'].append(lf.stem)
                else:
                    hub_learnings_info['other'].append(lf.stem)

        taught_count = 0
        consolidated_count = 0
        total_corrupt_cleaned = 0
        total_files_migrated = 0
        total_files_merged = 0
        total_files_cleaned = 0
        all_errors = []
        teaching_details = []  # Collect detailed info for summary

        for info in selected_info:
            proj = info['proj']
            proj_path = info['path']
            proj_details = {'name': proj['name'], 'actions': [], 'impact': 'minimal'}

            if not proj_path.exists():
                print(f"   â”Œâ”€ {proj['name']}")
                print(f"   â”‚  âŒ Path not found")
                print(f"   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
                continue

            print(f"   â”Œâ”€ {proj['name']}")

            try:
                scf_dir = proj_path / '.scf'
                created_scf_dir = not scf_dir.exists()
                scf_dir.mkdir(exist_ok=True)
                if created_scf_dir:
                    print(f"   â”‚  ğŸ“ Created .scf/ directory")
                    proj_details['actions'].append('created .scf/')

                # First, consolidate any legacy SCF files
                consolidation = self._consolidate_scf_files(proj_path)
                if consolidation['errors']:
                    all_errors.extend([f"{proj['name']}: {e}" for e in consolidation['errors']])

                # Report migrations (files moved from root to .scf/)
                if consolidation['migrated']:
                    total_files_migrated += len(consolidation['migrated'])
                    for f in consolidation['migrated']:
                        print(f"   â”‚  ğŸ“¦ Migrated: {f} â†’ .scf/")
                    proj_details['actions'].append(f"migrated {len(consolidation['migrated'])} file(s)")
                    proj_details['impact'] = 'moderate'

                # Report merges (data combined from multiple sources)
                if consolidation['merged']:
                    total_files_merged += len(consolidation['merged'])
                    for f in consolidation['merged']:
                        print(f"   â”‚  ğŸ”€ Merged data from: {f}")
                    proj_details['actions'].append(f"merged {len(consolidation['merged'])} source(s)")
                    proj_details['impact'] = 'moderate'

                # Report cleanups (legacy files removed)
                if consolidation['cleaned']:
                    total_files_cleaned += len(consolidation['cleaned'])
                    cleaned_names = [f.split('/')[-1] for f in consolidation['cleaned']]
                    print(f"   â”‚  ğŸ§¹ Cleaned legacy: {', '.join(set(cleaned_names))}")
                    proj_details['actions'].append(f"cleaned {len(consolidation['cleaned'])} legacy file(s)")

                # Report corrupt lines cleaned
                if consolidation['corrupt_lines_cleaned'] > 0:
                    total_corrupt_cleaned += consolidation['corrupt_lines_cleaned']
                    print(f"   â”‚  ğŸ”§ Fixed {consolidation['corrupt_lines_cleaned']} corrupt signal line(s)")
                    proj_details['actions'].append(f"fixed {consolidation['corrupt_lines_cleaned']} corrupt lines")

                # Update or create kb-sync.json (merge, don't overwrite)
                kb_sync_path = scf_dir / 'kb-sync.json'
                kb_sync = {}
                kb_sync_existed = kb_sync_path.exists()
                if kb_sync_existed:
                    try:
                        kb_sync = json.loads(kb_sync_path.read_text())
                    except:
                        pass

                # Get current hub version
                hub_version = self._get_hub_version()

                # Check if already up to date
                current_version = kb_sync.get('hub_version')
                if current_version == hub_version:
                    if not consolidation['migrated'] and not consolidation['merged'] and not consolidation['cleaned']:
                        print(f"   â”‚  â„¹ï¸  Already up to date with hub")
                        print(f"   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
                        proj_details['actions'].append('already current')
                        teaching_details.append(proj_details)
                        continue

                kb_sync['last_sync_date'] = datetime.now(timezone.utc).isoformat()
                kb_sync['hub_kb_version'] = datetime.now(timezone.utc).isoformat()
                kb_sync['hub_version'] = hub_version  # Track version hash
                kb_sync['hub_path'] = str(self.hub_path)
                kb_sync['framework_path'] = str(self.framework_path)

                with open(kb_sync_path, 'w') as f:
                    json.dump(kb_sync, f, indent=2)

                # Update registry
                proj['last_sync'] = datetime.now(timezone.utc).isoformat()
                taught_count += 1

                # Report what learnings are now available
                if hub_learnings_info['total'] > 0:
                    learning_summary = []
                    if hub_learnings_info['ide']:
                        learning_summary.append(f"{len(hub_learnings_info['ide'])} IDE configs")
                    if hub_learnings_info['patterns']:
                        learning_summary.append(f"{len(hub_learnings_info['patterns'])} patterns")
                    if hub_learnings_info['other']:
                        learning_summary.append(f"{len(hub_learnings_info['other'])} project learnings")
                    print(f"   â”‚  ğŸ“š Hub knowledge: {', '.join(learning_summary)}")
                    proj_details['actions'].append(f"linked to {hub_learnings_info['total']} learnings")
                    proj_details['impact'] = 'significant'

                if not kb_sync_existed:
                    print(f"   â”‚  ğŸ”— Created kb-sync.json (first sync!)")
                    proj_details['actions'].append('first sync')
                    proj_details['impact'] = 'significant'
                else:
                    print(f"   â”‚  âœ… Updated kb-sync.json")
                    proj_details['actions'].append('synced')

                # Write signal opportunity prompt for spoke LLM
                signal_opp_path = scf_dir / 'SIGNAL_OPPORTUNITY.md'
                signal_content = self._generate_signal_opportunity_prompt(
                    proj['name'],
                    hub_learnings_info
                )
                signal_opp_path.write_text(signal_content)
                print(f"   â”‚  ğŸ“ Updated signal opportunity prompt")
                proj_details['actions'].append('signal prompt updated')

                # Assess overall impact
                if consolidation['migrated'] or not kb_sync_existed:
                    proj_details['impact'] = 'significant'
                elif consolidation['merged'] or consolidation['cleaned']:
                    proj_details['impact'] = 'moderate'

                print(f"   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
                consolidated_count += 1 if (consolidation['migrated'] or consolidation['merged']) else 0
                teaching_details.append(proj_details)

            except Exception as e:
                print(f"   â”‚  âŒ Error: {e}")
                print(f"   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
                all_errors.append(f"{proj['name']}: {e}")
                proj_details['actions'].append(f'error: {e}')
                teaching_details.append(proj_details)

        self.save_registry(registry)

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # DETAILED SUMMARY
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        print(f"\n   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
        print(f"   ğŸ“Š TEACHING SUMMARY")
        print(f"   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")

        # Per-project breakdown
        print(f"\n   By Project: (ğŸŸ¢ significant | ğŸŸ¡ moderate | âšª minimal/current)")
        for detail in teaching_details:
            impact_icon = {'significant': 'ğŸŸ¢', 'moderate': 'ğŸŸ¡', 'minimal': 'âšª'}.get(detail['impact'], 'âšª')
            actions_str = ', '.join(detail['actions']) if detail['actions'] else 'no changes'
            print(f"      {impact_icon} {detail['name']}: {actions_str}")

        # Impact breakdown
        significant = sum(1 for d in teaching_details if d['impact'] == 'significant')
        moderate = sum(1 for d in teaching_details if d['impact'] == 'moderate')
        minimal = sum(1 for d in teaching_details if d['impact'] == 'minimal')

        print(f"\n   Overall: {taught_count}/{len(selected_info)} projects taught")
        if significant or moderate or minimal:
            parts = []
            if significant:
                parts.append(f"{significant} significant")
            if moderate:
                parts.append(f"{moderate} moderate")
            if minimal:
                parts.append(f"{minimal} minimal")
            print(f"   Impact: {', '.join(parts)}")

        # File operations summary
        if total_files_migrated or total_files_merged or total_files_cleaned or total_corrupt_cleaned:
            print(f"\n   File Operations Total:")
            if total_files_migrated:
                print(f"      ğŸ“¦ Files migrated to .scf/:  {total_files_migrated}")
            if total_files_merged:
                print(f"      ğŸ”€ Data sources merged:      {total_files_merged}")
            if total_files_cleaned:
                print(f"      ğŸ§¹ Legacy files cleaned:     {total_files_cleaned}")
            if total_corrupt_cleaned:
                print(f"      ğŸ”§ Corrupt lines fixed:      {total_corrupt_cleaned}")

        # Hub knowledge summary
        if hub_learnings_info['total'] > 0:
            print(f"\n   Hub Knowledge Now Available:")
            if hub_learnings_info['ide']:
                print(f"      ğŸ”§ IDE Configs: {', '.join(hub_learnings_info['ide'][:3])}" +
                      (f" (+{len(hub_learnings_info['ide'])-3} more)" if len(hub_learnings_info['ide']) > 3 else ""))
            if hub_learnings_info['patterns']:
                print(f"      ğŸ“ Patterns: {', '.join(hub_learnings_info['patterns'][:3])}" +
                      (f" (+{len(hub_learnings_info['patterns'])-3} more)" if len(hub_learnings_info['patterns']) > 3 else ""))
            if hub_learnings_info['other']:
                print(f"      ğŸ“š Project Learnings: {len(hub_learnings_info['other'])} file(s)")

        # Errors
        if all_errors:
            print(f"\n   âš ï¸  {len(all_errors)} error(s) occurred - check Settings > Error Log")
            self._log_errors('teach_menu', all_errors)

        # Benefit statement
        if taught_count > 0:
            print(f"\n   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
            if significant > 0:
                print(f"   ğŸ’¡ {significant} project(s) now have access to ecosystem learnings!")
                print(f"      LLMs working in these projects can apply hub patterns.")
            elif moderate > 0:
                print(f"   âœ¨ {moderate} project(s) cleaned up and synchronized.")
        else:
            print(f"\n   â„¹ï¸  All projects already up to date with hub version {hub_version[:8]}...")

        self.wait_for_enter()

    def stats_menu(self):
        """Show detailed statistics with actionable recommendations"""
        while True:
            self.clear_screen()
            registry = self.load_registry()
            projects = registry.get('projects', [])
            scf_enabled = [p for p in projects if p.get('scf_enabled')]
            regular = [p for p in projects if not p.get('scf_enabled')]
            never_synced = [p for p in scf_enabled if not p.get('last_sync')]

            learnings_dir = self.hub_path / 'learnings'
            learning_count = len(list(learnings_dir.glob('*.json'))) if learnings_dir.exists() else 0

            # Check for outdated projects (synced before latest hub learning was added)
            outdated_projects = []
            if learnings_dir.exists() and learning_count > 0:
                # Get most recent learning file modification time
                latest_learning_time = None
                for lf in learnings_dir.glob('*.json'):
                    try:
                        mtime = lf.stat().st_mtime
                        if latest_learning_time is None or mtime > latest_learning_time:
                            latest_learning_time = mtime
                    except:
                        pass

                if latest_learning_time:
                    for p in scf_enabled:
                        last_sync = p.get('last_sync')
                        if last_sync:
                            try:
                                sync_time = datetime.fromisoformat(last_sync.replace('Z', '+00:00')).timestamp()
                                if sync_time < latest_learning_time:
                                    outdated_projects.append(p)
                            except:
                                pass

            # Check for projects with unpushed git changes
            unpushed_projects = []
            uncommitted_projects = []
            for p in projects:
                git = p.get('git')
                if git and git.get('has_repo'):
                    if git.get('has_uncommitted'):
                        uncommitted_projects.append(p)
                    elif git.get('has_remote') and not git.get('is_pushed'):
                        unpushed_projects.append(p)

            # Build actionable recommendations
            actions = []
            if regular:
                actions.append(('enable', f"Enable SCF on {len(regular)} project(s)", regular))
            if never_synced:
                actions.append(('sync', f"Sync {len(never_synced)} project(s) that never synced", never_synced))
            if outdated_projects:
                actions.append(('teach', f"Teach {len(outdated_projects)} project(s) with new hub learnings", outdated_projects))
            if len(projects) == 0:
                actions.append(('scan', "Scan for projects to add", None))
            if learning_count == 0 and scf_enabled:
                actions.append(('learn', "Learn patterns from SCF-enabled projects", scf_enabled))

            # Get hub git info
            hub_git = self._get_git_info(self.hub_path) if (self.hub_path / '.git').exists() else None

            print(f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    ğŸ“Š Hub Statistics                         â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

   ğŸ“ Projects
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   Total registered:    {len(projects)}
   SCF-enabled:         {len(scf_enabled)}
   Regular:             {len(regular)}
   Never synced:        {len(never_synced)}
   Outdated:            {len(outdated_projects)}

   ğŸ§  Learnings
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   Patterns stored:     {learning_count}

   ğŸ“Š Git Status
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   Uncommitted changes: {len(uncommitted_projects)}
   Unpushed commits:    {len(unpushed_projects)}
""")

            if actions:
                print("   ğŸ’¡ Recommended Actions")
                print("   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
                for i, (_, desc, _) in enumerate(actions, 1):
                    print(f"   {i}. {desc}")
                print()

            if not actions:
                print("   âœ… Everything looks good!")
                print()

            print("   b. Back")

            choice = self.get_choice(len(actions))

            if choice == 'b':
                return

            try:
                idx = int(choice) - 1
                if 0 <= idx < len(actions):
                    action_type, desc, items = actions[idx]
                    self._execute_recommendation(action_type, items)
            except ValueError:
                pass

    def _execute_recommendation(self, action_type: str, items):
        """Execute a recommendation action"""
        if action_type == 'enable':
            self._enable_scf_batch(items)
        elif action_type == 'sync':
            self._sync_projects_batch(items)
        elif action_type == 'scan':
            self.add_project()  # Reuse add project flow which scans
        elif action_type == 'learn':
            self._learn_from_projects(items)
        elif action_type == 'teach':
            self._teach_outdated_projects(items)

    def _teach_outdated_projects(self, projects: list):
        """Teach outdated projects - push hub learnings to them"""
        self.clear_screen()
        registry = self.load_registry()

        print("\n   ğŸ“š Teach Outdated Projects")
        print("   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
        print("   These projects synced before new learnings were added.\n")

        # Display projects by group
        project_map = self._display_projects_by_group(projects, registry)

        print(f"\n   Selection (1,3,5 or 1-{len(projects)} or 'a' for all) [all]")
        print("   c. Cancel\n")
        selection = input("   > ").strip().lower()

        indices = self._parse_selection(selection, len(projects))
        if indices is None:  # Explicit cancel
            return
        if not indices:
            print("   âŒ No valid selection - please enter numbers from the list above")
            self.wait_for_enter()
            return

        selected = [project_map[i + 1] for i in indices if (i + 1) in project_map]
        if not selected:
            print("   âŒ No valid projects selected")
            self.wait_for_enter()
            return

        # Gather hub learnings info
        learnings_dir = self.hub_path / 'learnings'
        hub_learnings_count = 0
        if learnings_dir.exists():
            hub_learnings_count = len(list(learnings_dir.rglob('*.json')))

        print(f"\n   Teaching {len(selected)} project(s)...\n")

        taught_count = 0
        consolidated_count = 0
        total_corrupt_cleaned = 0
        total_files_migrated = 0
        total_files_cleaned = 0
        all_errors = []
        teaching_details = []  # Track per-project actions

        for proj in selected:
            proj_path = Path(proj['path']).expanduser()
            proj_detail = {'name': proj['name'], 'actions': [], 'impact': 'minimal'}
            print(f"   â”Œâ”€ {proj['name']}")

            if not proj_path.exists():
                print(f"   â”‚  âŒ Path not found")
                print(f"   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
                proj_detail['actions'].append('path not found')
                teaching_details.append(proj_detail)
                continue

            try:
                scf_dir = proj_path / '.scf'
                scf_dir.mkdir(exist_ok=True)

                # First, consolidate any legacy SCF files
                consolidation = self._consolidate_scf_files(proj_path)
                if consolidation['errors']:
                    all_errors.extend([f"{proj['name']}: {e}" for e in consolidation['errors']])

                # Report what happened
                if consolidation['migrated']:
                    total_files_migrated += len(consolidation['migrated'])
                    print(f"   â”‚  ğŸ“¦ Migrated {len(consolidation['migrated'])} file(s) to .scf/")
                    proj_detail['actions'].append(f"migrated {len(consolidation['migrated'])}")
                    proj_detail['impact'] = 'significant'
                if consolidation['merged']:
                    print(f"   â”‚  ğŸ”€ Merged {len(consolidation['merged'])} data source(s)")
                    proj_detail['actions'].append(f"merged {len(consolidation['merged'])}")
                    proj_detail['impact'] = 'moderate' if proj_detail['impact'] == 'minimal' else proj_detail['impact']
                if consolidation['cleaned']:
                    total_files_cleaned += len(consolidation['cleaned'])
                    print(f"   â”‚  ğŸ§¹ Cleaned {len(consolidation['cleaned'])} legacy file(s)")
                    proj_detail['actions'].append(f"cleaned {len(consolidation['cleaned'])}")
                if consolidation['corrupt_lines_cleaned'] > 0:
                    total_corrupt_cleaned += consolidation['corrupt_lines_cleaned']
                    print(f"   â”‚  ğŸ”§ Fixed {consolidation['corrupt_lines_cleaned']} corrupt line(s)")
                    proj_detail['actions'].append(f"fixed {consolidation['corrupt_lines_cleaned']} corrupt")

                # Update kb-sync.json
                kb_sync_path = scf_dir / 'kb-sync.json'
                kb_sync = {}
                if kb_sync_path.exists():
                    try:
                        kb_sync = json.loads(kb_sync_path.read_text())
                    except:
                        pass

                hub_version = self._get_hub_version()
                kb_sync['last_sync_date'] = datetime.now(timezone.utc).isoformat()
                kb_sync['hub_kb_version'] = datetime.now(timezone.utc).isoformat()
                kb_sync['hub_version'] = hub_version
                kb_sync['hub_path'] = str(self.hub_path)

                with open(kb_sync_path, 'w') as f:
                    json.dump(kb_sync, f, indent=2)

                # Update registry
                for p in registry.get('projects', []):
                    if p['name'] == proj['name']:
                        p['last_sync'] = datetime.now(timezone.utc).isoformat()
                        break

                taught_count += 1
                if consolidation['migrated'] or consolidation['merged']:
                    consolidated_count += 1

                if hub_learnings_count > 0:
                    print(f"   â”‚  ğŸ“š Now linked to {hub_learnings_count} hub learning(s)")
                    proj_detail['actions'].append(f"linked {hub_learnings_count} learnings")
                    proj_detail['impact'] = 'significant'

                proj_detail['actions'].append('synced')
                print(f"   â”‚  âœ… Synced with hub version {hub_version[:8]}")
                print(f"   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
                teaching_details.append(proj_detail)

            except Exception as e:
                print(f"   â”‚  âŒ Error: {e}")
                print(f"   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
                all_errors.append(f"{proj['name']}: {str(e)}")
                proj_detail['actions'].append(f'error')
                teaching_details.append(proj_detail)

        self.save_registry(registry)

        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # SUMMARY
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        print(f"\n   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
        print(f"   ğŸ“Š TEACHING SUMMARY")
        print(f"   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")

        # Per-project breakdown
        print(f"\n   By Project: (ğŸŸ¢ significant | ğŸŸ¡ moderate | âšª minimal/current)")
        for detail in teaching_details:
            impact_icon = {'significant': 'ğŸŸ¢', 'moderate': 'ğŸŸ¡', 'minimal': 'âšª'}.get(detail['impact'], 'âšª')
            actions_str = ', '.join(detail['actions']) if detail['actions'] else 'no changes'
            print(f"      {impact_icon} {detail['name']}: {actions_str}")

        print(f"\n   Overall: {taught_count}/{len(selected)} projects taught")

        if total_files_migrated or total_files_cleaned or total_corrupt_cleaned:
            print(f"\n   File Operations Total:")
            if total_files_migrated:
                print(f"      ğŸ“¦ Files migrated:       {total_files_migrated}")
            if total_files_cleaned:
                print(f"      ğŸ§¹ Legacy files cleaned: {total_files_cleaned}")
            if total_corrupt_cleaned:
                print(f"      ğŸ”§ Corrupt lines fixed:  {total_corrupt_cleaned}")

        if hub_learnings_count > 0:
            print(f"\n   Hub Knowledge Available: {hub_learnings_count} learning file(s)")
            print(f"   ğŸ’¡ LLMs in these projects can now access ecosystem patterns!")

        # Log any errors
        if all_errors:
            print(f"\n   âš ï¸  {len(all_errors)} error(s) occurred - check Settings > Error Log")
            self._log_errors("teach_outdated_projects", all_errors)

        self.wait_for_enter()

    def _enable_scf_batch(self, projects: list):
        """Enable SCF on multiple projects with preview and verification"""
        self.clear_screen()
        registry = self.load_registry()

        print("\n   ğŸš€ Enable SCF on Projects")
        print("   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n")

        # Preview what will happen for each project
        print("   Preview - checking each project:\n")
        project_status = []

        for proj in projects:
            proj_path = Path(proj.get('path', '')).expanduser()
            status = {'proj': proj, 'path': proj_path, 'actions': [], 'existing': []}

            if not proj_path.exists():
                status['actions'].append("âŒ Path not found")
                project_status.append(status)
                continue

            scf_dir = proj_path / '.scf'

            # Check for existing SCF files
            existing_files = []
            if scf_dir.exists():
                existing_files = list(scf_dir.glob('*'))
            # Also check root for legacy buildstate
            if (proj_path / 'buildstate.json').exists():
                existing_files.append(proj_path / 'buildstate.json')
            if (proj_path / 'BUILDSTATE.json').exists():
                existing_files.append(proj_path / 'BUILDSTATE.json')

            if existing_files:
                status['existing'] = [f.name for f in existing_files]
                status['actions'].append(f"âš ï¸  Has {len(existing_files)} existing SCF file(s) - will PRESERVE")
            else:
                status['actions'].append("ğŸ“„ Will create new .scf/ with templates")

            # Check what templates would be added
            templates_dir = self.framework_path / 'templates' / 'spoke'
            if templates_dir.exists():
                new_templates = []
                for t in templates_dir.glob('*'):
                    if t.is_file():
                        dest = scf_dir / t.name
                        if not dest.exists():
                            new_templates.append(t.name)
                if new_templates:
                    status['actions'].append(f"â• Will add: {', '.join(new_templates[:3])}{'...' if len(new_templates) > 3 else ''}")

            project_status.append(status)

        # Organize preview by groups
        groups = registry.get('groups', {})
        grouped_status = {}
        ungrouped_status = []

        for status in project_status:
            grp = status['proj'].get('group')
            if grp:
                if grp not in grouped_status:
                    grouped_status[grp] = []
                grouped_status[grp].append(status)
            else:
                ungrouped_status.append(status)

        idx = 1

        for group_name in sorted(grouped_status.keys()):
            group_desc = groups.get(group_name, {}).get('description', '')
            desc_str = f" - {group_desc}" if group_desc else ""
            print(f"   ğŸ“‚ {group_name}{desc_str}")

            for status in grouped_status[group_name]:
                proj = status['proj']
                print(f"   {idx:2}. {proj['name']}")
                for action in status['actions']:
                    print(f"       {action}")
                if status['existing']:
                    print(f"       ğŸ“‚ Existing: {', '.join(status['existing'][:4])}{'...' if len(status['existing']) > 4 else ''}")
                idx += 1
            print()

        if ungrouped_status:
            if grouped_status:
                print(f"   ğŸ“ Ungrouped")
            for status in ungrouped_status:
                proj = status['proj']
                print(f"   {idx:2}. {proj['name']}")
                for action in status['actions']:
                    print(f"       {action}")
                if status['existing']:
                    print(f"       ğŸ“‚ Existing: {', '.join(status['existing'][:4])}{'...' if len(status['existing']) > 4 else ''}")
                idx += 1
            print()

        # Confirm
        print("   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
        print("   âš ï¸  Existing SCF files will NOT be overwritten")
        print("\n   [y] Proceed  [n/Enter] Cancel")
        confirm = input("\n   > ").strip().lower()

        if confirm != 'y':
            print("\n   Cancelled.")
            self.wait_for_enter()
            return

        print(f"\n   Enabling SCF...")

        for status in project_status:
            proj = status['proj']
            proj_path = status['path']

            if not proj_path.exists():
                continue

            print(f"   â€¢ {proj['name']}...", end=" ")
            try:
                # Initialize SCF in the project
                scf_dir = proj_path / '.scf'
                scf_dir.mkdir(exist_ok=True)

                # Copy templates (only if not exists)
                templates_dir = self.framework_path / 'templates' / 'spoke'
                added = []
                if templates_dir.exists():
                    import shutil
                    for template_file in templates_dir.glob('*'):
                        if template_file.is_file():
                            dest = scf_dir / template_file.name
                            if not dest.exists():
                                shutil.copy(template_file, dest)
                                added.append(template_file.name)

                # Update registry
                registry = self.load_registry()
                for p in registry.get('projects', []):
                    if p['name'] == proj['name']:
                        p['scf_enabled'] = True
                        break
                self.save_registry(registry)

                if added:
                    print(f"âœ… Added {len(added)} file(s)")
                elif status['existing']:
                    print(f"âœ… Preserved {len(status['existing'])} existing file(s)")
                else:
                    print("âœ…")
            except Exception as e:
                print(f"âŒ {e}")

        self.wait_for_enter()

    def _sync_projects_batch(self, projects: list):
        """Sync multiple projects"""
        self.clear_screen()
        registry = self.load_registry()

        print("\n   ğŸ”„ Sync Projects")
        print("   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n")

        # Display projects by group
        project_map = self._display_projects_by_group(projects, registry)

        print(f"\n   Selection (1,3,5 or 1-{len(projects)} or 'a' for all) [all]")
        print("   c. Cancel\n")
        selection = input("   > ").strip().lower()

        indices = self._parse_selection(selection, len(projects))
        if indices is None:  # Explicit cancel
            return
        if not indices:
            print("   âŒ No valid selection - please enter numbers from the list above")
            self.wait_for_enter()
            return

        selected = [project_map[i + 1] for i in indices if (i + 1) in project_map]
        if not selected:
            print("   âŒ No valid projects selected")
            self.wait_for_enter()
            return
        print(f"\n   Syncing {len(selected)} project(s)...")

        for proj in selected:
            proj_path = Path(proj['path']).expanduser()
            print(f"   â€¢ {proj['name']}...", end=" ")

            if not proj_path.exists():
                print("âŒ Path not found")
                continue

            try:
                # Run sync for this project
                result = subprocess.run(
                    [sys.executable, str(self.framework_path / 'scf'), 'sync', str(proj_path)],
                    capture_output=True, text=True, timeout=60
                )
                if result.returncode == 0:
                    # Update last_sync in registry
                    registry = self.load_registry()
                    for p in registry.get('projects', []):
                        if p['name'] == proj['name']:
                            p['last_sync'] = datetime.now(timezone.utc).isoformat()
                            break
                    self.save_registry(registry)
                    print("âœ…")
                else:
                    print(f"âš ï¸  {result.stderr[:50] if result.stderr else 'Unknown error'}")
            except subprocess.TimeoutExpired:
                print("âš ï¸  Timeout")
            except Exception as e:
                print(f"âŒ {e}")

        self.wait_for_enter()

    def _learn_from_projects(self, projects: list):
        """Learn patterns from projects"""
        self.clear_screen()
        registry = self.load_registry()

        print("\n   ğŸ§  Learn from Projects")
        print("   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n")

        # Display projects by group
        project_map = self._display_projects_by_group(projects, registry)

        print(f"\n   Selection (1,3,5 or 1-{len(projects)} or 'a' for all) [all]")
        print("   c. Cancel\n")
        selection = input("   > ").strip().lower()

        indices = self._parse_selection(selection, len(projects))
        if indices is None:  # Explicit cancel
            return
        if not indices:
            print("   âŒ No valid selection - please enter numbers from the list above")
            self.wait_for_enter()
            return

        selected = [project_map[i + 1] for i in indices if (i + 1) in project_map]
        if not selected:
            print("   âŒ No valid projects selected")
            self.wait_for_enter()
            return
        print(f"\n   Learning from {len(selected)} project(s)...")

        learnings_dir = self.hub_path / 'learnings'
        learnings_dir.mkdir(exist_ok=True)

        total_learnings = 0

        for proj in selected:
            proj_path = Path(proj['path']).expanduser()
            print(f"\n   ğŸ“‚ {proj['name']}")

            if not proj_path.exists():
                print("      âŒ Path not found")
                continue

            # Look for signals and decisions
            scf_dir = proj_path / '.scf'
            buildstate_path = scf_dir / 'BUILDSTATE.json'
            signals_path = scf_dir / 'spoke-signals.jsonl'

            project_learnings = []

            # Extract high-impact decisions from BUILDSTATE.json
            # Try multiple buildstate locations
            buildstate_paths = [
                scf_dir / 'BUILDSTATE.json',
                scf_dir / 'buildstate.json',
                proj_path / 'BUILDSTATE.json',
                proj_path / 'buildstate.json'
            ]

            for buildstate_path in buildstate_paths:
                if buildstate_path.exists():
                    try:
                        content = buildstate_path.read_text().strip()
                        if not content:
                            continue  # Skip empty files
                        buildstate = json.loads(content)
                        decisions = buildstate.get('decisions', [])
                        high_impact = [d for d in decisions if d.get('impact', 0) >= 8]
                        for decision in high_impact:
                            project_learnings.append({
                                'type': 'decision',
                                'source_project': proj['name'],
                                'source_path': str(proj_path),
                                'date': decision.get('date'),
                                'topic': decision.get('decision'),
                                'rationale': decision.get('rationale'),
                                'impact': decision.get('impact'),
                                'learned_at': datetime.now(timezone.utc).isoformat()
                            })
                        if high_impact:
                            print(f"      â€¢ Found {len(high_impact)} high-impact decisions")
                        break  # Found valid buildstate, stop searching
                    except json.JSONDecodeError as e:
                        print(f"      âš ï¸  Invalid JSON in {buildstate_path.name}: {e}")
                    except Exception as e:
                        print(f"      âš ï¸  Error reading {buildstate_path.name}: {e}")

            # Extract offers from spoke-signals.jsonl
            # Also check root location for legacy
            signals_paths = [signals_path, proj_path / 'spoke-signals.jsonl']
            for sig_path in signals_paths:
                if sig_path.exists():
                    try:
                        offers = []
                        parse_errors = 0
                        with open(sig_path) as f:
                            for line_num, line in enumerate(f, 1):
                                line = line.strip()
                                if line:
                                    try:
                                        signal = json.loads(line)
                                        if not isinstance(signal, dict):
                                            continue
                                        for offer in signal.get('offers', []):
                                            if offer.get('impact', 0) >= 8:
                                                offers.append({
                                                    'type': offer.get('type', 'pattern'),
                                                    'source_project': proj['name'],
                                                    'source_path': str(proj_path),
                                                    'date': signal.get('timestamp'),
                                                    'topic': offer.get('topic'),
                                                    'context': offer.get('context'),
                                                    'impact': offer.get('impact'),
                                                    'learned_at': datetime.now(timezone.utc).isoformat()
                                                })
                                    except json.JSONDecodeError:
                                        parse_errors += 1
                        project_learnings.extend(offers)
                        if offers:
                            print(f"      â€¢ Found {len(offers)} signaled learnings")
                        if parse_errors:
                            print(f"      âš ï¸  {parse_errors} malformed signal line(s) skipped")
                        break  # Found signals file, stop searching
                    except Exception as e:
                        print(f"      âš ï¸  Error reading signals: {e}")

            # Save learnings
            if project_learnings:
                learning_file = learnings_dir / f"{proj['name']}.json"
                existing = []
                if learning_file.exists():
                    try:
                        existing = json.loads(learning_file.read_text())
                    except:
                        pass

                # Merge, avoiding duplicates by topic
                existing_topics = {l.get('topic') for l in existing}
                new_learnings = [l for l in project_learnings if l.get('topic') not in existing_topics]

                if new_learnings:
                    all_learnings = existing + new_learnings
                    with open(learning_file, 'w') as f:
                        json.dump(all_learnings, f, indent=2)
                    print(f"      âœ… Saved {len(new_learnings)} new learning(s)")
                    total_learnings += len(new_learnings)
                else:
                    print(f"      â„¹ï¸  No new learnings (already captured)")
            else:
                print(f"      â„¹ï¸  No high-impact learnings found")

        print(f"\n   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
        print(f"   ğŸ“Š Total new learnings captured: {total_learnings}")

        self.wait_for_enter()

    def knowledge_base_menu(self):
        """Browse the knowledge base (learnings)"""
        while True:
            self.clear_screen()
            learnings_dir = self.hub_path / 'learnings'

            # Load all learnings
            all_learnings = []
            learning_files = []
            if learnings_dir.exists():
                learning_files = sorted(learnings_dir.glob('*.json'))
                for lf in learning_files:
                    try:
                        data = json.loads(lf.read_text())
                        if isinstance(data, list):
                            for item in data:
                                item['_source_file'] = lf.name
                            all_learnings.extend(data)
                    except:
                        pass

            # Group by type
            by_type = {}
            for learning in all_learnings:
                ltype = learning.get('type', 'unknown')
                if ltype not in by_type:
                    by_type[ltype] = []
                by_type[ltype].append(learning)

            # Group by source project
            by_project = {}
            for learning in all_learnings:
                proj = learning.get('source_project', 'unknown')
                if proj not in by_project:
                    by_project[proj] = []
                by_project[proj].append(learning)

            print(f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    ğŸ“– Knowledge Base                         â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

   ğŸ“Š Summary
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   Total learnings:     {len(all_learnings)}
   Learning files:      {len(learning_files)}
   Source projects:     {len(by_project)}
""")
            if by_type:
                print("   By Type:")
                for ltype, items in sorted(by_type.items()):
                    print(f"      â€¢ {ltype}: {len(items)}")
                print()

            print("""   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   1. ğŸ“‹ Browse all learnings
   2. ğŸ“ Browse by project
   3. ğŸ·ï¸  Browse by type
   4. ğŸ” Search learnings
   5. ğŸ“„ View learning files

   b. Back to main menu
""")
            choice = self.get_choice(5)

            if choice == 'b':
                return
            elif choice == '1':
                self._browse_all_learnings(all_learnings)
            elif choice == '2':
                self._browse_by_project(by_project)
            elif choice == '3':
                self._browse_by_type(by_type)
            elif choice == '4':
                self._search_learnings(all_learnings)
            elif choice == '5':
                self._view_learning_files(learning_files)

    def _browse_all_learnings(self, learnings: list):
        """Browse all learnings with pagination"""
        if not learnings:
            self.clear_screen()
            print("\n   ğŸ“­ No learnings found.")
            print("   Use 'Learn' to gather learnings from your projects.")
            self.wait_for_enter()
            return

        page = 0
        per_page = 5

        while True:
            self.clear_screen()
            total_pages = (len(learnings) - 1) // per_page + 1
            start = page * per_page
            end = min(start + per_page, len(learnings))

            title = f"ğŸ“‹ All Learnings (Page {page + 1}/{total_pages})"
            title_padding = (62 - len(title)) // 2
            title_line = f"{' ' * title_padding}{title}{' ' * (62 - title_padding - len(title))}"
            print(f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘{title_line}â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
""")
            for i, learning in enumerate(learnings[start:end], start + 1):
                self._print_learning_summary(i, learning)
                print()

            print("   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
            nav = []
            if page > 0:
                nav.append("p. Previous")
            if page < total_pages - 1:
                nav.append("n. Next")
            nav.append(f"1-{end - start}. View details")
            nav.append("b. Back")
            print(f"   {' | '.join(nav)}")

            choice = input("\n   > ").strip().lower()

            if choice == 'b':
                return
            elif choice == 'p' and page > 0:
                page -= 1
            elif choice == 'n' and page < total_pages - 1:
                page += 1
            elif choice.isdigit():
                idx = int(choice)
                if 1 <= idx <= (end - start):
                    self._view_learning_detail(learnings[start + idx - 1])

    def _browse_by_project(self, by_project: dict):
        """Browse learnings grouped by source project"""
        if not by_project:
            self.clear_screen()
            print("\n   ğŸ“­ No learnings found.")
            self.wait_for_enter()
            return

        while True:
            self.clear_screen()
            projects = sorted(by_project.keys())

            print(f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘              ğŸ“ Learnings by Project                         â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
""")
            for i, proj in enumerate(projects, 1):
                count = len(by_project[proj])
                types = set(l.get('type', 'unknown') for l in by_project[proj])
                print(f"   {i:2}. {proj} ({count} learnings)")
                print(f"       Types: {', '.join(sorted(types))}")

            print("\n   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
            print(f"   Enter 1-{len(projects)} to view project learnings")
            print("   c. Cancel\n")

            choice = input("   > ").strip().lower()

            if choice == 'c':
                return

            if choice.isdigit():
                idx = int(choice)
                if 1 <= idx <= len(projects):
                    proj_name = projects[idx - 1]
                    self._browse_all_learnings(by_project[proj_name])

    def _browse_by_type(self, by_type: dict):
        """Browse learnings grouped by type"""
        if not by_type:
            self.clear_screen()
            print("\n   ğŸ“­ No learnings found.")
            self.wait_for_enter()
            return

        while True:
            self.clear_screen()
            types = sorted(by_type.keys())

            print(f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘              ğŸ·ï¸  Learnings by Type                            â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
""")
            for i, ltype in enumerate(types, 1):
                count = len(by_type[ltype])
                projects = set(l.get('source_project', 'unknown') for l in by_type[ltype])
                print(f"   {i:2}. {ltype} ({count} learnings)")
                print(f"       From: {', '.join(sorted(projects)[:3])}{'...' if len(projects) > 3 else ''}")

            print("\n   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
            print(f"   Enter 1-{len(types)} to view type learnings")
            print("   c. Cancel\n")

            choice = input("   > ").strip().lower()

            if choice == 'c':
                return

            if choice.isdigit():
                idx = int(choice)
                if 1 <= idx <= len(types):
                    type_name = types[idx - 1]
                    self._browse_all_learnings(by_type[type_name])

    def _search_learnings(self, learnings: list):
        """Search learnings by keyword"""
        self.clear_screen()
        print(f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘              ğŸ” Search Learnings                             â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
""")
        print("   Enter search term (searches topic, rationale, context)")
        print("   c. Cancel\n")

        query = input("   Search: ").strip().lower()

        if query == 'c' or not query:
            return

        # Search in various fields
        results = []
        for learning in learnings:
            searchable = ' '.join([
                str(learning.get('topic', '')),
                str(learning.get('rationale', '')),
                str(learning.get('context', '')),
                str(learning.get('source_project', '')),
                str(learning.get('type', ''))
            ]).lower()

            if query in searchable:
                results.append(learning)

        if not results:
            print(f"\n   No results found for '{query}'")
            self.wait_for_enter()
            return

        print(f"\n   Found {len(results)} result(s)")
        self.wait_for_enter()
        self._browse_all_learnings(results)

    def _view_learning_files(self, learning_files: list):
        """View raw learning files"""
        if not learning_files:
            self.clear_screen()
            print("\n   ğŸ“­ No learning files found.")
            self.wait_for_enter()
            return

        while True:
            self.clear_screen()
            print(f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘              ğŸ“„ Learning Files                               â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
""")
            for i, lf in enumerate(learning_files, 1):
                try:
                    data = json.loads(lf.read_text())
                    count = len(data) if isinstance(data, list) else 1
                    size = lf.stat().st_size
                    mtime = datetime.fromtimestamp(lf.stat().st_mtime).strftime('%Y-%m-%d %H:%M')
                    print(f"   {i:2}. {lf.name}")
                    print(f"       {count} learnings | {self._format_size(size)} | Modified: {mtime}")
                except:
                    print(f"   {i:2}. {lf.name} (error reading)")

            print("\n   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
            print(f"   Enter 1-{len(learning_files)} to view file contents")
            print("   c. Cancel\n")

            choice = input("   > ").strip().lower()

            if choice == 'c':
                return

            if choice.isdigit():
                idx = int(choice)
                if 1 <= idx <= len(learning_files):
                    self._view_file_contents(learning_files[idx - 1])

    def _view_file_contents(self, filepath: Path):
        """View contents of a learning file"""
        self.clear_screen()
        print(f"\n   ğŸ“„ {filepath.name}")
        print("   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n")

        try:
            data = json.loads(filepath.read_text())
            if isinstance(data, list):
                for i, learning in enumerate(data, 1):
                    self._print_learning_summary(i, learning)
                    print()
            else:
                print(json.dumps(data, indent=2)[:2000])
        except Exception as e:
            print(f"   Error reading file: {e}")

        self.wait_for_enter()

    def _print_learning_summary(self, num: int, learning: dict):
        """Print a learning summary"""
        ltype = learning.get('type', 'unknown')
        topic = learning.get('topic', 'No topic')[:50]
        project = learning.get('source_project', 'unknown')
        impact = learning.get('impact', '?')
        date = learning.get('date', learning.get('learned_at', ''))[:10] if learning.get('date') or learning.get('learned_at') else ''

        type_icons = {
            'decision': 'ğŸ“‹',
            'pattern': 'ğŸ”„',
            'solution': 'ğŸ’¡',
            'optimization': 'âš¡',
            'bugfix': 'ğŸ›',
            'architecture': 'ğŸ—ï¸'
        }
        icon = type_icons.get(ltype, 'ğŸ“')

        print(f"   {num:2}. {icon} [{ltype}] {topic}")
        print(f"       From: {project} | Impact: {impact} | {date}")

    def _view_learning_detail(self, learning: dict):
        """View detailed learning information"""
        self.clear_screen()

        ltype = learning.get('type', 'unknown')
        type_icons = {
            'decision': 'ğŸ“‹',
            'pattern': 'ğŸ”„',
            'solution': 'ğŸ’¡',
            'optimization': 'âš¡',
            'bugfix': 'ğŸ›',
            'architecture': 'ğŸ—ï¸'
        }
        icon = type_icons.get(ltype, 'ğŸ“')

        print(f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘              {icon} Learning Detail                            â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

   Type:     {ltype}
   Topic:    {learning.get('topic', 'No topic')}
   Impact:   {learning.get('impact', '?')}/10

   Source
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   Project:  {learning.get('source_project', 'unknown')}
   Path:     {learning.get('source_path', 'unknown')}
   Date:     {learning.get('date', learning.get('learned_at', 'unknown'))}
""")
        if learning.get('rationale'):
            print("   Rationale")
            print("   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
            # Word wrap rationale
            rationale = learning['rationale']
            for i in range(0, len(rationale), 55):
                print(f"   {rationale[i:i+55]}")
            print()

        if learning.get('context'):
            print("   Context")
            print("   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
            context = learning['context']
            for i in range(0, len(context), 55):
                print(f"   {context[i:i+55]}")
            print()

        if learning.get('_source_file'):
            print(f"   ğŸ“„ Source file: {learning['_source_file']}")

        self.wait_for_enter()

    def settings_menu(self):
        """Hub settings menu"""
        while True:
            self.clear_screen()
            profile = self.load_profile()

            # Count error logs
            log_file = self.hub_path / 'logs' / 'errors.jsonl'
            error_count = 0
            if log_file.exists():
                try:
                    error_count = sum(1 for _ in open(log_file))
                except:
                    pass

            print(f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    âš™ï¸  Hub Settings                           â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

   Current Settings:
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   ğŸ‘¤ Name:      {profile.get('user', {}).get('name', 'Not set')}
   ğŸ’¼ Focus:     {profile.get('work_style', {}).get('description', 'Not set')}
   ğŸ¤– AI Style:  {profile.get('work_style', {}).get('ai_collaboration_style', 'collaborative')}
   ğŸ“ Hub Path:  {self.hub_path}

   1. âœï¸  Edit name
   2. âœï¸  Edit focus
   3. âœï¸  Edit AI collaboration style
   4. ğŸ“‚ Open hub-profile.json
   5. ğŸ“‹ View error log ({error_count} entries)
   6. ğŸ—‘ï¸  Clear error log

   b. Back
""")
            choice = self.get_choice(6)

            if choice == 'b':
                return
            elif choice == '1':
                new_name = input("\n   Enter new name: ").strip()
                if new_name:
                    profile['user']['name'] = new_name
                    self._save_profile(profile)
                    print("   âœ… Updated!")
                    self.wait_for_enter()
            elif choice == '2':
                new_focus = input("\n   Enter your focus/role: ").strip()
                if new_focus:
                    profile['work_style']['description'] = new_focus
                    self._save_profile(profile)
                    print("   âœ… Updated!")
                    self.wait_for_enter()
            elif choice == '3':
                print("\n   AI Collaboration Style:")
                print("   1. Autonomous - AI takes initiative")
                print("   2. Collaborative - Discuss first")
                print("   3. Supervised - Always ask")
                style_choice = input("   > ").strip()
                styles = {'1': 'autonomous', '2': 'collaborative', '3': 'supervised'}
                if style_choice in styles:
                    profile['work_style']['ai_collaboration_style'] = styles[style_choice]
                    self._save_profile(profile)
                    print("   âœ… Updated!")
                    self.wait_for_enter()
            elif choice == '4':
                import os
                editor = os.environ.get('EDITOR', 'nano')
                os.system(f'{editor} "{self.hub_path}/hub-profile.json"')
            elif choice == '5':
                self._view_error_log()
            elif choice == '6':
                self._clear_error_log()

    def _view_error_log(self):
        """View the error log"""
        self.clear_screen()
        log_file = self.hub_path / 'logs' / 'errors.jsonl'

        print(f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    ğŸ“‹ Error Log                              â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
""")
        if not log_file.exists():
            print("   ğŸ“­ No errors logged yet. That's good!")
            self.wait_for_enter()
            return

        try:
            entries = []
            with open(log_file) as f:
                for line in f:
                    if line.strip():
                        try:
                            entries.append(json.loads(line))
                        except:
                            pass

            if not entries:
                print("   ğŸ“­ Error log is empty.")
                self.wait_for_enter()
                return

            # Show most recent first
            entries.reverse()

            print(f"   Showing {min(10, len(entries))} most recent of {len(entries)} total entries\n")

            for entry in entries[:10]:
                timestamp = entry.get('timestamp', 'unknown')[:19].replace('T', ' ')
                operation = entry.get('operation', 'unknown')
                errors = entry.get('errors', [])

                print(f"   [{timestamp}] {operation}")
                for err in errors[:3]:
                    print(f"      â€¢ {err[:65]}{'...' if len(err) > 65 else ''}")
                if len(errors) > 3:
                    print(f"      ... and {len(errors) - 3} more")
                print()

            print(f"   Log file: {log_file}")

        except Exception as e:
            print(f"   âŒ Error reading log: {e}")

        self.wait_for_enter()

    def _clear_error_log(self):
        """Clear the error log"""
        log_file = self.hub_path / 'logs' / 'errors.jsonl'

        if not log_file.exists():
            print("\n   ğŸ“­ No error log to clear.")
            self.wait_for_enter()
            return

        print("\n   âš ï¸  This will delete all logged errors.")
        print("   [y] Clear log  [n/Enter] Cancel")
        confirm = input("\n   > ").strip().lower()

        if confirm == 'y':
            try:
                log_file.unlink()
                print("   âœ… Error log cleared.")
            except Exception as e:
                print(f"   âŒ Error clearing log: {e}")
        else:
            print("   Cancelled.")

        self.wait_for_enter()

    def _save_profile(self, profile: dict):
        """Save hub profile"""
        profile_path = self.hub_path / 'hub-profile.json'
        with open(profile_path, 'w') as f:
            json.dump(profile, f, indent=2)


class SCFCommands:
    """Main SCF command implementations"""

    @staticmethod
    def cmd_init(args):
        """Initialize SCF in a project (spoke mode) or setup hub"""
        project_path = Path(args.path).resolve()

        if args.hub:
            print("ğŸ—ï¸  Setting up SCF Hub...")
            print("Use 'scf hub create' for guided hub setup.")
        elif args.guided:
            SCFCommands._guided_init(project_path, args)
        else:
            print(f"ğŸš€ Initializing SCF in: {project_path.name}")
            # Use existing teach.py init logic
            hub_path = Path(__file__).parent.resolve()
            init_project(project_path, hub_path, args.verbose)

    @staticmethod
    def _guided_init(project_path: Path, args):
        """Guided initialization with foundation questions"""
        print(f"\nğŸš€ Guided SCF Setup for: {project_path.name}\n")
        print("Let's establish your project foundation.\n")

        # Gather foundation info
        print("ğŸ“‹ Project Identity:\n")

        name = input("   Project name: ").strip() or project_path.name

        print("\n   What type of project is this?")
        print("   [1] Code - Software development")
        print("   [2] Research - Investigation, analysis")
        print("   [3] Writing - Documentation, content")
        print("   [4] Design - UI/UX, architecture")
        print("   [5] Hybrid - Mix of above")

        type_map = {'1': 'code', '2': 'research', '3': 'writing', '4': 'design', '5': 'hybrid'}
        while True:
            type_choice = input("   > ").strip()
            if type_choice in type_map:
                project_type = type_map[type_choice]
                break
            print("   Please enter 1-5")

        one_liner = input("\n   One-sentence description: ").strip()
        success = input("   What does 'done' look like? ").strip()

        print("\nğŸ“‹ Boundaries:\n")
        in_scope = input("   What's IN scope? (comma-separated): ").strip()
        out_scope = input("   What's OUT of scope? (comma-separated): ").strip()

        print("\nğŸ“‹ AI Collaboration:\n")
        print("   How should AI work with you?")
        print("   [1] Autonomous - Take initiative")
        print("   [2] Collaborative - Discuss first")
        print("   [3] Supervised - Always ask")

        style_map = {'1': 'autonomous', '2': 'collaborative', '3': 'supervised'}
        while True:
            style_choice = input("   > ").strip()
            if style_choice in style_map:
                ai_style = style_map[style_choice]
                break
            print("   Please enter 1-3")

        # Initialize with foundation
        hub_path = Path(__file__).parent.resolve()
        init_project(project_path, hub_path, args.verbose)

        # Update buildstate with foundation
        scf_dir = project_path / '.scf'
        buildstate_path = scf_dir / 'BUILDSTATE.json'

        if buildstate_path.exists():
            with open(buildstate_path) as f:
                buildstate = json.load(f)
        else:
            buildstate = {}

        # Add foundation
        buildstate['_project_foundation'] = {
            "completed": True,
            "completed_at": datetime.now(timezone.utc).isoformat(),
            "completed_with": "scf init --guided",
            "identity": {
                "type": project_type,
                "name": name,
                "one_liner": one_liner,
                "success_looks_like": success
            },
            "boundaries": {
                "in_scope": [s.strip() for s in in_scope.split(',') if s.strip()],
                "out_of_scope": [s.strip() for s in out_scope.split(',') if s.strip()],
                "constraints": []
            },
            "approach": {
                "ai_collaboration_style": ai_style
            },
            "philosophy": {
                "core_principle": "AI as responsible partner, not just enabler",
                "behaviors": [
                    "Detect scope drift and flag before enabling",
                    "Require explicit acknowledgment for direction changes"
                ]
            },
            "evolution_log": [{
                "date": datetime.now().strftime("%Y-%m-%d"),
                "change": "Project foundation established",
                "acknowledged_by": "User via guided setup",
                "ai_partner": "scf CLI"
            }]
        }

        # Update project info
        buildstate['project'] = {
            "name": name,
            "type": project_type,
            "description": one_liner
        }

        with open(buildstate_path, 'w') as f:
            json.dump(buildstate, f, indent=2)

        print(f"\nâœ… Project foundation established!")
        print(f"   AI assistants will now work within your defined boundaries.")

    @staticmethod
    def cmd_sync(args):
        """Sync project with hub or check sync status"""
        project_path = Path(args.path or ".").resolve()

        if args.status:
            print(f"ğŸ” Checking sync status for: {project_path.name}")
            check_sync_status(project_path)
        else:
            print(f"ğŸ”„ Syncing {project_path.name} with hub...")
            hub_path = Path(__file__).parent.resolve()
            update_project(project_path, hub_path, args.verbose)

    @staticmethod
    def cmd_hub(args):
        """Hub management commands"""
        framework_path = Path(__file__).parent.resolve()
        hub_manager = SCFHubManager(framework_path)

        # Find hub for most operations
        hub_path = hub_manager.find_hub()

        # Launch interactive mode if no action or explicit --interactive
        if args.action is None or (hasattr(args, 'interactive') and args.interactive):
            if not hub_path:
                print("âŒ No hub found. Let's create one!\n")
                hub_manager.create_hub(Path("~/scf-hub").expanduser())
                hub_path = hub_manager.find_hub()

            menu = SCFHubMenu(hub_path, hub_manager, framework_path)
            menu.run()
            return

        if args.action == "help":
            SCFCommands._hub_help()

        elif args.action == "create":
            create_path = Path(args.path or "~/scf-hub").expanduser()
            hub_manager.create_hub(create_path, interactive=not args.non_interactive)

        elif args.action == "locate":
            if hub_path:
                print(f"âœ… Hub found at: {hub_path}")
            else:
                print("âŒ No hub found.")
                print("\nTo create a hub, run: scf hub create")

        elif args.action == "status":
            SCFCommands._hub_status(hub_path)

        elif args.action == "stats":
            SCFCommands._hub_stats(hub_path, hub_manager)

        elif args.action == "projects":
            SCFCommands._hub_projects(hub_path, args)

        elif args.action == "learn":
            SCFCommands._hub_learn(hub_path, hub_manager, args)

        elif args.action == "teach":
            SCFCommands._hub_teach(hub_path, hub_manager, args)

        elif args.action == "scan":
            SCFCommands._hub_scan(hub_path, hub_manager)

    @staticmethod
    def _hub_help():
        """Show hub-specific help"""
        print("""
ğŸ“Š SCF Hub Commands
==================

  scf hub status              Show hub status and health
  scf hub stats               Detailed statistics on projects and learnings
  scf hub locate              Find hub location

Project Management:
  scf hub projects            List all registered projects
  scf hub projects --add <path>       Add a project to hub
  scf hub projects --remove <name>    Remove a project from hub
  scf hub projects --info <name>      Show project details
  scf hub scan                Scan directories for new projects

Learning & Teaching:
  scf hub learn               Gather learnings from all spokes
  scf hub learn <project>     Learn from specific project
  scf hub teach               Push learnings to all spokes
  scf hub teach <project>     Teach specific project

Setup:
  scf hub create              Create a new hub (interactive)
  scf hub create <path>       Create hub at specific location

Examples:
  scf hub projects --add ~/projects/my-app
  scf hub learn session-continuity-framework
  scf hub teach --all
""")

    @staticmethod
    def _hub_status(hub_path: Path):
        """Show hub status"""
        if not hub_path:
            print("âŒ No hub configured. Run: scf hub create")
            return

        print(f"ğŸ“Š Hub Status")
        print("=" * 50)
        print(f"\nğŸ“ Location: {hub_path}\n")

        # Show hub info
        profile_path = hub_path / 'hub-profile.json'
        if profile_path.exists():
            with open(profile_path) as f:
                profile = json.load(f)
            print(f"ğŸ‘¤ User: {profile.get('user', {}).get('name', 'Unknown')}")
            print(f"ğŸ’¼ Focus: {profile.get('work_style', {}).get('description', 'Not set')}")
            print(f"ğŸ¤– AI Style: {profile.get('work_style', {}).get('ai_collaboration_style', 'collaborative')}")
            created = profile.get('hub_config', {}).get('created_at', 'Unknown')
            if created != 'Unknown':
                created = created.split('T')[0]
            print(f"ğŸ“… Created: {created}")

        # Count and list projects
        registry_path = hub_path / '.scf-registry' / 'spoke-projects.json'
        if registry_path.exists():
            with open(registry_path) as f:
                registry = json.load(f)
            projects = registry.get('projects', [])
            scf_enabled = sum(1 for p in projects if p.get('scf_enabled'))
            print(f"\nğŸ“ Projects: {len(projects)} total ({scf_enabled} SCF-enabled)")

            if projects:
                print("\n   Recent projects:")
                for proj in projects[:5]:
                    status = "ğŸŒŸ" if proj.get('scf_enabled') else "ğŸ“"
                    print(f"   {status} {proj['name']}")
                if len(projects) > 5:
                    print(f"   ... and {len(projects) - 5} more")

        # Check learnings
        learnings_dir = hub_path / 'learnings'
        if learnings_dir.exists():
            learning_files = list(learnings_dir.glob('*.json'))
            print(f"\nğŸ§  Learnings: {len(learning_files)} patterns stored")

        print(f"\nğŸ’¡ Run 'scf hub stats' for detailed statistics")

    @staticmethod
    def _hub_stats(hub_path: Path, hub_manager):
        """Show detailed hub statistics"""
        if not hub_path:
            print("âŒ No hub configured. Run: scf hub create")
            return

        print(f"ğŸ“Š Hub Statistics")
        print("=" * 50)

        registry_path = hub_path / '.scf-registry' / 'spoke-projects.json'
        if not registry_path.exists():
            print("\nâŒ No project registry found")
            return

        with open(registry_path) as f:
            registry = json.load(f)

        projects = registry.get('projects', [])
        scf_enabled = [p for p in projects if p.get('scf_enabled')]
        regular = [p for p in projects if not p.get('scf_enabled')]

        print(f"\nğŸ“ Projects Overview")
        print(f"   Total registered: {len(projects)}")
        print(f"   SCF-enabled:      {len(scf_enabled)}")
        print(f"   Regular:          {len(regular)}")

        # Sync status
        needs_sync = []
        never_synced = []
        for proj in projects:
            if proj.get('scf_enabled'):
                if not proj.get('last_sync'):
                    never_synced.append(proj['name'])
                # Could check actual sync dates here

        if never_synced:
            print(f"\nâš ï¸  Never synced: {len(never_synced)} projects")
            for name in never_synced[:3]:
                print(f"      â€¢ {name}")

        # Learnings stats
        learnings_dir = hub_path / 'learnings'
        print(f"\nğŸ§  Learnings")
        if learnings_dir.exists():
            learning_files = list(learnings_dir.glob('*.json'))
            print(f"   Patterns stored: {len(learning_files)}")
        else:
            print(f"   Patterns stored: 0")
            print(f"   ğŸ’¡ Run 'scf hub learn' to gather learnings from spokes")

        # Recommendations
        print(f"\nğŸ’¡ Recommendations")
        if regular:
            print(f"   â€¢ {len(regular)} projects could be SCF-enabled")
        if never_synced:
            print(f"   â€¢ {len(never_synced)} projects need initial sync")
        if not scf_enabled:
            print(f"   â€¢ Run 'scf hub scan' to discover more projects")

    @staticmethod
    def _hub_projects(hub_path: Path, args):
        """List and manage hub projects"""
        if not hub_path:
            print("âŒ No hub configured. Run: scf hub create")
            return

        registry_path = hub_path / '.scf-registry' / 'spoke-projects.json'

        # Handle --add
        if args.add:
            SCFCommands._hub_projects_add(hub_path, registry_path, args.add)
            return

        # Handle --remove
        if args.remove:
            SCFCommands._hub_projects_remove(registry_path, args.remove)
            return

        # Handle --info
        if args.info:
            SCFCommands._hub_projects_info(registry_path, args.info)
            return

        # Default: list all projects
        if not registry_path.exists():
            print("ğŸ“ No projects registered yet")
            print("   Run 'scf hub scan' to discover projects")
            return

        with open(registry_path) as f:
            registry = json.load(f)

        projects = registry.get('projects', [])
        if not projects:
            print("ğŸ“ No projects registered yet")
            return

        print(f"ğŸ“ Registered Projects ({len(projects)})")
        print("=" * 50)

        for proj in sorted(projects, key=lambda x: x['name'].lower()):
            status = "ğŸŒŸ" if proj.get('scf_enabled') else "ğŸ“"
            sync = proj.get('last_sync', 'never')
            if sync != 'never':
                sync = sync.split('T')[0]
            print(f"\n{status} {proj['name']}")
            print(f"   Path: {proj['path']}")
            print(f"   Type: {proj.get('type', 'unknown')}")
            print(f"   Last sync: {sync}")

    @staticmethod
    def _hub_projects_add(hub_path: Path, registry_path: Path, project_path: str):
        """Add a project to the hub"""
        proj_path = Path(project_path).expanduser().resolve()

        if not proj_path.exists():
            print(f"âŒ Path not found: {proj_path}")
            return

        # Load or create registry
        if registry_path.exists():
            with open(registry_path) as f:
                registry = json.load(f)
        else:
            registry = {"version": "1.0", "projects": []}

        # Check if already registered
        existing = {p['path'] for p in registry.get('projects', [])}
        if str(proj_path) in existing:
            print(f"âš ï¸  Project already registered: {proj_path.name}")
            return

        # Detect project info
        is_scf = (proj_path / '.scf').exists() or (proj_path / 'buildstate.json').exists()

        proj_info = {
            'name': proj_path.name,
            'path': str(proj_path),
            'type': 'unknown',
            'scf_enabled': is_scf,
            'added_at': datetime.now(timezone.utc).isoformat(),
            'last_sync': None
        }

        # Read SCF details if available
        if is_scf:
            for bs_path in [proj_path / '.scf' / 'BUILDSTATE.json', proj_path / 'buildstate.json']:
                if bs_path.exists():
                    try:
                        with open(bs_path) as f:
                            data = json.load(f)
                        proj_info['type'] = data.get('project', {}).get('type', 'unknown')

                        # Update spoke's hub_path
                        if '_scf_metadata' in data:
                            data['_scf_metadata']['hub_path'] = str(hub_path)
                            with open(bs_path, 'w') as f:
                                json.dump(data, f, indent=2)
                        break
                    except:
                        pass

        registry['projects'].append(proj_info)

        with open(registry_path, 'w') as f:
            json.dump(registry, f, indent=2)

        status = "ğŸŒŸ SCF-enabled" if is_scf else "ğŸ“ Regular"
        print(f"âœ… Added: {proj_path.name} ({status})")

    @staticmethod
    def _hub_projects_remove(registry_path: Path, project_name: str):
        """Remove a project from the hub"""
        if not registry_path.exists():
            print("âŒ No projects registered")
            return

        with open(registry_path) as f:
            registry = json.load(f)

        projects = registry.get('projects', [])
        original_count = len(projects)

        # Filter out the project (match by name or path)
        registry['projects'] = [
            p for p in projects
            if p['name'].lower() != project_name.lower() and
               not p['path'].endswith(project_name)
        ]

        if len(registry['projects']) == original_count:
            print(f"âŒ Project not found: {project_name}")
            return

        with open(registry_path, 'w') as f:
            json.dump(registry, f, indent=2)

        print(f"âœ… Removed: {project_name}")

    @staticmethod
    def _hub_projects_info(registry_path: Path, project_name: str):
        """Show detailed project info"""
        if not registry_path.exists():
            print("âŒ No projects registered")
            return

        with open(registry_path) as f:
            registry = json.load(f)

        # Find project
        proj = None
        for p in registry.get('projects', []):
            if p['name'].lower() == project_name.lower() or p['path'].endswith(project_name):
                proj = p
                break

        if not proj:
            print(f"âŒ Project not found: {project_name}")
            return

        print(f"ğŸ“¦ Project: {proj['name']}")
        print("=" * 50)
        print(f"   Path:        {proj['path']}")
        print(f"   Type:        {proj.get('type', 'unknown')}")
        print(f"   SCF-enabled: {'Yes' if proj.get('scf_enabled') else 'No'}")
        print(f"   Added:       {proj.get('added_at', 'unknown').split('T')[0]}")
        print(f"   Last sync:   {proj.get('last_sync', 'never')}")

        # If SCF-enabled, read more details
        if proj.get('scf_enabled'):
            proj_path = Path(proj['path'])
            for bs_path in [proj_path / '.scf' / 'BUILDSTATE.json', proj_path / 'buildstate.json']:
                if bs_path.exists():
                    try:
                        with open(bs_path) as f:
                            data = json.load(f)

                        if '_project_foundation' in data:
                            foundation = data['_project_foundation']
                            if foundation.get('identity'):
                                print(f"\nğŸ“‹ Foundation:")
                                print(f"   {foundation['identity'].get('one_liner', 'No description')}")

                        if 'features' in data and data['features']:
                            print(f"\nâœ¨ Features: {len(data['features'])}")
                            for feat in data['features'][:3]:
                                print(f"   â€¢ {feat.get('name', 'unnamed')}")

                        if 'decisions' in data and data['decisions']:
                            print(f"\nğŸ“ Decisions: {len(data['decisions'])}")

                        break
                    except:
                        pass

    @staticmethod
    def _hub_scan(hub_path: Path, hub_manager):
        """Scan for new projects"""
        if not hub_path:
            print("âŒ No hub configured. Run: scf hub create")
            return

        registry_dir = hub_path / '.scf-registry'
        hub_manager._discover_existing_projects(hub_path, registry_dir)

    @staticmethod
    def _hub_learn(hub_path: Path, hub_manager, args):
        """Gather learnings from spokes"""
        if not hub_path:
            print("âŒ No hub configured. Run: scf hub create")
            return

        target = args.target if hasattr(args, 'target') and args.target else None

        print(f"ğŸ§  Learning from {'project: ' + target if target else 'all spokes'}...")

        registry_path = hub_path / '.scf-registry' / 'spoke-projects.json'
        if not registry_path.exists():
            print("âŒ No projects registered")
            return

        with open(registry_path) as f:
            registry = json.load(f)

        projects = [p for p in registry.get('projects', []) if p.get('scf_enabled')]

        if target:
            projects = [p for p in projects if p['name'].lower() == target.lower()]
            if not projects:
                print(f"âŒ SCF-enabled project not found: {target}")
                return

        learnings_dir = hub_path / 'learnings'
        learnings_dir.mkdir(exist_ok=True)

        learned_count = 0
        for proj in projects:
            proj_path = Path(proj['path'])
            signals_path = proj_path / '.scf' / 'spoke-signals.jsonl'

            if not signals_path.exists():
                signals_path = proj_path / 'spoke-signals.jsonl'

            if signals_path.exists():
                print(f"   ğŸ“– Reading signals from {proj['name']}...")
                # Read and process signals
                # For now, just count them
                with open(signals_path) as f:
                    signals = []
                    for line in f:
                        if line.strip():
                            try:
                                signals.append(json.loads(line))
                            except json.JSONDecodeError:
                                pass  # Skip corrupt lines
                    high_impact = [s for s in signals if isinstance(s, dict) and s.get('offers')]
                    if high_impact:
                        learned_count += len(high_impact)
                        print(f"      Found {len(high_impact)} high-impact learnings")

        print(f"\nâœ… Gathered {learned_count} learnings from {len(projects)} projects")
        print(f"   ğŸ’¡ Run 'scf hub teach' to push learnings to other spokes")

    @staticmethod
    def _hub_teach(hub_path: Path, hub_manager, args):
        """Push learnings to spokes"""
        if not hub_path:
            print("âŒ No hub configured. Run: scf hub create")
            return

        target = args.target if hasattr(args, 'target') and args.target else None

        print(f"ğŸ“š Teaching {'project: ' + target if target else 'all spokes'}...")

        registry_path = hub_path / '.scf-registry' / 'spoke-projects.json'
        if not registry_path.exists():
            print("âŒ No projects registered")
            return

        with open(registry_path) as f:
            registry = json.load(f)

        projects = [p for p in registry.get('projects', []) if p.get('scf_enabled')]

        if target:
            projects = [p for p in projects if p['name'].lower() == target.lower()]
            if not projects:
                print(f"âŒ SCF-enabled project not found: {target}")
                return

        taught_count = 0
        for proj in projects:
            proj_path = Path(proj['path'])
            print(f"   ğŸ“ Updating {proj['name']}...")

            # Update kb-sync.json
            kb_sync_path = proj_path / '.scf' / 'kb-sync.json'
            if kb_sync_path.exists():
                try:
                    with open(kb_sync_path) as f:
                        kb_sync = json.load(f)
                    kb_sync['last_sync_date'] = datetime.now(timezone.utc).isoformat()
                    kb_sync['hub_kb_version'] = datetime.now(timezone.utc).isoformat()
                    with open(kb_sync_path, 'w') as f:
                        json.dump(kb_sync, f, indent=2)
                    taught_count += 1
                except:
                    pass

            # Update last_sync in registry
            proj['last_sync'] = datetime.now(timezone.utc).isoformat()

        # Save registry
        with open(registry_path, 'w') as f:
            json.dump(registry, f, indent=2)

        print(f"\nâœ… Updated {taught_count} projects")

    @staticmethod
    def cmd_server(args):
        """Start/stop/status local SCF server"""
        try:
            from scf_local_server import SCFLocalServer
        except ImportError:
            print("âŒ Server module not available")
            return

        if args.action == "start":
            print("ğŸŒ Starting SCF local server...")
            server = SCFLocalServer(port=args.port)
            print(f"âœ… Server running on http://localhost:{args.port}")

        elif args.action == "stop":
            print("ğŸ›‘ Stopping SCF server...")

        elif args.action == "status":
            print("ğŸ“Š Server status: checking...")

    @staticmethod
    def cmd_projects(args):
        """Project discovery and management (hub features)"""
        if args.action == "scan":
            print("ğŸ” Scanning for SCF projects...")
            try:
                hunter_main()
            except:
                print("   Scanning current directory tree...")

        elif args.action == "health":
            print("ğŸ¥ Project health overview:")
            # Show health dashboard

        elif args.action == "learn":
            print("ğŸ§  Learning from project patterns...")


def create_parser():
    """Create the unified argument parser"""
    parser = argparse.ArgumentParser(
        description="SCF - Session Continuity Framework",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  scf init                    # Initialize current directory as SCF project
  scf init --guided           # Guided setup with foundation questions
  scf hub create              # Create your personal hub
  scf hub create ~/my-hub     # Create hub at specific location
  scf sync                    # Sync current project with hub
  scf sync --status           # Check sync status
  scf projects scan           # Discover projects

For more help: scf <command> --help
        """
    )

    parser.add_argument('--verbose', '-v', action='store_true', help='Verbose output')

    # Subcommands
    subparsers = parser.add_subparsers(dest='command', help='Available commands')

    # Init command
    init_parser = subparsers.add_parser('init', help='Initialize SCF in project')
    init_parser.add_argument('path', nargs='?', default='.', help='Project path (default: current directory)')
    init_parser.add_argument('--hub', action='store_true', help='[Deprecated] Use "scf hub create" instead')
    init_parser.add_argument('--guided', '-g', action='store_true', help='Guided setup with foundation questions')
    init_parser.add_argument('--fresh', action='store_true', help='Reset existing SCF files')

    # Hub command
    hub_parser = subparsers.add_parser('hub', help='Hub management (run "scf hub" for full help)')
    hub_parser.add_argument('action', nargs='?', choices=['create', 'locate', 'status', 'stats', 'projects', 'scan', 'learn', 'teach', 'help'],
                           help='Hub action')
    hub_parser.add_argument('target', nargs='?', help='Target project for learn/teach')
    hub_parser.add_argument('path', nargs='?', help='Hub path for create (default: ~/scf-hub)')
    hub_parser.add_argument('--non-interactive', action='store_true', help='Skip interactive prompts')
    hub_parser.add_argument('--add', metavar='PATH', help='Add project to hub')
    hub_parser.add_argument('--remove', metavar='NAME', help='Remove project from hub')
    hub_parser.add_argument('--info', metavar='NAME', help='Show project details')

    # Sync command
    sync_parser = subparsers.add_parser('sync', help='Sync with hub or check status')
    sync_parser.add_argument('path', nargs='?', help='Project path (default: current directory)')
    sync_parser.add_argument('--status', action='store_true', help='Check sync status only')

    # Server command
    server_parser = subparsers.add_parser('server', help='Local server management')
    server_parser.add_argument('action', choices=['start', 'stop', 'status'], help='Server action')
    server_parser.add_argument('--port', type=int, default=8765, help='Server port (default: 8765)')

    # Projects command (hub features)
    projects_parser = subparsers.add_parser('projects', help='Project discovery and management')
    projects_parser.add_argument('action', choices=['scan', 'health', 'learn'], help='Projects action')

    return parser


def main():
    """Main entry point for unified SCF CLI"""
    parser = create_parser()

    # If no arguments, show onboarding
    if len(sys.argv) == 1:
        onboarding = SCFOnboarding()
        onboarding.show_welcome()
        role = onboarding.choose_role()

        if role == "hub":
            print("\nğŸ—ï¸  Let's set up your SCF Hub:")
            print("Run: scf hub create")
        else:
            print(f"\nğŸ’» Let's add SCF to your current project:")
            print("Run: scf init --guided")
        return

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        return

    # Route to appropriate command
    try:
        if args.command == 'init':
            SCFCommands.cmd_init(args)
        elif args.command == 'hub':
            SCFCommands.cmd_hub(args)
        elif args.command == 'sync':
            SCFCommands.cmd_sync(args)
        elif args.command == 'server':
            SCFCommands.cmd_server(args)
        elif args.command == 'projects':
            SCFCommands.cmd_projects(args)
        else:
            parser.print_help()

    except KeyboardInterrupt:
        print("\n\nâš ï¸  Operation cancelled by user")
    except Exception as e:
        if hasattr(args, 'verbose') and args.verbose:
            import traceback
            traceback.print_exc()
        else:
            print(f"âŒ Error: {e}")
            print("Use --verbose for detailed error info")


if __name__ == '__main__':
    main()
