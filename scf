#!/usr/bin/env python3
"""
SCF - Session Continuity Framework
Unified Command Line Interface

This replaces the 25+ separate Python scripts with a single, intuitive entry point.
Provides role-based onboarding and progressive complexity disclosure.
"""

import argparse
import sys
import json
import shutil
from pathlib import Path
from typing import Optional
from datetime import datetime, timezone

# Import existing SCF modules
try:
    from teach import main as teach_main, init_project, update_project
    from scf_enhanced_overview import generate_enhanced_overview
    from buildstate_hunter_learner import main as hunter_main
    from scf_sync_checker import check_sync_status
except ImportError as e:
    # Allow partial imports for hub-only operations
    pass

class SCFOnboarding:
    """Handles user onboarding and role selection"""

    def show_welcome(self):
        """Display welcome message and explain SCF concept"""
        print("""
üöÄ Welcome to Session Continuity Framework (SCF)

SCF gives your AI assistants perfect memory across all your development sessions.
Never lose context, never repeat explanations, always stay in flow.

Choose your role:
""")

    def choose_role(self) -> str:
        """Let user choose between hub and spoke modes"""
        print("1. üìä Project Manager (Hub) - Manage multiple projects from one central location")
        print("2. üíª Solo Developer (Spoke) - Add AI memory to a single project")
        print("3. ‚ùì Learn More - Understand the difference")

        while True:
            choice = input("\nEnter your choice (1/2/3): ").strip()
            if choice == "1":
                return "hub"
            elif choice == "2":
                return "spoke"
            elif choice == "3":
                self.explain_hub_spoke()
            else:
                print("Please enter 1, 2, or 3")

    def explain_hub_spoke(self):
        """Explain hub vs spoke concept clearly"""
        print("""
üèóÔ∏è  Hub vs Spoke - Simple Explanation:

üéØ SPOKE MODE (Solo Developer):
   - You work on ONE project
   - SCF adds "memory" to that project
   - AI assistants remember all your conversations
   - Perfect for: Individual projects, focused development

üìä HUB MODE (Project Manager):
   - You manage MULTIPLE projects
   - Central dashboard shows all project health
   - Share learnings between projects
   - Perfect for: Teams, consultants, multiple client projects

Most people start with SPOKE mode for their current project.
""")


class SCFHubManager:
    """Manages SCF Hub creation and configuration"""

    def __init__(self, framework_path: Path):
        self.framework_path = framework_path
        self.templates_dir = framework_path / 'templates' / 'hub'

    def create_hub(self, hub_path: Path, interactive: bool = True) -> bool:
        """Create a new SCF hub at the specified location"""
        hub_path = hub_path.expanduser().resolve()

        print(f"\nüèóÔ∏è  Creating SCF Hub at: {hub_path}\n")

        # Create hub directory
        hub_path.mkdir(parents=True, exist_ok=True)

        # Create .scf directory (hub is also a spoke tracking itself)
        scf_dir = hub_path / '.scf'
        scf_dir.mkdir(exist_ok=True)

        # Create .scf-registry directory
        registry_dir = hub_path / '.scf-registry'
        registry_dir.mkdir(exist_ok=True)
        (registry_dir / 'spokes').mkdir(exist_ok=True)

        # Gather user info if interactive
        user_info = {}
        if interactive:
            user_info = self._gather_user_info()

        # Create hub-profile.json
        self._create_hub_profile(hub_path, user_info)

        # Create spoke-projects.json
        self._create_spoke_registry(registry_dir)

        # Create hub's own buildstate (it's a spoke tracking itself)
        self._create_hub_buildstate(scf_dir, hub_path)

        # Create learnings directory
        learnings_dir = hub_path / 'learnings'
        learnings_dir.mkdir(exist_ok=True)

        print(f"\n‚úÖ Hub created successfully at: {hub_path}")
        print(f"\nüìÅ Structure created:")
        print(f"   {hub_path}/")
        print(f"   ‚îú‚îÄ‚îÄ .scf/                  # Hub's own buildstate")
        print(f"   ‚îú‚îÄ‚îÄ .scf-registry/         # Project registry")
        print(f"   ‚îÇ   ‚îú‚îÄ‚îÄ spokes/            # Individual spoke tracking")
        print(f"   ‚îÇ   ‚îî‚îÄ‚îÄ spoke-projects.json")
        print(f"   ‚îú‚îÄ‚îÄ hub-profile.json       # Your preferences")
        print(f"   ‚îî‚îÄ‚îÄ learnings/             # Cross-project patterns")

        # Discover existing projects
        if interactive:
            self._discover_existing_projects(hub_path, registry_dir)

        print(f"\nüöÄ Next steps:")
        print(f"   1. Run 'scf hub status' to see connected projects")
        print(f"   2. Run 'scf init <path>' to add more projects")

        return True

    def _discover_existing_projects(self, hub_path: Path, registry_dir: Path):
        """Interactively discover and intake existing projects"""
        print(f"\nüìÇ Project Discovery")
        print(f"=" * 50)

        discover = input("\nDo you have existing projects to discover? [Y/n]: ").strip().lower()
        if discover == 'n':
            print("   Skipping project discovery.")
            return

        # Get scan locations
        scan_paths = []
        print("\nEnter directories to scan for projects (one per line).")
        print("Common locations: ~/projects, ~/code, ~/work")
        print("Press Enter with empty line when done.\n")

        while True:
            path_input = input("   Scan path: ").strip()
            if not path_input:
                break
            scan_path = Path(path_input).expanduser()
            if scan_path.exists() and scan_path.is_dir():
                scan_paths.append(scan_path)
                print(f"   ‚úì Added: {scan_path}")
            else:
                print(f"   ‚úó Path not found: {scan_path}")

        if not scan_paths:
            # Default to common locations
            default_paths = [Path.home() / 'projects', Path.home() / 'code']
            for dp in default_paths:
                if dp.exists():
                    scan_paths.append(dp)
            if scan_paths:
                print(f"\n   Using default paths: {', '.join(str(p) for p in scan_paths)}")

        if not scan_paths:
            print("   No valid paths to scan.")
            return

        # Scan for projects
        print(f"\nüîç Scanning for projects...")
        discovered = self._scan_for_projects(scan_paths)

        if not discovered:
            print("   No projects found.")
            return

        # Separate SCF-enabled from regular projects
        scf_projects = [p for p in discovered if p.get('scf_enabled')]
        regular_projects = [p for p in discovered if not p.get('scf_enabled')]

        print(f"\nüìä Found {len(discovered)} projects:")
        print(f"   ‚Ä¢ {len(scf_projects)} SCF-enabled (have .scf/ folder)")
        print(f"   ‚Ä¢ {len(regular_projects)} regular projects")

        # Present SCF-enabled projects first
        if scf_projects:
            print(f"\nüåü SCF-Enabled Projects (already have context):")
            print("-" * 50)
            for proj in scf_projects:
                self._present_project(proj, is_scf=True)

        # Present regular projects
        if regular_projects:
            print(f"\nüìÅ Regular Projects (can add SCF):")
            print("-" * 50)
            for proj in regular_projects:
                self._present_project(proj, is_scf=False)

        # Let user select which to intake
        print(f"\nüì• Project Intake")
        print("-" * 50)
        print("For each project, choose: [Y]es intake, [N]o skip, [A]ll remaining, [Q]uit\n")

        intake_list = []
        skip_remaining = False
        intake_remaining = False

        for proj in discovered:
            if skip_remaining:
                break
            if intake_remaining:
                intake_list.append(proj)
                continue

            status = "üåü SCF" if proj.get('scf_enabled') else "üìÅ New"
            print(f"{status} {proj['name']}")
            if proj.get('scf_enabled') and proj.get('description'):
                print(f"      ‚îî‚îÄ {proj['description'][:60]}...")

            choice = input(f"   Intake? [Y/n/a/q]: ").strip().lower()

            if choice == 'q':
                skip_remaining = True
            elif choice == 'a':
                intake_remaining = True
                intake_list.append(proj)
            elif choice != 'n':
                intake_list.append(proj)

        # Register selected projects
        if intake_list:
            self._register_projects(registry_dir, intake_list, hub_path)
            print(f"\n‚úÖ Registered {len(intake_list)} projects with hub")
        else:
            print("\n   No projects selected for intake.")

    def _scan_for_projects(self, scan_paths: list) -> list:
        """Scan directories for projects (looks for git repos or common project markers)"""
        discovered = []
        seen_paths = set()

        for scan_path in scan_paths:
            # Look for immediate subdirectories that look like projects
            try:
                for item in scan_path.iterdir():
                    if not item.is_dir():
                        continue
                    if item.name.startswith('.'):
                        continue
                    if str(item.resolve()) in seen_paths:
                        continue

                    # Check if it's a project
                    is_git = (item / '.git').exists()
                    is_scf = (item / '.scf').exists() or (item / 'buildstate.json').exists()
                    has_package = (item / 'package.json').exists()
                    has_pyproject = (item / 'pyproject.toml').exists() or (item / 'setup.py').exists()
                    has_cargo = (item / 'Cargo.toml').exists()

                    if is_git or is_scf or has_package or has_pyproject or has_cargo:
                        proj_info = {
                            'name': item.name,
                            'path': str(item.resolve()),
                            'scf_enabled': is_scf,
                            'has_git': is_git,
                            'description': None,
                            'project_type': None
                        }

                        # If SCF-enabled, read additional details
                        if is_scf:
                            proj_info.update(self._read_scf_details(item))

                        discovered.append(proj_info)
                        seen_paths.add(str(item.resolve()))

            except PermissionError:
                continue

        return sorted(discovered, key=lambda x: (not x['scf_enabled'], x['name'].lower()))

    def _read_scf_details(self, project_path: Path) -> dict:
        """Read details from SCF-enabled project"""
        details = {}

        # Try .scf/BUILDSTATE.json first, then buildstate.json
        buildstate_paths = [
            project_path / '.scf' / 'BUILDSTATE.json',
            project_path / 'buildstate.json'
        ]

        for bs_path in buildstate_paths:
            if bs_path.exists():
                try:
                    with open(bs_path) as f:
                        data = json.load(f)

                    # Extract useful info
                    if 'project' in data:
                        details['description'] = data['project'].get('description')
                        details['project_type'] = data['project'].get('type')

                    if '_project_foundation' in data:
                        foundation = data['_project_foundation']
                        if foundation.get('identity'):
                            details['description'] = details.get('description') or foundation['identity'].get('one_liner')
                            details['project_type'] = details.get('project_type') or foundation['identity'].get('type')

                    if '_scf_metadata' in data:
                        details['scf_version'] = data['_scf_metadata'].get('version')
                        details['hub_path'] = data['_scf_metadata'].get('hub_path')

                    break
                except (json.JSONDecodeError, KeyError):
                    pass

        return details

    def _present_project(self, proj: dict, is_scf: bool):
        """Display project info"""
        print(f"\n   üì¶ {proj['name']}")
        print(f"      Path: {proj['path']}")
        if is_scf:
            if proj.get('description'):
                print(f"      Desc: {proj['description']}")
            if proj.get('project_type'):
                print(f"      Type: {proj['project_type']}")
            if proj.get('scf_version'):
                print(f"      SCF:  v{proj['scf_version']}")
        else:
            markers = []
            if proj.get('has_git'):
                markers.append('git')
            print(f"      Markers: {', '.join(markers) if markers else 'directory'}")

    def _register_projects(self, registry_dir: Path, projects: list, hub_path: Path):
        """Register projects in the spoke registry"""
        registry_path = registry_dir / 'spoke-projects.json'

        # Load existing registry
        if registry_path.exists():
            with open(registry_path) as f:
                registry = json.load(f)
        else:
            registry = {"version": "1.0", "projects": [], "last_scan": None}

        # Add projects
        existing_paths = {p.get('path') for p in registry.get('projects', [])}

        for proj in projects:
            if proj['path'] not in existing_paths:
                registry['projects'].append({
                    'name': proj['name'],
                    'path': proj['path'],
                    'type': proj.get('project_type', 'unknown'),
                    'scf_enabled': proj.get('scf_enabled', False),
                    'added_at': datetime.now(timezone.utc).isoformat(),
                    'last_sync': None
                })

                # Update spoke's hub_path if SCF-enabled
                if proj.get('scf_enabled'):
                    self._update_spoke_hub_path(Path(proj['path']), hub_path)

        registry['last_scan'] = datetime.now(timezone.utc).isoformat()

        with open(registry_path, 'w') as f:
            json.dump(registry, f, indent=2)

    def _update_spoke_hub_path(self, project_path: Path, hub_path: Path):
        """Update a spoke's hub_path to point to this hub"""
        buildstate_paths = [
            project_path / '.scf' / 'BUILDSTATE.json',
            project_path / 'buildstate.json'
        ]

        for bs_path in buildstate_paths:
            if bs_path.exists():
                try:
                    with open(bs_path) as f:
                        data = json.load(f)

                    if '_scf_metadata' in data:
                        data['_scf_metadata']['hub_path'] = str(hub_path)

                        with open(bs_path, 'w') as f:
                            json.dump(data, f, indent=2)
                        break
                except (json.JSONDecodeError, KeyError):
                    pass

    def _gather_user_info(self) -> dict:
        """Interactive user info gathering"""
        print("üìã Let's personalize your hub:\n")

        name = input("   What name should AI partners call you? ").strip()

        print("\n   What's your primary development focus?")
        print("   (e.g., 'Full-stack web, Python automation')")
        focus = input("   > ").strip()

        print("\n   How do you prefer AI collaboration?")
        print("   [1] Autonomous - Take initiative, check in on big decisions")
        print("   [2] Collaborative - Discuss approach before implementing")
        print("   [3] Supervised - Always ask before acting")

        while True:
            style_choice = input("   > ").strip()
            if style_choice == "1":
                style = "autonomous"
                break
            elif style_choice == "2":
                style = "collaborative"
                break
            elif style_choice == "3":
                style = "supervised"
                break
            else:
                print("   Please enter 1, 2, or 3")

        return {
            'name': name,
            'focus': focus,
            'style': style
        }

    def _create_hub_profile(self, hub_path: Path, user_info: dict):
        """Create hub-profile.json with user info"""
        profile_template = self.templates_dir / 'hub-profile.json'

        if profile_template.exists():
            with open(profile_template) as f:
                profile = json.load(f)
        else:
            profile = {
                "user": {"name": None},
                "work_style": {"description": None},
                "hub_config": {}
            }

        # Fill in user info
        profile['user']['name'] = user_info.get('name', 'Developer')
        profile['work_style']['description'] = user_info.get('focus', '')
        profile['work_style']['ai_collaboration_style'] = user_info.get('style', 'collaborative')
        profile['hub_config']['created_at'] = datetime.now(timezone.utc).isoformat()
        profile['hub_config']['hub_path'] = str(hub_path)
        profile['hub_config']['framework_path'] = str(self.framework_path)

        profile_path = hub_path / 'hub-profile.json'
        with open(profile_path, 'w') as f:
            json.dump(profile, f, indent=2)

        print(f"   ‚úÖ Created hub-profile.json")

    def _create_spoke_registry(self, registry_dir: Path):
        """Create spoke-projects.json registry"""
        registry_template = self.templates_dir / 'spoke-projects.json'

        if registry_template.exists():
            shutil.copy2(registry_template, registry_dir / 'spoke-projects.json')
        else:
            registry = {
                "version": "1.0",
                "projects": [],
                "last_scan": None
            }
            with open(registry_dir / 'spoke-projects.json', 'w') as f:
                json.dump(registry, f, indent=2)

        print(f"   ‚úÖ Created spoke registry")

    def _create_hub_buildstate(self, scf_dir: Path, hub_path: Path):
        """Create hub's own buildstate (hub tracks itself as a spoke)"""
        buildstate = {
            "_scf_metadata": {
                "version": "2.2.0",
                "structure_version": "v2",
                "description": "SCF Hub - Your personal learning center",
                "is_hub": True,
                "hub_path": str(hub_path)
            },
            "_project_foundation": {
                "completed": True,
                "completed_at": datetime.now(timezone.utc).isoformat(),
                "identity": {
                    "type": "hub",
                    "name": "SCF Hub",
                    "one_liner": "Central hub for cross-project learnings",
                    "success_looks_like": "All projects connected, learnings flowing"
                },
                "boundaries": {
                    "in_scope": ["User preferences", "Project registry", "Cross-project learnings"],
                    "out_of_scope": ["Individual project code", "Framework development"]
                }
            },
            "_session_state": {
                "last_modified_by": "scf hub create",
                "last_modified_at": datetime.now(timezone.utc).isoformat(),
                "session_count": 1
            },
            "project": {
                "name": "SCF Hub",
                "type": "hub",
                "created": datetime.now(timezone.utc).isoformat()
            }
        }

        with open(scf_dir / 'BUILDSTATE.json', 'w') as f:
            json.dump(buildstate, f, indent=2)

        print(f"   ‚úÖ Created hub buildstate")

    @staticmethod
    def find_hub() -> Optional[Path]:
        """Find existing hub location"""
        # Check common locations
        common_paths = [
            Path.home() / 'scf-hub',
            Path.home() / '.scf-hub',
            Path.home() / 'projects' / 'scf-hub'
        ]

        for path in common_paths:
            if (path / 'hub-profile.json').exists():
                return path

        # Check environment variable
        import os
        env_hub = os.environ.get('SCF_HUB_PATH')
        if env_hub:
            env_path = Path(env_hub).expanduser()
            if env_path.exists():
                return env_path

        return None


class SCFCommands:
    """Main SCF command implementations"""

    @staticmethod
    def cmd_init(args):
        """Initialize SCF in a project (spoke mode) or setup hub"""
        project_path = Path(args.path).resolve()

        if args.hub:
            print("üèóÔ∏è  Setting up SCF Hub...")
            print("Use 'scf hub create' for guided hub setup.")
        elif args.guided:
            SCFCommands._guided_init(project_path, args)
        else:
            print(f"üöÄ Initializing SCF in: {project_path.name}")
            # Use existing teach.py init logic
            hub_path = Path(__file__).parent.resolve()
            init_project(project_path, hub_path, args.verbose)

    @staticmethod
    def _guided_init(project_path: Path, args):
        """Guided initialization with foundation questions"""
        print(f"\nüöÄ Guided SCF Setup for: {project_path.name}\n")
        print("Let's establish your project foundation.\n")

        # Gather foundation info
        print("üìã Project Identity:\n")

        name = input("   Project name: ").strip() or project_path.name

        print("\n   What type of project is this?")
        print("   [1] Code - Software development")
        print("   [2] Research - Investigation, analysis")
        print("   [3] Writing - Documentation, content")
        print("   [4] Design - UI/UX, architecture")
        print("   [5] Hybrid - Mix of above")

        type_map = {'1': 'code', '2': 'research', '3': 'writing', '4': 'design', '5': 'hybrid'}
        while True:
            type_choice = input("   > ").strip()
            if type_choice in type_map:
                project_type = type_map[type_choice]
                break
            print("   Please enter 1-5")

        one_liner = input("\n   One-sentence description: ").strip()
        success = input("   What does 'done' look like? ").strip()

        print("\nüìã Boundaries:\n")
        in_scope = input("   What's IN scope? (comma-separated): ").strip()
        out_scope = input("   What's OUT of scope? (comma-separated): ").strip()

        print("\nüìã AI Collaboration:\n")
        print("   How should AI work with you?")
        print("   [1] Autonomous - Take initiative")
        print("   [2] Collaborative - Discuss first")
        print("   [3] Supervised - Always ask")

        style_map = {'1': 'autonomous', '2': 'collaborative', '3': 'supervised'}
        while True:
            style_choice = input("   > ").strip()
            if style_choice in style_map:
                ai_style = style_map[style_choice]
                break
            print("   Please enter 1-3")

        # Initialize with foundation
        hub_path = Path(__file__).parent.resolve()
        init_project(project_path, hub_path, args.verbose)

        # Update buildstate with foundation
        scf_dir = project_path / '.scf'
        buildstate_path = scf_dir / 'BUILDSTATE.json'

        if buildstate_path.exists():
            with open(buildstate_path) as f:
                buildstate = json.load(f)
        else:
            buildstate = {}

        # Add foundation
        buildstate['_project_foundation'] = {
            "completed": True,
            "completed_at": datetime.now(timezone.utc).isoformat(),
            "completed_with": "scf init --guided",
            "identity": {
                "type": project_type,
                "name": name,
                "one_liner": one_liner,
                "success_looks_like": success
            },
            "boundaries": {
                "in_scope": [s.strip() for s in in_scope.split(',') if s.strip()],
                "out_of_scope": [s.strip() for s in out_scope.split(',') if s.strip()],
                "constraints": []
            },
            "approach": {
                "ai_collaboration_style": ai_style
            },
            "philosophy": {
                "core_principle": "AI as responsible partner, not just enabler",
                "behaviors": [
                    "Detect scope drift and flag before enabling",
                    "Require explicit acknowledgment for direction changes"
                ]
            },
            "evolution_log": [{
                "date": datetime.now().strftime("%Y-%m-%d"),
                "change": "Project foundation established",
                "acknowledged_by": "User via guided setup",
                "ai_partner": "scf CLI"
            }]
        }

        # Update project info
        buildstate['project'] = {
            "name": name,
            "type": project_type,
            "description": one_liner
        }

        with open(buildstate_path, 'w') as f:
            json.dump(buildstate, f, indent=2)

        print(f"\n‚úÖ Project foundation established!")
        print(f"   AI assistants will now work within your defined boundaries.")

    @staticmethod
    def cmd_sync(args):
        """Sync project with hub or check sync status"""
        project_path = Path(args.path or ".").resolve()

        if args.status:
            print(f"üîç Checking sync status for: {project_path.name}")
            check_sync_status(project_path)
        else:
            print(f"üîÑ Syncing {project_path.name} with hub...")
            hub_path = Path(__file__).parent.resolve()
            update_project(project_path, hub_path, args.verbose)

    @staticmethod
    def cmd_hub(args):
        """Hub management commands"""
        framework_path = Path(__file__).parent.resolve()
        hub_manager = SCFHubManager(framework_path)

        # Find hub for most operations
        hub_path = hub_manager.find_hub()

        if args.action == "help" or args.action is None:
            SCFCommands._hub_help()

        elif args.action == "create":
            create_path = Path(args.path or "~/scf-hub").expanduser()
            hub_manager.create_hub(create_path, interactive=not args.non_interactive)

        elif args.action == "locate":
            if hub_path:
                print(f"‚úÖ Hub found at: {hub_path}")
            else:
                print("‚ùå No hub found.")
                print("\nTo create a hub, run: scf hub create")

        elif args.action == "status":
            SCFCommands._hub_status(hub_path)

        elif args.action == "stats":
            SCFCommands._hub_stats(hub_path, hub_manager)

        elif args.action == "projects":
            SCFCommands._hub_projects(hub_path, args)

        elif args.action == "learn":
            SCFCommands._hub_learn(hub_path, hub_manager, args)

        elif args.action == "teach":
            SCFCommands._hub_teach(hub_path, hub_manager, args)

        elif args.action == "scan":
            SCFCommands._hub_scan(hub_path, hub_manager)

    @staticmethod
    def _hub_help():
        """Show hub-specific help"""
        print("""
üìä SCF Hub Commands
==================

  scf hub status              Show hub status and health
  scf hub stats               Detailed statistics on projects and learnings
  scf hub locate              Find hub location

Project Management:
  scf hub projects            List all registered projects
  scf hub projects --add <path>       Add a project to hub
  scf hub projects --remove <name>    Remove a project from hub
  scf hub projects --info <name>      Show project details
  scf hub scan                Scan directories for new projects

Learning & Teaching:
  scf hub learn               Gather learnings from all spokes
  scf hub learn <project>     Learn from specific project
  scf hub teach               Push learnings to all spokes
  scf hub teach <project>     Teach specific project

Setup:
  scf hub create              Create a new hub (interactive)
  scf hub create <path>       Create hub at specific location

Examples:
  scf hub projects --add ~/projects/my-app
  scf hub learn session-continuity-framework
  scf hub teach --all
""")

    @staticmethod
    def _hub_status(hub_path: Path):
        """Show hub status"""
        if not hub_path:
            print("‚ùå No hub configured. Run: scf hub create")
            return

        print(f"üìä Hub Status")
        print("=" * 50)
        print(f"\nüìç Location: {hub_path}\n")

        # Show hub info
        profile_path = hub_path / 'hub-profile.json'
        if profile_path.exists():
            with open(profile_path) as f:
                profile = json.load(f)
            print(f"üë§ User: {profile.get('user', {}).get('name', 'Unknown')}")
            print(f"üíº Focus: {profile.get('work_style', {}).get('description', 'Not set')}")
            print(f"ü§ñ AI Style: {profile.get('work_style', {}).get('ai_collaboration_style', 'collaborative')}")
            created = profile.get('hub_config', {}).get('created_at', 'Unknown')
            if created != 'Unknown':
                created = created.split('T')[0]
            print(f"üìÖ Created: {created}")

        # Count and list projects
        registry_path = hub_path / '.scf-registry' / 'spoke-projects.json'
        if registry_path.exists():
            with open(registry_path) as f:
                registry = json.load(f)
            projects = registry.get('projects', [])
            scf_enabled = sum(1 for p in projects if p.get('scf_enabled'))
            print(f"\nüìÅ Projects: {len(projects)} total ({scf_enabled} SCF-enabled)")

            if projects:
                print("\n   Recent projects:")
                for proj in projects[:5]:
                    status = "üåü" if proj.get('scf_enabled') else "üìÅ"
                    print(f"   {status} {proj['name']}")
                if len(projects) > 5:
                    print(f"   ... and {len(projects) - 5} more")

        # Check learnings
        learnings_dir = hub_path / 'learnings'
        if learnings_dir.exists():
            learning_files = list(learnings_dir.glob('*.json'))
            print(f"\nüß† Learnings: {len(learning_files)} patterns stored")

        print(f"\nüí° Run 'scf hub stats' for detailed statistics")

    @staticmethod
    def _hub_stats(hub_path: Path, hub_manager):
        """Show detailed hub statistics"""
        if not hub_path:
            print("‚ùå No hub configured. Run: scf hub create")
            return

        print(f"üìä Hub Statistics")
        print("=" * 50)

        registry_path = hub_path / '.scf-registry' / 'spoke-projects.json'
        if not registry_path.exists():
            print("\n‚ùå No project registry found")
            return

        with open(registry_path) as f:
            registry = json.load(f)

        projects = registry.get('projects', [])
        scf_enabled = [p for p in projects if p.get('scf_enabled')]
        regular = [p for p in projects if not p.get('scf_enabled')]

        print(f"\nüìÅ Projects Overview")
        print(f"   Total registered: {len(projects)}")
        print(f"   SCF-enabled:      {len(scf_enabled)}")
        print(f"   Regular:          {len(regular)}")

        # Sync status
        needs_sync = []
        never_synced = []
        for proj in projects:
            if proj.get('scf_enabled'):
                if not proj.get('last_sync'):
                    never_synced.append(proj['name'])
                # Could check actual sync dates here

        if never_synced:
            print(f"\n‚ö†Ô∏è  Never synced: {len(never_synced)} projects")
            for name in never_synced[:3]:
                print(f"      ‚Ä¢ {name}")

        # Learnings stats
        learnings_dir = hub_path / 'learnings'
        print(f"\nüß† Learnings")
        if learnings_dir.exists():
            learning_files = list(learnings_dir.glob('*.json'))
            print(f"   Patterns stored: {len(learning_files)}")
        else:
            print(f"   Patterns stored: 0")
            print(f"   üí° Run 'scf hub learn' to gather learnings from spokes")

        # Recommendations
        print(f"\nüí° Recommendations")
        if regular:
            print(f"   ‚Ä¢ {len(regular)} projects could be SCF-enabled")
        if never_synced:
            print(f"   ‚Ä¢ {len(never_synced)} projects need initial sync")
        if not scf_enabled:
            print(f"   ‚Ä¢ Run 'scf hub scan' to discover more projects")

    @staticmethod
    def _hub_projects(hub_path: Path, args):
        """List and manage hub projects"""
        if not hub_path:
            print("‚ùå No hub configured. Run: scf hub create")
            return

        registry_path = hub_path / '.scf-registry' / 'spoke-projects.json'

        # Handle --add
        if args.add:
            SCFCommands._hub_projects_add(hub_path, registry_path, args.add)
            return

        # Handle --remove
        if args.remove:
            SCFCommands._hub_projects_remove(registry_path, args.remove)
            return

        # Handle --info
        if args.info:
            SCFCommands._hub_projects_info(registry_path, args.info)
            return

        # Default: list all projects
        if not registry_path.exists():
            print("üìÅ No projects registered yet")
            print("   Run 'scf hub scan' to discover projects")
            return

        with open(registry_path) as f:
            registry = json.load(f)

        projects = registry.get('projects', [])
        if not projects:
            print("üìÅ No projects registered yet")
            return

        print(f"üìÅ Registered Projects ({len(projects)})")
        print("=" * 50)

        for proj in sorted(projects, key=lambda x: x['name'].lower()):
            status = "üåü" if proj.get('scf_enabled') else "üìÅ"
            sync = proj.get('last_sync', 'never')
            if sync != 'never':
                sync = sync.split('T')[0]
            print(f"\n{status} {proj['name']}")
            print(f"   Path: {proj['path']}")
            print(f"   Type: {proj.get('type', 'unknown')}")
            print(f"   Last sync: {sync}")

    @staticmethod
    def _hub_projects_add(hub_path: Path, registry_path: Path, project_path: str):
        """Add a project to the hub"""
        proj_path = Path(project_path).expanduser().resolve()

        if not proj_path.exists():
            print(f"‚ùå Path not found: {proj_path}")
            return

        # Load or create registry
        if registry_path.exists():
            with open(registry_path) as f:
                registry = json.load(f)
        else:
            registry = {"version": "1.0", "projects": []}

        # Check if already registered
        existing = {p['path'] for p in registry.get('projects', [])}
        if str(proj_path) in existing:
            print(f"‚ö†Ô∏è  Project already registered: {proj_path.name}")
            return

        # Detect project info
        is_scf = (proj_path / '.scf').exists() or (proj_path / 'buildstate.json').exists()

        proj_info = {
            'name': proj_path.name,
            'path': str(proj_path),
            'type': 'unknown',
            'scf_enabled': is_scf,
            'added_at': datetime.now(timezone.utc).isoformat(),
            'last_sync': None
        }

        # Read SCF details if available
        if is_scf:
            for bs_path in [proj_path / '.scf' / 'BUILDSTATE.json', proj_path / 'buildstate.json']:
                if bs_path.exists():
                    try:
                        with open(bs_path) as f:
                            data = json.load(f)
                        proj_info['type'] = data.get('project', {}).get('type', 'unknown')

                        # Update spoke's hub_path
                        if '_scf_metadata' in data:
                            data['_scf_metadata']['hub_path'] = str(hub_path)
                            with open(bs_path, 'w') as f:
                                json.dump(data, f, indent=2)
                        break
                    except:
                        pass

        registry['projects'].append(proj_info)

        with open(registry_path, 'w') as f:
            json.dump(registry, f, indent=2)

        status = "üåü SCF-enabled" if is_scf else "üìÅ Regular"
        print(f"‚úÖ Added: {proj_path.name} ({status})")

    @staticmethod
    def _hub_projects_remove(registry_path: Path, project_name: str):
        """Remove a project from the hub"""
        if not registry_path.exists():
            print("‚ùå No projects registered")
            return

        with open(registry_path) as f:
            registry = json.load(f)

        projects = registry.get('projects', [])
        original_count = len(projects)

        # Filter out the project (match by name or path)
        registry['projects'] = [
            p for p in projects
            if p['name'].lower() != project_name.lower() and
               not p['path'].endswith(project_name)
        ]

        if len(registry['projects']) == original_count:
            print(f"‚ùå Project not found: {project_name}")
            return

        with open(registry_path, 'w') as f:
            json.dump(registry, f, indent=2)

        print(f"‚úÖ Removed: {project_name}")

    @staticmethod
    def _hub_projects_info(registry_path: Path, project_name: str):
        """Show detailed project info"""
        if not registry_path.exists():
            print("‚ùå No projects registered")
            return

        with open(registry_path) as f:
            registry = json.load(f)

        # Find project
        proj = None
        for p in registry.get('projects', []):
            if p['name'].lower() == project_name.lower() or p['path'].endswith(project_name):
                proj = p
                break

        if not proj:
            print(f"‚ùå Project not found: {project_name}")
            return

        print(f"üì¶ Project: {proj['name']}")
        print("=" * 50)
        print(f"   Path:        {proj['path']}")
        print(f"   Type:        {proj.get('type', 'unknown')}")
        print(f"   SCF-enabled: {'Yes' if proj.get('scf_enabled') else 'No'}")
        print(f"   Added:       {proj.get('added_at', 'unknown').split('T')[0]}")
        print(f"   Last sync:   {proj.get('last_sync', 'never')}")

        # If SCF-enabled, read more details
        if proj.get('scf_enabled'):
            proj_path = Path(proj['path'])
            for bs_path in [proj_path / '.scf' / 'BUILDSTATE.json', proj_path / 'buildstate.json']:
                if bs_path.exists():
                    try:
                        with open(bs_path) as f:
                            data = json.load(f)

                        if '_project_foundation' in data:
                            foundation = data['_project_foundation']
                            if foundation.get('identity'):
                                print(f"\nüìã Foundation:")
                                print(f"   {foundation['identity'].get('one_liner', 'No description')}")

                        if 'features' in data and data['features']:
                            print(f"\n‚ú® Features: {len(data['features'])}")
                            for feat in data['features'][:3]:
                                print(f"   ‚Ä¢ {feat.get('name', 'unnamed')}")

                        if 'decisions' in data and data['decisions']:
                            print(f"\nüìù Decisions: {len(data['decisions'])}")

                        break
                    except:
                        pass

    @staticmethod
    def _hub_scan(hub_path: Path, hub_manager):
        """Scan for new projects"""
        if not hub_path:
            print("‚ùå No hub configured. Run: scf hub create")
            return

        registry_dir = hub_path / '.scf-registry'
        hub_manager._discover_existing_projects(hub_path, registry_dir)

    @staticmethod
    def _hub_learn(hub_path: Path, hub_manager, args):
        """Gather learnings from spokes"""
        if not hub_path:
            print("‚ùå No hub configured. Run: scf hub create")
            return

        target = args.target if hasattr(args, 'target') and args.target else None

        print(f"üß† Learning from {'project: ' + target if target else 'all spokes'}...")

        registry_path = hub_path / '.scf-registry' / 'spoke-projects.json'
        if not registry_path.exists():
            print("‚ùå No projects registered")
            return

        with open(registry_path) as f:
            registry = json.load(f)

        projects = [p for p in registry.get('projects', []) if p.get('scf_enabled')]

        if target:
            projects = [p for p in projects if p['name'].lower() == target.lower()]
            if not projects:
                print(f"‚ùå SCF-enabled project not found: {target}")
                return

        learnings_dir = hub_path / 'learnings'
        learnings_dir.mkdir(exist_ok=True)

        learned_count = 0
        for proj in projects:
            proj_path = Path(proj['path'])
            signals_path = proj_path / '.scf' / 'spoke-signals.jsonl'

            if not signals_path.exists():
                signals_path = proj_path / 'spoke-signals.jsonl'

            if signals_path.exists():
                print(f"   üìñ Reading signals from {proj['name']}...")
                # Read and process signals
                # For now, just count them
                with open(signals_path) as f:
                    signals = [json.loads(line) for line in f if line.strip()]
                    high_impact = [s for s in signals if s.get('offers')]
                    if high_impact:
                        learned_count += len(high_impact)
                        print(f"      Found {len(high_impact)} high-impact learnings")

        print(f"\n‚úÖ Gathered {learned_count} learnings from {len(projects)} projects")
        print(f"   üí° Run 'scf hub teach' to push learnings to other spokes")

    @staticmethod
    def _hub_teach(hub_path: Path, hub_manager, args):
        """Push learnings to spokes"""
        if not hub_path:
            print("‚ùå No hub configured. Run: scf hub create")
            return

        target = args.target if hasattr(args, 'target') and args.target else None

        print(f"üìö Teaching {'project: ' + target if target else 'all spokes'}...")

        registry_path = hub_path / '.scf-registry' / 'spoke-projects.json'
        if not registry_path.exists():
            print("‚ùå No projects registered")
            return

        with open(registry_path) as f:
            registry = json.load(f)

        projects = [p for p in registry.get('projects', []) if p.get('scf_enabled')]

        if target:
            projects = [p for p in projects if p['name'].lower() == target.lower()]
            if not projects:
                print(f"‚ùå SCF-enabled project not found: {target}")
                return

        taught_count = 0
        for proj in projects:
            proj_path = Path(proj['path'])
            print(f"   üìù Updating {proj['name']}...")

            # Update kb-sync.json
            kb_sync_path = proj_path / '.scf' / 'kb-sync.json'
            if kb_sync_path.exists():
                try:
                    with open(kb_sync_path) as f:
                        kb_sync = json.load(f)
                    kb_sync['last_sync_date'] = datetime.now(timezone.utc).isoformat()
                    kb_sync['hub_kb_version'] = datetime.now(timezone.utc).isoformat()
                    with open(kb_sync_path, 'w') as f:
                        json.dump(kb_sync, f, indent=2)
                    taught_count += 1
                except:
                    pass

            # Update last_sync in registry
            proj['last_sync'] = datetime.now(timezone.utc).isoformat()

        # Save registry
        with open(registry_path, 'w') as f:
            json.dump(registry, f, indent=2)

        print(f"\n‚úÖ Updated {taught_count} projects")

    @staticmethod
    def cmd_server(args):
        """Start/stop/status local SCF server"""
        try:
            from scf_local_server import SCFLocalServer
        except ImportError:
            print("‚ùå Server module not available")
            return

        if args.action == "start":
            print("üåê Starting SCF local server...")
            server = SCFLocalServer(port=args.port)
            print(f"‚úÖ Server running on http://localhost:{args.port}")

        elif args.action == "stop":
            print("üõë Stopping SCF server...")

        elif args.action == "status":
            print("üìä Server status: checking...")

    @staticmethod
    def cmd_projects(args):
        """Project discovery and management (hub features)"""
        if args.action == "scan":
            print("üîç Scanning for SCF projects...")
            try:
                hunter_main()
            except:
                print("   Scanning current directory tree...")

        elif args.action == "health":
            print("üè• Project health overview:")
            # Show health dashboard

        elif args.action == "learn":
            print("üß† Learning from project patterns...")


def create_parser():
    """Create the unified argument parser"""
    parser = argparse.ArgumentParser(
        description="SCF - Session Continuity Framework",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  scf init                    # Initialize current directory as SCF project
  scf init --guided           # Guided setup with foundation questions
  scf hub create              # Create your personal hub
  scf hub create ~/my-hub     # Create hub at specific location
  scf sync                    # Sync current project with hub
  scf sync --status           # Check sync status
  scf projects scan           # Discover projects

For more help: scf <command> --help
        """
    )

    parser.add_argument('--verbose', '-v', action='store_true', help='Verbose output')

    # Subcommands
    subparsers = parser.add_subparsers(dest='command', help='Available commands')

    # Init command
    init_parser = subparsers.add_parser('init', help='Initialize SCF in project')
    init_parser.add_argument('path', nargs='?', default='.', help='Project path (default: current directory)')
    init_parser.add_argument('--hub', action='store_true', help='[Deprecated] Use "scf hub create" instead')
    init_parser.add_argument('--guided', '-g', action='store_true', help='Guided setup with foundation questions')
    init_parser.add_argument('--fresh', action='store_true', help='Reset existing SCF files')

    # Hub command
    hub_parser = subparsers.add_parser('hub', help='Hub management (run "scf hub" for full help)')
    hub_parser.add_argument('action', nargs='?', choices=['create', 'locate', 'status', 'stats', 'projects', 'scan', 'learn', 'teach', 'help'],
                           help='Hub action')
    hub_parser.add_argument('target', nargs='?', help='Target project for learn/teach')
    hub_parser.add_argument('path', nargs='?', help='Hub path for create (default: ~/scf-hub)')
    hub_parser.add_argument('--non-interactive', action='store_true', help='Skip interactive prompts')
    hub_parser.add_argument('--add', metavar='PATH', help='Add project to hub')
    hub_parser.add_argument('--remove', metavar='NAME', help='Remove project from hub')
    hub_parser.add_argument('--info', metavar='NAME', help='Show project details')

    # Sync command
    sync_parser = subparsers.add_parser('sync', help='Sync with hub or check status')
    sync_parser.add_argument('path', nargs='?', help='Project path (default: current directory)')
    sync_parser.add_argument('--status', action='store_true', help='Check sync status only')

    # Server command
    server_parser = subparsers.add_parser('server', help='Local server management')
    server_parser.add_argument('action', choices=['start', 'stop', 'status'], help='Server action')
    server_parser.add_argument('--port', type=int, default=8765, help='Server port (default: 8765)')

    # Projects command (hub features)
    projects_parser = subparsers.add_parser('projects', help='Project discovery and management')
    projects_parser.add_argument('action', choices=['scan', 'health', 'learn'], help='Projects action')

    return parser


def main():
    """Main entry point for unified SCF CLI"""
    parser = create_parser()

    # If no arguments, show onboarding
    if len(sys.argv) == 1:
        onboarding = SCFOnboarding()
        onboarding.show_welcome()
        role = onboarding.choose_role()

        if role == "hub":
            print("\nüèóÔ∏è  Let's set up your SCF Hub:")
            print("Run: scf hub create")
        else:
            print(f"\nüíª Let's add SCF to your current project:")
            print("Run: scf init --guided")
        return

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        return

    # Route to appropriate command
    try:
        if args.command == 'init':
            SCFCommands.cmd_init(args)
        elif args.command == 'hub':
            SCFCommands.cmd_hub(args)
        elif args.command == 'sync':
            SCFCommands.cmd_sync(args)
        elif args.command == 'server':
            SCFCommands.cmd_server(args)
        elif args.command == 'projects':
            SCFCommands.cmd_projects(args)
        else:
            parser.print_help()

    except KeyboardInterrupt:
        print("\n\n‚ö†Ô∏è  Operation cancelled by user")
    except Exception as e:
        if hasattr(args, 'verbose') and args.verbose:
            import traceback
            traceback.print_exc()
        else:
            print(f"‚ùå Error: {e}")
            print("Use --verbose for detailed error info")


if __name__ == '__main__':
    main()
